<html><head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../documentation.js"></script>
<link rel="icon" type="image/png" sizes="32x32" href="../../../../../../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../../../../../images/favicon-16x16.png">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script>
$(document).ready(function() {

    // Hint languages to prevent false matches (php for example).
    hljs.configure({
        languages: ['perl', 'javascript', 'xml', 'html', 'css', 'json', 'yaml']
    });

    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Csomagátírás</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="OTRS 6 - Fejlesztői kézikönyv"><link rel="up" href="how-to-publish-extensions.html" title="4. fejezet - Hogyan tehetők közzé az OTRS kiterjesztések"><link rel="prev" href="package-building.html" title="Csomagkészítés"><link rel="next" href="contributing.html" title="5. fejezet - Közreműködés az OTRS-ben"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Csomagátírás</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="package-building.html">Vissza</a> </td><th width="60%" align="center">4. fejezet - Hogyan tehetők közzé az OTRS kiterjesztések</th><td width="20%" align="right"> <a accesskey="n" href="contributing.html">Előre</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="package-porting"></a>Csomagátírás</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6">OTRS 5-ről 6-ra</a></span></dt><dd><dl><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-datetime">Dátum- és időszámítás</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-user-multiupload">A fogd és vidd többszörös feltöltés hozzáadása</a></span></dt><dt><span class="section"><a href="package-porting.html#packge-porting-5-to-6-admin-modules">Az adminisztrációs képernyők továbbfejlesztései</a></span></dt><dd><dl><dt><span class="section"><a href="package-porting.html#packge-porting-5-to-6-breadcrumbs">Kenyérmorzsák hozzáadása az adminisztrációs képernyőkhöz</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-saveandcontinue"><span class="emphasis"><em>Mentés</em></span> és <span class="emphasis"><em>Mentés és befejezés</em></span>
gombok hozzáadása az adminisztrációs képernyőkhöz</a></span></dt></dl></dd><dt><span class="section"><a href="package-porting.html#packge-porting-5-to-6-configuration-files">Beállítófájlok költöztetése</a></span></dt><dd><dl><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-XML-config-file-format">XML beállítófájl formátum</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-perl-config-file-format">Perl beállítófájl formátum</a></span></dt></dl></dd><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-perldoc-structure">Megváltoztatott Perl-dokumentáció szerkezet</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-javascript-templating-improvements">Továbbfejlesztések a sablonozáshoz és a JavaScript használatával végzett
munkához</a></span></dt><dd><dl><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-javascript-refactor">A JavaScript eltávolításra került a sablonokból</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-richtext-template">A sablonfájlok eltávolításra kerültek a Rich Text szerkesztőből</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-javascript-translations">Fordítások a JavaScript fájlokban</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-javascript-handover">Adatok átadása Perlből JavaScriptbe</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-javascript-templates">HTML sablonok a JavaScripthez</a></span></dt></dl></dd><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-user-permissions">Felhasználói jogosultságok ellenőrzése</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-ticket-api">Jegy API változások</a></span></dt><dd><dl><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-ticket-api-ticketget"><code class="literal">TicketGet()</code></a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-ticket-api-linkobject-events"><code class="literal">LinkObject</code> események</a></span></dt></dl></dd><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-article-api">Bejegyzés API változások</a></span></dt><dd><dl><dt><span class="section"><a href="package-porting.html#otrs6-article-methods">Metabejegyzés API</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-article-backend-api">Bejegyzés háttérprogram API</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-article-search-index">Bejegyzéskeresési index</a></span></dt></dl></dd><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-sysconfig-changes">Rendszerbeállítás API változások</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-linkobject-changes"><code class="literal">LinkObject</code> API változások</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-postmaster-filter-communication-log">Kommunikációs napló támogatás a további levelezési szűrőkhöz</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-process-mailqueue-for-ut">Levelezési sor feldolgozása az egységtesztekhez</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-5-to-6-agentticketzoom-widget-handling">Felületi elem kezelés a jegynagyítás képernyőn</a></span></dt></dl></dd><dt><span class="section"><a href="package-porting.html#package-porting-4-to-5">OTRS 4-ről 5-re</a></span></dt><dd><dl><dt><span class="section"><a href="package-porting.html#id-1.5.4.4.3">Átszerkesztett <code class="filename">Kernel/Output/HTML</code></a></span></dt><dt><span class="section"><a href="package-porting.html#id-1.5.4.4.4">Elő-kimenetszűrők</a></span></dt><dt><span class="section"><a href="package-porting.html#id-1.5.4.4.5">IE 8 és IE 9</a></span></dt><dt><span class="section"><a href="package-porting.html#id-1.5.4.4.6">Általános felület API változás a „Ticket” csatlakozóban</a></span></dt><dt><span class="section"><a href="package-porting.html#id-1.5.4.4.7">Előnézeti függvények a dinamikus statisztikákban</a></span></dt><dt><span class="section"><a href="package-porting.html#id-1.5.4.4.8">Eldobott HTML nyomtatás</a></span></dt><dt><span class="section"><a href="package-porting.html#id-1.5.4.4.9">Továbbfejlesztett fordítási szöveg kinyerés</a></span></dt></dl></dd><dt><span class="section"><a href="package-porting.html#package-porting-33-to-4">OTRS 3.3-ról 4-re</a></span></dt><dd><dl><dt><span class="section"><a href="package-porting.html#package-porting-33-to-4-objectmanager">Új objektumkezelés</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-33-to-4-cache">Eltávolított <code class="literal">CacheInternalObject</code></a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-33-to-4-scheduler-location">Áthelyezett ütemező háttérprogram fájlok</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-33-to-4-sopm-code-tags">Kódszakaszok frissítése az SOPM
fájlokban</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-33-to-4-template-engine">Új sablonmotor</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-33-to-4-fontawesome">Új FontAwesome verzió</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-33-to-4-unit-tests">Egységtesztek</a></span></dt><dt><span class="section"><a href="package-porting.html#package-porting-33-to-4-custom-ticket-history-types">Egyéni jegy előzmény típusok</a></span></dt></dl></dd></dl></div><p>
        Az OTRS minden új hibajavító vagy fő verziójával át kell írnia a csomagjait,
és meg kell győződnie arról, hogy azok továbbra is működnek az OTRS API-val.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="package-porting-5-to-6"></a>OTRS 5-ről 6-ra</h3></div></div></div><p>
        Ez a szakasz azokat a változtatásokat sorolja fel, amelyeket meg kell
vizsgálnia, amikor átírja a csomagját az OTRS 5-ről 6-ra.
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-5-to-6-datetime"></a>Dátum- és időszámítás</h4></div></div></div><p>
            Az OTRS 6-ban egy új modul lett hozzáadva a dátum- és időszámításhoz:
<code class="literal">Kernel::System::DateTime</code>. A
<code class="literal">Kernel::System::Time</code> modul mostantól elavult, és többé
nem szabad használni új kódoknál.
        </p><p>
            Az új <code class="literal">Kernel::System::DateTime</code> modul legfőbb előnye, hogy
támogatja a valódi időzónákat (mint például
<code class="literal">Europe/Berlin</code>) az órákban számított időeltolások (mint
például <code class="literal">+2</code>) helyett. Ne feledje, hogy a régi
<code class="literal">Kernel::System::Time</code> modult is továbbfejlesztették az
időzónák támogatásához. Az időeltolások teljes mértékben eldobásra
kerültek. Ez azt jelenti, hogy az összes olyan kódot, amely időeltolásokat
használ a számításokhoz, át kell írni az új <code class="literal">DateTime</code>
modul használatához. Azok a kódok, amelyek önmaguk nem foglalkoznak az
időeltolásokkal, a legtöbb esetben maradhatnak érintetlenül. Mindössze arról
kell meggyőződnie, hogy a <code class="literal">Kernel::System::Time</code> objektum
létrehozásakor érvényes időzóna legyen megadva.
        </p><p>
            Itt egy példa az időeltolásos kód időzónákra történő átírásához:
        </p><p>
            </p><pre class="programlisting">
# Feltételezzünk egy 0 időeltolást ennél az objektumnál.
my $TimeObject     = $Kernel::OM-&gt;Get('Kernel::System::Time');
my $SystemTime     = $TimeObject-&gt;TimeStamp2SystemTime( String =&gt; '2004-08-14 22:45:00' );
# Általában beállításon vagy paraméteren keresztül van lekérve.
my $UserTimeZone   = '+2';
my $UserSystemTime = $SystemTime + $UserTimeZone * 3600;
my $UserTimeStamp  = $TimeObject-&gt;SystemTime2TimeStamp( SystemTime =&gt; $UserSystemTime );
            </pre><p>
        </p><p>
            Az új <code class="literal">Kernel::System::DateTime</code> modult használó kód:
        </p><p>
            </p><pre class="programlisting">
# Ez hallgatólagosan beállítja a beállított OTRS időzónát.
my $DateTimeObject = $Kernel::OM-&gt;Create('Kernel::System::DateTime');
# Általában beállításon vagy paraméteren keresztül van lekérve.
my $UserTimeZone   = 'Europe/Berlin';
$DateTimeObject-&gt;ToTimeZone( TimeZone =&gt; $UserTimeZone );
# Ne feledje, hogy az epoch független az időzónától, mindig az UTC-hez lesz kiszámítva.
my $SystemTime    = $DateTimeObject-&gt;ToEpoch();
my $UserTimeStamp = $DateTimeObject-&gt;ToString();
            </pre><p>
        </p><p>
            Ne feledje, hogy a <code class="literal">Kernel::System::DateTime</code> modulban lévő
új <code class="code">Get()</code> függvénnyel visszaadott időértékek vezető nulla nélkül
lesznek a <code class="literal">Kernel::System::Time</code> modulban lévő
<code class="code">SystemTime2Date()</code> függvény által visszaadottak helyett. Az új
<code class="literal">Kernel::System::DateTime</code> modulban a <code class="code">Format()</code>
függvény szövegként adja vissza a dátumot és időt a megadott formátum
szerint.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-5-to-6-user-multiupload"></a>A fogd és vidd többszörös feltöltés hozzáadása</h4></div></div></div><p>
            Az OTRS 6-nál egy több mellékletet feltöltő funkcionalitás lett
hozzáadva. Ahhoz, hogy a több melléklet feltöltését megvalósítsa az egyéb
kiterjesztésekben, a melléklet rész, valamint a
<code class="code">JSOnDocumentComplete</code> részek eltávolítása szükséges a
sablonfájlokból (<code class="literal">AttachmentDelete</code> és
<code class="literal">AttachmentUpload</code>). Tartsa észben, hogy néhány esetben a
JavaScript részek már kihelyezésre kerültek a
<code class="filename">Core.Agent.XXX</code> fájlokba.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
                Ne feledje, hogy ez jelenleg csak olyan helyeknél alkalmazható, ahol
tulajdonképpen van értelme a több fájl feltöltési lehetőségének (mint
például <code class="literal">AgentTicketPhone</code>,
<code class="literal">AgentTicketCompose</code>, stb.). Ez nem használható mindenféle
beállítás nélkül az adminisztrátori képernyőknél.
            </p></div><p>
            Ahhoz, hogy az új több melléklet feltöltést tartalmazza a sablon, cserélje
le a meglévő <code class="code">input type="file"</code> elemet a következő kódra a
<code class="filename">.tt</code> sablonfájlban:
        </p><p>
            </p><pre class="programlisting">
&lt;label&gt;[% Translate("Attachments") | html %]:&lt;/label&gt;
&lt;div class="Field"&gt;
[% INCLUDE "FormElements/AttachmentList.tt" %]
&lt;/div&gt;
&lt;div class="Clear"&gt;&lt;/div&gt;
            </pre><p>
        </p><p>
            Az is szükséges, hogy eltávolítsa az <code class="code">IsUpload</code> változót és az
összes egyéb <code class="code">IsUpload</code> részt a Perl-modulból. Az olyan kódrészek
nem szükségesek többé, mint a következők:
        </p><p>
            </p><pre class="programlisting">
my $IsUpload = ( $ParamObject-&gt;GetParam( Param =&gt; 'AttachmentUpload' ) ? 1 : 0 );
            </pre><p>
        </p><p>
            Ezenkívül a melléklet megjelenítő blokkot is le kell cserélni:
        </p><p>
            </p><pre class="programlisting">
$LayoutObject-&gt;Block(
    Name =&gt; 'Attachment',
    Data =&gt; $Attachment,
);
            </pre><p>
        </p><p>
            Cserélje le erre a kódra:
        </p><p>
            </p><pre class="programlisting">
push @{ $Param{AttachmentList} }, $Attachment;
            </pre><p>
        </p><p>
            Ha a modul, ahová integrálni szeretné a többszörös feltöltést, támogatja a
szabványos sablonokat, akkor győződjön meg arról, hogy hozzáadott-e egy
szakaszt az ember által olvasható fájlméret formátumok megjelenítéséhez
közvetlenül azután, hogy a kiválasztott sablon melléklete be lett töltve
(nézze meg az <code class="literal">AgentTicketPhone</code> modult hivatkozásként):
        </p><p>
            </p><pre class="programlisting">
for my $Attachment (@TicketAttachments) {
    $Attachment-&gt;{Filesize} = $LayoutObject-&gt;HumanReadableDataSize(
        Size =&gt; $Attachment-&gt;{Filesize},
    );
}
            </pre><p>
        </p><p>
            Mikor Selenium egységteszteket ad az átírt modulokhoz, akkor vessen egy
pillantást a <code class="filename">Selenium/Agent/MultiAttachmentUpload.t</code>
fájlra hivatkozásként.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="packge-porting-5-to-6-admin-modules"></a>Az adminisztrációs képernyők továbbfejlesztései</h4></div></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="packge-porting-5-to-6-breadcrumbs"></a>Kenyérmorzsák hozzáadása az adminisztrációs képernyőkhöz</h5></div></div></div><p>
                Az OTRS 6-ban az összes adminisztrációs modulnak tartalmaznia kell egy
kenyérmorzsát. A kenyérmorzsát csak a <code class="filename">.tt</code> sablonfájlban
kell hozzáadni, és közvetlenül a h1 címsor után kell elhelyezni a fájl felső
részén. Ezenkívül a címsornak meg kell kapnia az <code class="code">InvisibleText</code>
osztályt, hogy csak a képernyőfelolvasóknak legye
<span class="emphasis"><em>láthatóvá</em></span>.
            </p><pre class="programlisting">
&lt;div class="MainBox ARIARoleMain LayoutFixedSidebar SidebarFirst"&gt;
    &lt;h1 class="InvisibleText"&gt;[% Translate("Name of your module") | html %]&lt;/h1&gt;
[% BreadcrumbPath = [
        {
            Name =&gt; Translate('Name of your module'),
        },
    ]
%]
[% INCLUDE "Breadcrumb.tt" Path = BreadcrumbPath %]
...
            </pre><p>
                Győződjön meg arról, hogy hozzáadta-e a megfelelő kenyérmorzsát az
adminisztrációs modul összes szintjéhez (például
<code class="literal">Subaction</code>):
            </p><pre class="programlisting">
[% BreadcrumbPath = [
        {
            Name =&gt; Translate('Module Home Screen'),
            Link =&gt; Env("Action"),
        },
        {
            Name =&gt; Translate("Some Subaction"),
        },
    ]
%]

[% INCLUDE "Breadcrumb.tt" Path = BreadcrumbPath %]
                </pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-saveandcontinue"></a><span class="emphasis"><em>Mentés</em></span> és <span class="emphasis"><em>Mentés és befejezés</em></span>
gombok hozzáadása az adminisztrációs képernyőkhöz</h5></div></div></div><p>
                Az OTRS 6-ban az adminisztrációs modulok nemcsak egy
<span class="emphasis"><em>Mentés</em></span> gombot tartalmaznak, hanem egy <span class="emphasis"><em>Mentés
és befejezés</em></span> gombot is. A <span class="emphasis"><em>Mentés</em></span> gombnak
ugyanazon a szerkesztőoldalon kell hagynia a felhasználót mentés után, míg a
<span class="emphasis"><em>Mentés és befejezés</em></span> gombnak vissza kell vinnie annak az
entitásnak az áttekintőjére, amin a felhasználó jelenleg dolgozik. Nézze meg
a meglévő OTRS adminisztrációs képernyőit hivatkozásként.
            </p><p>
                </p><pre class="programlisting">
&lt;div class="Field SpacingTop SaveButtons"&gt;
    &lt;button class="Primary CallForAction" id="SubmitAndContinue" type="submit" value="[% Translate("Save") | html %]"&gt;&lt;span&gt;[% Translate("Save") | html %]&lt;/span&gt;&lt;/button&gt;
    [% Translate("or") | html %]
    &lt;button class="Primary CallForAction" id="Submit" type="submit" value="[% Translate("Save") | html %]"&gt;&lt;span&gt;[% Translate("Save and finish") | html %]&lt;/span&gt;&lt;/button&gt;
    [% Translate("or") | html %]
    &lt;a href="[% Env("Baselink") %]Action=[% Env("Action") %]"&gt;&lt;span&gt;[% Translate("Cancel") | html %]&lt;/span&gt;&lt;/a&gt;
&lt;/div&gt;
                </pre><p>
            </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="packge-porting-5-to-6-configuration-files"></a>Beállítófájlok költöztetése</h4></div></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-XML-config-file-format"></a>XML beállítófájl formátum</h5></div></div></div><p>
                Az OTRS 6 egy új <a class="link" href="how-it-works.html#xml-config" title="XML beállítófájlok">XML beállítófájl
formátumot</a> használ, és a beállítófájlok helye áthelyezésre került a
<code class="filename">Kernel/Config/Files</code> mappából a
<code class="filename">Kernel/Config/Files/XML</code> mappába. A meglévő XML
beállítófájloknak az új formátumra és helyre történő átalakításához
használhatja a következő eszközt, amely az OTRS keretrendszer része:
            </p><p>
                </p><pre class="programlisting">
bin/otrs.Console.pl Dev::Tools::Migrate::ConfigXMLStructure --source-directory Kernel/Config/Files
Migrating configuration XML files...
Kernel/Config/Files/Calendar.xml -&gt; Kernel/Config/Files/XML/Calendar.xml... Done.
Kernel/Config/Files/CloudServices.xml -&gt; Kernel/Config/Files/XML/CloudServices.xml... Done.
Kernel/Config/Files/Daemon.xml -&gt; Kernel/Config/Files/XML/Daemon.xml... Done.
Kernel/Config/Files/Framework.xml -&gt; Kernel/Config/Files/XML/Framework.xml... Done.
Kernel/Config/Files/GenericInterface.xml -&gt; Kernel/Config/Files/XML/GenericInterface.xml... Done.
Kernel/Config/Files/ProcessManagement.xml -&gt; Kernel/Config/Files/XML/ProcessManagement.xml... Done.
Kernel/Config/Files/Ticket.xml -&gt; Kernel/Config/Files/XML/Ticket.xml... Done.

Done.
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-perl-config-file-format"></a>Perl beállítófájl formátum</h5></div></div></div><p>
                Az OTRS 6 felgyorsítja a beállítófájlok betöltését a régi beállítási
formátum (1) támogatásának eldobásával, amely csak egymás utáni Perl kódot
használ, és az <code class="literal">eval</code> által kellett futtatni, és ehelyett
kényszerítve az új csomagalapú formátumot (1.1) a Perl beállítófájloknál. Az
OTRS 6+ csak az ebben a formátumban lévő fájlokat tudja betölteni, ezért
győződjön meg arról, hogy átalakította-e az összes egyéni fejlesztést erre
(lásd <code class="filename">Kernel/Config/Files/ZZZ*.pm</code> például). Minden
egyes Perl beállítófájlnak tartalmaznia kell egy csomagot a
<code class="literal">Load()</code> metódussal.
            </p><p>
                Régebben a Perl beállítófájlokat néha rossz célra használták egy automatikus
betöltő mechanizmusként a meglévő csomagokban lévő kód felülírásához. Ez
többé nem szükséges, mivel az OTRS 6 biztosít egy dedikált
<code class="literal">Autoload</code> mechanizmust. Nézze meg a
<code class="filename">Kernel/Autoload/Test.pm</code> fájlt annak bemutatásához, hogy
hogyan kell használni ezt a mechanizmust egy metódus hozzáadásához egy
meglévő fájlba.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-5-to-6-perldoc-structure"></a>Megváltoztatott Perl-dokumentáció szerkezet</h4></div></div></div><p>
            A Perl-fájlokban lévő POD szerkezete kis mértékben javítva lett, és
alkalmazni kell az összes fájlban. A POD mostantól kényszerítve van, hogy
szintaktikailag helyes legyen.
        </p><p>
            Amit korábban <code class="literal">SYNOPSIS</code> szakasznak hívtak, azt most
<code class="literal">DESCRIPTION</code> névre változtatták, mivel a szinopszis
jellemzően néhány népszerű kódhasználati példát biztosít, és nem magának a
modulnak a leírását. Természetesen megadható további szinopszis. Itt egy
példa arra, hogy hogyan:
        </p><p>
            </p><pre class="programlisting">
=head1 NAME

Kernel::System::ObjectManager - Központi egyke kezelő és objektumpéldány előállító

=head1 SYNOPSIS

# Csak felső szintű parancsfájlokban!
local $Kernel::OM = Kernel::System::ObjectManager-&gt;new();

# Bárhol: egyke példány lekérése (és létrehozása, ha szükséges).
my $ConfigObject = $Kernel::OM-&gt;Get('Kernel::Config');

# Egyke objektumok és az összes függőségük eltávolítása.
$Kernel::OM-&gt;ObjectsDiscard(
    Objects            =&gt; ['Kernel::System::Ticket', 'Kernel::System::Queue'],
);

=head1 DESCRIPTION

Az objektumkezelő egy központi hely az egyke OTRS objektumok létrehozásához
és hozzáféréséhez (a C&lt;L&lt;/Get()&gt;&gt; metóduson keresztül), valamint szabályos
(nem kezelt) objektumpéldányok létrehozásához (a C&lt;L&lt;/Create()&gt;&gt; metóduson
keresztül).

            </pre><p>
        </p><p>
            Abban az esetben, ha a <code class="literal">DESCRIPTION</code> nem ad hozzá semmilyen
értéket a <code class="literal">NAME</code> szakaszban lévő sorhoz, akkor át kell írni
vagy teljesen el kell távolítani.
        </p><p>
            A második fontos változtatás, hogy a függvények mostantól
<code class="literal">=head2</code> szakaszként vannak dokumentálva a korábban
használt <code class="literal">=item</code> helyett.
        </p><p>
            </p><pre class="programlisting">
=head2 Get()

Lekér egy egyke objektumot, és ha még nem létezik, akkor a háttérben létrehoz egyet.

my $ConfigObject = $Kernel::OM-&gt;Get('Kernel::Config');

# Második meghíváskor visszaadja ugyanazt a ConfigObject objektumot, mint ami fent van.
my $ConfigObject2 = $Kernel::OM-&gt;Get('Kernel::Config');

=cut

sub Get { ... }
            </pre><p>
        </p><p>
            Ezek a változtatások egy továbbfejlesztett internetes API dokumentációhoz
vezetnek, amint az objektumkezelő dokumentációjában is látható az <a class="ulink" href="http://otrs.github.io/doc/api/otrs/5.0/Perl/Kernel/System/ObjectManager.pm.html" target="_top">OTRS
5</a> és az <a class="ulink" href="http://otrs.github.io/doc/api/otrs/6.0/Perl/Kernel/System/ObjectManager.pm.html" target="_top">OTRS
6</a> esetén.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-javascript-templating-improvements"></a>Továbbfejlesztések a sablonozáshoz és a JavaScript használatával végzett
munkához</h4></div></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-javascript-refactor"></a>A JavaScript eltávolításra került a sablonokból</h5></div></div></div><p>
                Az OTRS 6-tal az összes JavaScript - különösen a
<code class="literal">JSOnDocumentComplete</code> blokkokban lévők - eltávolításra
kerültek a sablonfájlokból, és át lettek helyezve JavaScript fájlokba. Csak
nagyon ritka feltételek esetén szükséges a JavaScript kódot a sablonfájlokon
belül elhelyezni. Minden egyéb előfordulásnál tegye a JS kódot a modulra
jellemző JavaScript fájlokba. Az ilyen JavaScript fájlokban lévő
<code class="literal">Init()</code> metódus automatikusan végre lesz hajtva a fájl
betöltésekor (az eseménykötések előkészítéséhez, stb.), ha regisztrálja a
JavaScript fájlt az OTRS alkalmazásban. Ezt a
<code class="literal">Core.Init.RegisterNamespace(TargetNS, 'APP_MODULE');</code>
végrehajtásával lehet elvégezni a névtér meghatározásának végén a JavaScript
fájlon belül.
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-richtext-template"></a>A sablonfájlok eltávolításra kerültek a Rich Text szerkesztőből</h5></div></div></div><p>
                A sablonfájlokon belül lévő JavaScript újraírása mellett (lásd fent) a Rich
Text szerkesztő (<code class="literal">RichTextEditor.tt</code> és
<code class="literal">CustomerRichTextEditor.tt</code>) sablonfájljai is eltávolításra
kerültek, mivel azok többé nem szükségesek.
            </p><p>
                Általában ezek a sablonfájlok voltak megtalálhatók a modulra jellemző
sablonfájlokban egy blokkon belül:
            </p><p>
                </p><pre class="programlisting">
[% RenderBlockStart("RichText") %]
[% InsertTemplate("RichTextEditor.tt") %]
[% RenderBlockEnd("RichText") %]
                </pre><p>
            </p><p>
                Erre többé nincs szükség, és eltávolítható. Ahelyett, hogy meghívná ezt a
blokkot a Perl-modulból, mostantól szükség van a szükséges Rich Text
paraméter beállítására ott. Ahelyett, hogy:
            </p><p>
                </p><pre class="programlisting">
$LayoutObject-&gt;Block(
    Name =&gt; 'RichText',
    Data =&gt; \%Param,
);
                </pre><p>
            </p><p>
                mostantól ezt kell meghívnia:
            </p><p>
                </p><pre class="programlisting">
$LayoutObject-&gt;SetRichTextParameters(
    Data =&gt; \%Param,
);
                </pre><p>
            </p><p>Ugyanez a szabály alkalmazható az ügyfélfelületre is. Távolítsa el a Rich
Text blokkokat a <code class="filename">CustomerRichTextEditor.tt</code> fájlból, és
inkább a következő kódot alkalmazza:</p><p>
                </p><pre class="programlisting">
$LayoutObject-&gt;CustomerSetRichTextParameters(
    Data =&gt; \%Param,
);
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-javascript-translations"></a>Fordítások a JavaScript fájlokban</h5></div></div></div><p>
                A lefordítható szövegek hozzáadása a JavaScript fájlokban eléggé nehéz volt
az OTRS-ben. A szöveget le kellett fordítani a Perl-modulban vagy a
sablonban, majd ezután kellett átküldeni a JavaScript függvénynek. Az OTRS
6-tal a szövegek lefordítása közvetlenül a JavaScript fájlokban
lehetséges. Az összes egyéb kerülőmegoldást el kell távolítani, különösen a
csak a sablonokban lévő, a szövegek lefordításához használt blokkokat.
            </p><p>
                Ehelyett az új <code class="literal">Core.Language</code> JavaScript fordítási
névteret kell használni a szövegek lefordításához közvetlenül a JavaScript
fájlokban:
            </p><p>
                </p><pre class="programlisting">
Core.Language.Translate('The string to translate');
                </pre><p>
            </p><p>
                Lehetséges továbbá JavaScript változókat átadni, amelyek ki lesznek cserélve
közvetlenül a szövegben:
            </p><p>
                </p><pre class="programlisting">
Core.Language.Translate('The %s to %s', 'string', 'translate');
                </pre><p>
            </p><p>
                Minden egyes <code class="literal">%s</code> helykitöltő a további paraméterként
átadott változóval lesz kicserélve. A paraméterek száma nincs korlátozva.
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-javascript-handover"></a>Adatok átadása Perlből JavaScriptbe</h5></div></div></div><p>
                A sablonfájlok JavaScript kód nélküli eléréséhez néhány egyéb
kerülőmegoldást is meg kellett tenni a megfelelő megoldáshoz. A fordítások
mellett az adatok átadása a Perlből a JavaScriptbe továbbra is probléma az
OTRS-ben. A kerülőmegoldás az volt, hogy egy JavaScript blokkot adtak a
sablonba, amelyben a JavaScript változók meg lettek határozva és fel lettek
töltve a sablon címkéivel a Perlből a sablonba átadott adatok alapján.
            </p><p>
                Az adatok Perlből JavaScriptbe történő átadásának folyamata mostantól sokkal
egyszerűbb az OTRS 6-ban. Ahhoz, hogy bizonyos adatokat változóként küldjön
át a Perlből a JavaScriptbe, valakinek csak egy függvényt kell meghívnia a
Perl oldalon. Ezután az adatok automatikusa elérhetők lesznek a
JavaScriptben.
            </p><p>
                A Perlben csak ezt kell meghívni:
            </p><p>
                </p><pre class="programlisting">
$Self-&gt;{LayoutObject}-&gt;AddJSData(
    Key   =&gt; 'KeyToBeAvailableInJS',
    Value =&gt; $YourData,
);
                </pre><p>
            </p><p>
                A <code class="literal">Value</code> paraméter automatikusan át lesz alakítva JSON
objektummá, és tartalmazhat összetett adatokat is.
            </p><p>
                A JavaScriptben az adatokat ezzel kaphatja meg:
            </p><p>
                </p><pre class="programlisting">
Core.Config.Get('KeyToBeAvailableInJS');
            </pre><p>
            </p><p>
                Ez felváltja az összes kerülőmegoldást, amiket el kell távolítani egy modul
OTRS 6-ra történő átírásakor, mert a sablonfájlokban lévő JavaScript
mostantól csak nagyon ritka feltételek esetén engedélyezett (lást fent).
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-javascript-templates"></a>HTML sablonok a JavaScripthez</h5></div></div></div><p>
                Az OTRS 6 egy új JavaScript API-t vezet be a
<code class="literal">Core.Template</code> osztályon keresztül. Hasonló módon
használhatja a JavaScript kódjában mint ahogy a
<code class="literal">TemplateToolkit</code> modult használta a Perl kódból.
            </p><p>
                Itt egy példa a meglévő <code class="literal">jQuery</code> alapú kód átírásához az új
sablon API-ra:
            </p><p>
                </p><pre class="programlisting">
var DivID = 'MyDiv',
    DivText = 'Helló, Világ!';

$('&lt;div /&gt;').addClass('CSSClass')
    .attr('id', DivID)
    .text(DivText)
    .appendTo('body');
                </pre><p>
            </p><p>
                Először győződjön meg arról, hogy létrehozott-e egy új sablonfájlt a
<code class="literal">Kernel/Output/JavaScript/Templates/Standard</code> mappa
alatt. Ehhez a következőket kell észben tartania:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            Hozzon létre egy almappát a <code class="literal">Modulja</code> nevével.
                        </p></li><li class="listitem"><p>
                            Újrahasználhatja a meglévő almappa szerkezetet, de csak akkor, ha van
értelme a komponensénél (például <code class="literal">Agent/SajatModul/</code> vagy
<code class="literal">Agent/Admin/SajatModul/</code>).
                        </p></li><li class="listitem"><p>
                            Használjon <code class="literal">.html.tmpl</code> kiterjesztést a sablonfájlnál.
                        </p></li><li class="listitem"><p>
                            Tömören és világosan nevezze el a sablonokat annak érdekében, hogy elkerülje
a félreértéseket (például jó:
<code class="literal">Agent/SajatModul/SettingsDialog.html.tmpl</code>, rossz:
<code class="literal">Agent/SettingsDialogTemplate.html.tmpl</code>).
                        </p></li></ul></div><p>
            </p><p>
                Ezután adja hozzá a HTML-t a sablonfájlhoz, meggyőződve arról, hogy
helykitöltőket használ minden olyan változónál, amire szüksége lehet:
            </p><p>
                </p><pre class="programlisting">
&lt;div id="{{ DivID }}" class="CSSClass"&gt;
    {{ DivText | Translate }}
&lt;/div&gt;
                </pre><p>
            </p><p>
                Majd egyszerűen jeleníttesse meg a HTML-t a
<code class="literal">Core.Template.Render</code> metódusnak a sablon elérési útjával
(kiterjesztés nélkül) és a változókat tartalmazó objektummal való
meghívásával a helyettesítéshez:
            </p><p>
                </p><pre class="programlisting">
var DivHTML = Core.Template.Render('Agent/MyModule/SettingsDialog', {
    DivID: 'MyDiv',
    DivText: 'Helló, Világ!'
});

$(DivHTML).appendTo('body');
                </pre><p>
            </p><p>
                Belsőleg a <code class="literal">Core.Template</code> a Nunjucks motort használja a
sablonok feldolgozásához. Lényegében bármilyen érvényes Nunjucks szintaxis
támogatott, nézze meg a <a class="ulink" href="https://mozilla.github.io/nunjucks/templating.html" target="_top">dokumentációjukat</a>
a további információkért.
            </p><p>
                Itt van néhány tipp:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            Használhatja a <code class="literal">| Translate</code> szűrőt a szövegek
lefordításához az aktuális nyelvre.
                        </p></li><li class="listitem"><p>
                            Az összes <code class="literal">{{ VarName }}</code> változókimenet alapértelmezetten
HTML elfedésben részesített. Ha valamilyen meglévő HTML-t szeretne kiíratni,
akkor használja a <code class="literal">| safe</code> szűrőt az elfedés
megkerüléséhez.
                        </p></li><li class="listitem"><p>
                            Használja az <code class="literal">| urlencode</code> szűrőt az URL paramétereinek
kódolásához.
                        </p></li><li class="listitem"><p>
                            A helyettesítő objektumban lévő összetett szerkezetek is támogatottak,
szóval nyugodtan átadhat tömböket vagy kivonatokat, és végiglépkedhet rajtuk
közvetlenül a sablonban. Például nézze meg a <code class="literal">{% for %}</code>
szintaxist a <a class="ulink" href="https://mozilla.github.io/nunjucks/templating.html#for" target="_top">Nunjucks
dokumentációjában</a>.
                        </p></li></ul></div><p>
            </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-5-to-6-user-permissions"></a>Felhasználói jogosultságok ellenőrzése</h4></div></div></div><p>
            Az OTRS 6 előtt a felhasználói jogosultságok a munkamenetben voltak
eltárolva és attribútumként lettek átadva a <code class="code">LayoutObject</code>
objektumnak, amely viszont ezután hozzáfért a meghatározott felhasználói
jogosultságokhoz, mint például <code class="code">if
($LayoutObject-&gt;{'UserIsGroup[admin]'}) { ... }</code>.
        </p><p>
            Az OTRS 6-tal a jogosultságok többé nincsenek a munkamenetben eltárolva, és
nem kerülnek átadásra a <code class="code">LayoutObject</code> objektumnak sem. Cserélje
ki a kódjában, hogy a <code class="code">PermissionCheck()</code> metódust hívja meg a
<code class="code">Kernel::System::Group</code> modulon (ügyintézőknél) vagy a
<code class="code">Kernel::System::CustomerGroup</code> modulon (ügyfeleknél). Itt egy
példa:
        </p><p>
            </p><pre class="programlisting">
my $HasPermission = $Kernel::OM-&gt;Get('Kernel::System::Group')-&gt;PermissionCheck(
UserID    =&gt; $UserID,
GroupName =&gt; $GroupName,
Type      =&gt; 'move_into',
);
            </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-5-to-6-ticket-api"></a>Jegy API változások</h4></div></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-ticket-api-ticketget"></a><code class="literal">TicketGet()</code></h5></div></div></div><p>
                Az OTRS 6-nál az összes kiterjesztést ellenőrizni kell, és át kell írni a
<code class="literal">$Ticket{SolutionTime}</code> értékről
<code class="literal">$Ticket{Closed}</code> értékre, ha a
<code class="literal">TicketGet()</code> az <code class="literal">Extended</code> paraméterrel
lett meghívva (nézze meg a <a class="ulink" href="https://bugs.otrs.org/show_bug.cgi?id=11872" target="_top">11872</a>-s hibát).
            </p><p>
                Ezenkívül a <code class="literal">ticket.create_time_unix</code> adatbázisoszlop
eltávolításra került, és hasonlóképpen a <code class="literal">CreateTimeUnix</code>
érték is el lett távolítva a <code class="literal">TicketGet()</code> eredményeként
kapott adatokból. Használja helyette a <code class="literal">Created</code> értéket
(<code class="literal">ticket.create_time</code> adatbázisoszlop).
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-ticket-api-linkobject-events"></a><code class="literal">LinkObject</code> események</h5></div></div></div><p>
                Az OTRS 6-ban a régi, jegyekre jellemző <code class="literal">LinkObject</code>
események el lettek dobva:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">TicketSlaveLinkAdd</code></p></li><li class="listitem"><p><code class="literal">TicketSlaveLinkDelete</code></p></li><li class="listitem"><p><code class="literal">TicketMasterLinkDelete</code></p></li></ul></div><p>
            </p><p>
                Ehelyett az ezekre figyelő összes eseménykezelőt át kell írni az két új
eseményre:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">LinkObjectLinkAdd</code></p></li><li class="listitem"><p><code class="literal">LinkObjectLinkDelete</code></p></li></ul></div><p>
            </p><p>
                Ezek az új események mindig aktiválva lesznek, amikor egy kapcsolatot
hozzáad vagy töröl a <code class="literal">LinkObject</code>, tekintet nélkül az
objektum típusára. A <code class="literal">Data</code> paraméter tartalmazni fogja az
összes információt, amire az eseménykezelőjének szüksége lehet a további
feldolgozáshoz, például:
            </p><p>
                </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">SourceObject</code></span></dt><dd><p>
                                A kapcsolat forrásobjektumának neve (például <code class="literal">Ticket</code>).
                            </p></dd><dt><span class="term"><code class="literal">SourceKey</code></span></dt><dd><p>
                                A kapcsolat forrásobjektumának kulcsa (például <code class="literal">TicketID</code>).
                            </p></dd><dt><span class="term"><code class="literal">TargetObject</code></span></dt><dd><p>
                                A kapcsolat célobjektumának neve (például <code class="literal">FAQItem</code>).
                            </p></dd><dt><span class="term"><code class="literal">TargetKey</code></span></dt><dd><p>
                                A kapcsolat célobjektumának kulcsa (például <code class="literal">FAQItemID</code>).
                            </p></dd><dt><span class="term"><code class="literal">Type</code></span></dt><dd><p>
                                A kapcsolat típusa (például <code class="literal">ParentChild</code>).
                            </p></dd><dt><span class="term"><code class="literal">State</code></span></dt><dd><p>
                                A kapcsolat állapota (<code class="literal">Valid</code> vagy
<code class="literal">Temporary</code>).
                            </p></dd></dl></div><p>
            </p><p>
                Ezekkel az új eseményekkel az egyéni <code class="literal">LinkObject</code> modulra
jellemző bármely esemény megvalósításai eldobhatók, és az összes
eseménykezelő átírható ezek használatára helyette. Mivel a forrás- és a
célobjektumnevek magában az eseményben is meg vannak adva, magától értetődő
lehet, hogy csak különleges helyzetekben legyenek futtatva.
            </p><p>
                Ahhoz, hogy az eseménykezelőt regisztrálja ezekhez az új eseményekhez,
győződjön meg arról, hogy hozzáadott-e egy regisztrációt a beállításokhoz,
például:
            </p><p>
                </p><pre class="programlisting">
&lt;!-- OLD STYLE --&gt;
&lt;ConfigItem Name="LinkObject::EventModulePost###1000-SampleModule" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Event handler for sample link object module.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Core::Event::Package&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::System::LinkObject::Event::SampleModule&lt;/Item&gt;
            &lt;Item Key="Event"&gt;(LinkObjectLinkAdd|LinkObjectLinkDelete)&lt;/Item&gt;
            &lt;Item Key="Transaction"&gt;1&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;

&lt;!-- NEW STYLE --&gt;
&lt;Setting Name="LinkObject::EventModulePost###1000-SampleModule" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Event handler for sample link object module.&lt;/Description&gt;
    &lt;Navigation&gt;Core::Event::Package&lt;/Navigation&gt;
    &lt;Value&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::System::LinkObject::Event::SampleModule&lt;/Item&gt;
            &lt;Item Key="Event"&gt;(LinkObjectLinkAdd|LinkObjectLinkDelete)&lt;/Item&gt;
            &lt;Item Key="Transaction"&gt;1&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Value&gt;
&lt;/Setting&gt;
                </pre><p>
            </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-5-to-6-article-api"></a>Bejegyzés API változások</h4></div></div></div><p>
            Az OTRS 6-ban változások történtek a bejegyzés API-n az új <span class="emphasis"><em>Omni
Channel</em></span> infrastruktúra előkészítéséhez.
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="otrs6-article-methods"></a>Metabejegyzés API</h5></div></div></div><p>
                A bejegyzés objektum mostantól olyan felső szintű bejegyzésfüggvényeket
biztosít, amelyek nem vonják be a háttérprogramhoz kapcsolódó adatokat.
            </p><p>
                A következő, bejegyzésre vonatkozó metódusok át lettek helyezve a
<code class="literal">Kernel::System::Ticket::Article</code> objektumba:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">ArticleFlagSet()</code></p></li><li class="listitem"><p><code class="literal">ArticleFlagDelete()</code></p></li><li class="listitem"><p><code class="literal">ArticleFlagGet()</code></p></li><li class="listitem"><p><code class="literal">ArticleFlagsOfTicketGet()</code></p></li><li class="listitem"><p><code class="literal">ArticleAccountedTimeGet()</code></p></li><li class="listitem"><p><code class="literal">ArticleAccountedTimeDelete()</code></p></li><li class="listitem"><p><code class="literal">ArticleSenderTypeList()</code></p></li><li class="listitem"><p><code class="literal">ArticleSenderTypeLookup()</code></p></li><li class="listitem"><p><code class="literal">SearchStringStopWordsFind()</code></p></li><li class="listitem"><p><code class="literal">SearchStringStopWordsUsageWarningActive()</code></p></li></ul></div><p>
            </p><p>
                Ha hivatkozik ezen metódusok bármelyikére a
<code class="literal">Kernel::System::Ticket</code> objektumon keresztül a kódjában,
akkor váltson át a bejegyzés objektum használatára helyette. Például:
            </p><p>
                </p><pre class="programlisting">
    my $ArticleObject = $Kernel::OM-&gt;Get('Kernel::System::Ticket::Article');

    my %ArticleSenderTypeList = $ArticleObject-&gt;ArticleSenderTypeList();
                </pre><p>
            </p><p>
                Az új <code class="literal">ArticleList()</code> metódust mostantól a bejegyzés
objektum biztosítja, és bejegyzések felsorolásához és kereséséhez
használható. Ez a metódus szűrőket és bejegyzésszámozást valósít meg,
valamint a bejegyzés metaadatait csak rendezett listaként adja
vissza. Például:
            </p><p>
                </p><pre class="programlisting">
my @Articles = $ArticleObject-&gt;ArticleList(
    TicketID             =&gt; 123,
    CommunicationChannel =&gt; 'Email',            # elhagyható, korlátozás egy bizonyos kommunikációs csatornára
    SenderType           =&gt; 'customer',         # elhagyható, korlátozás egy bizonyos bejegyzés küldőtípusra
    IsVisibleForCustomer =&gt; 1,                  # elhagyható, korlátozás egy bizonyos láthatóságra
    OnlyFirst            =&gt; 1,                  # elhagyható, csak az első egyezést adja vissza, vagy
    OnlyLast             =&gt; 1,                  # elhagyható, csak az utolsó egyezést adja vissza
);
                </pre><p>
            </p><p>
                A következő, bejegyzésekre vonatkozó metódusok mindegyike el lett dobva. Ha
ezek közül bármelyiket használja a kódjában, akkor értékelje ki az
alternatívák lehetőségeit.
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                              <code class="literal">ArticleFirstArticle()</code> (használja az <code class="literal">ArticleList(
OnlyFirst =&gt; 1 )</code> metódust helyette)
                          </p></li><li class="listitem"><p>
                              <code class="literal">ArticleLastCustomerArticle()</code> (használja az
<code class="literal">ArticleList( SenderType =&gt; 'customer', OnlyLast =&gt; 1 )</code>
metódust vagy hasonlót)
                          </p></li><li class="listitem"><p><code class="literal">ArticleCount()</code> (használja az
<code class="literal">ArticleList()</code> metódust helyette)</p></li><li class="listitem"><p>
                              <code class="literal">ArticlePage()</code> (újraírva az
<code class="literal">AgentTicketZoom</code> modulban)
                          </p></li><li class="listitem"><p><code class="literal">ArticleTypeList()</code></p></li><li class="listitem"><p><code class="literal">ArticleTypeLookup()</code></p></li><li class="listitem"><p><code class="literal">ArticleIndex()</code> (használja az
<code class="literal">ArticleList()</code> metódust helyette)</p></li><li class="listitem"><p><code class="literal">ArticleContentIndex()</code></p></li></ul></div><p>
            </p><p>
                A bejegyzésadatokkal való munkához használja az új bejegyzés háttérprogram
API-t. A bejegyzés megfelelő háttérprogram-objektumának lekéréséhez
használja a következőt:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">BackendForArticle(%Article)</code></p></li><li class="listitem"><p><code class="literal">BackendForChannel( ChannelName =&gt; $ChannelName )</code></p></li></ul></div><p>
            </p><p>
                A <code class="literal">BackendForArticle()</code> visszaadja a megfelelő
háttérprogramot egy adott bejegyzésnél vagy az érvénytelen háttérprogramot
azért, hogy mindig számíthasson egy háttérprogram-objektum példányra,
amelyet használhat sorozatos hívásoknál.
            </p><p>
                </p><pre class="programlisting">
my $ArticleBackendObject = $ArticleObject-&gt;BackendForArticle( TicketID =&gt; 42, ArticleID =&gt; 123 );
                </pre><p>
            </p><p>
                A <code class="literal">BackendForChannel()</code> visszaadja a megfelelő
háttérprogramot egy adott kommunikációs csatornánál.
            </p><p>
                </p><pre class="programlisting">
my $ArticleBackendObject = $ArticleObject-&gt;BackendForChannel( ChannelName =&gt; 'Email' );
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-article-backend-api"></a>Bejegyzés háttérprogram API</h5></div></div></div><p>
                Az összes többi bejegyzésadat és a hozzájuk kapcsolódó metódus át lett
helyezve külön háttérprogramokba. Minden egyes kommunikációs csatorna
mostantól rendelkezik egy dedikált háttérprogram API-val, amely kezeli a
bejegyzésadatokat és használható azok manipulálásához.
            </p><p>
                Az OTRS 6 Free néhány alapértelmezett csatornával és a megfelelő
háttérprogramokkal érkezik:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>E-mail (egyenértékű a régi <code class="literal">email</code> bejegyzéstípusokkal)</p></li><li class="listitem"><p>Telefon (egyenértékű a régi <code class="literal">phone</code> bejegyzéstípusokkal)</p></li><li class="listitem"><p>Belső (egyenértékű a régi <code class="literal">note</code> bejegyzéstípusokkal)</p></li><li class="listitem"><p>Csevegés (egyenértékű a régi <code class="literal">chat</code> bejegyzéstípusokkal)</p></li></ul></div><p>
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
                    Miközben a csevegés bejegyzés háttérprogram elérhető az OTRS 6 Free
verziójában, csak akkor használható, ha a rendszer érvényes <span class="bold"><strong>OTRS Business Solution™</strong></span> telepítéssel rendelkezik.
                </p></div><p>
                A bejegyzés adatainak manipulálása a következő háttérprogram-metódusokon
keresztül végezhető el:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">ArticleCreate()</code></p></li><li class="listitem"><p><code class="literal">ArticleUpdate()</code></p></li><li class="listitem"><p><code class="literal">ArticleGet()</code></p></li><li class="listitem"><p><code class="literal">ArticleDelete()</code></p></li></ul></div><p>
            </p><p>
                Ezen metódusok mindegyikéből el lett dobva a bejegyzéstípus paraméter,
amelyet a <code class="literal">SenderType</code> és az
<code class="literal">IsVisibleForCustomer</code> paraméterek kombinációjával kell
helyettesíteni. Ezenkívül mostantól ezen metódusok mindegyike igényli a
<code class="literal">TicketID</code> és a <code class="literal">UserID</code> paramétereket.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
                    Mivel a bejegyzés API-ban lévő változások rendszerszintűek, a régi API-t
használó összes kódot át kell írni az OTRS 6-hoz. Ebbe beletartozik például
az összes webszolgáltatás meghatározás, amely kihasználja ezeket a
metódusokat közvetlenül az általános felületen keresztül. Ezeket újra meg
kell vizsgálni és hozzá kell igazítani ahhoz, hogy az összes szükséges
paramétert biztosítsák az új API-hoz a kérések közben, és kezeljék a rájuk
adott válaszokat az új formátumban.
                </p></div><p>
                Ne feledje, hogy az <code class="literal">ArticleGet()</code> visszatérési kivonata
megváltozott, és néhány dolog (mint például a jegyadatok)
hiányozhatnak. Használja a <code class="literal">DynamicFields =&gt; 1</code> és a
<code class="literal">RealNames =&gt; 1</code> paramétereket, hogy további információ
kapjon.
            </p><p>
                Ezenkívül a melléklet adatai többé nem lesznek visszaadva, használja a
következő metódusok kombinációját a bejegyzés háttérprogramokból:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">ArticleAttachmentIndex()</code></p></li><li class="listitem"><p><code class="literal">ArticleAttachment()</code></p></li></ul></div><p>
            </p><p>
                Ne feledje, hogy az <code class="literal">ArticleAttachmentIndex()</code> paraméterei
és működése is megváltozott. A régi paraméterdarabok helyett használja az új
<code class="literal">ExcludePlainText</code>, <code class="literal">ExcludeHTMLBody</code> és
<code class="literal">ExcludeInline</code> kombinációját.
            </p><p>
                Példaként itt van, hogy az összes bejegyzés- és mellékletadatot hogyan lehet
lekérni ugyanabban a kivonatban:
            </p><p>
                </p><pre class="programlisting">
my @Articles = $ArticleObject-&gt;ArticleList(
    TicketID =&gt; $TicketID,
);

ARTICLE:
for my $Article (@Articles) {

    # Győződjön meg arról, hogy lekérte-e a háttérprogram-objektumot ehhez a bizonyos bejegyzéshez.
    my $ArticleBackendObject = $ArticleObject-&gt;BackendForArticle( %{$Article} );

    my %ArticleData = $ArticleBackendObject-&gt;ArticleGet(
        %{$Article},
        DynamicFields =&gt; 1,
        UserID        =&gt; $UserID,
    );
    $Article = \%ArticleData;

    # Mellékletindex lekérése (mellékletek nélkül).
    my %AtmIndex = $ArticleBackendObject-&gt;ArticleAttachmentIndex(
        ArticleID =&gt; $Article-&gt;{ArticleID},
        UserID    =&gt; $UserID,
    );
    next ARTICLE if !%AtmIndex;

    my @Attachments;
    ATTACHMENT:
    for my $FileID ( sort keys %AtmIndex ) {
        my %Attachment = $ArticleBackendObject-&gt;ArticleAttachment(
            ArticleID =&gt; $Article-&gt;{ArticleID},
            FileID    =&gt; $FileID,
            UserID    =&gt; $UserID,
        );
        next ATTACHMENT if !%Attachment;

        $Attachment{FileID} = $FileID;
        $Attachment{Content} = encode_base64( $Attachment{Content} );

        push @Attachments, \%Attachment;
    }

    # Mellékletadatok felvétele a bejegyzés kivonatába.
    $Article-&gt;{Atms} = \@Attachments;
}
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="package-porting-5-to-6-article-search-index"></a>Bejegyzéskeresési index</h5></div></div></div><p>
                A bejegyzésindexelés általánosabbá tételéhez a bejegyzés háttérprogramok
mostantól biztosítják a bejegyzésadatok megfelelő indexeléséhez  szükséges
információkat. Az index hasonlóan lesz létrehozva a régi
<code class="literal">StaticDB</code> mechanizmushoz, és egy dedikált
bejegyzéskeresési táblában lesznek eltárolva.
            </p><p>
                Mivel mostantól minden egyes bejegyzés háttérprogram képes keresést
biztosítani a bejegyzés mezőinek tetszőleges számán, használja a
<code class="literal">BackendSearchableFieldsGet()</code> metódust a velük kapcsolatos
információk lekéréséhez. Ezek az adatok használhatók a kérések formázásánál
is a <code class="literal">TicketSearch()</code> metódushoz. Véletlenül néhány
<code class="literal">TicketSearch()</code> paraméter megváltoztatta a nevét, hogy
tartalmazza a bejegyzés háttérprogram információit is, például:
            </p><p>
                </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Régi paraméter</th><th>Új paraméter</th></tr></thead><tbody><tr><td><code class="literal">From</code></td><td><code class="literal">MIMEBase_From</code></td></tr><tr><td><code class="literal">To</code></td><td><code class="literal">MIMEBase_To</code></td></tr><tr><td><code class="literal">Cc</code></td><td><code class="literal">MIMEBase_Cc</code></td></tr><tr><td><code class="literal">Subject</code></td><td><code class="literal">MIMEBase_Subject</code></td></tr><tr><td><code class="literal">Body</code></td><td><code class="literal">MIMEBase_Body</code></td></tr><tr><td><code class="literal">AttachmentName</code></td><td><code class="literal">MIMEBase_AttachmentName</code></td></tr></tbody></table></div><p>
            </p><p>
                Ezenkívül a bejegyzéskeresési indexelés mostantól aszinkron hívásban lesz
végrehajtva annak érdekében, hogy kitegye az index kiszámítását egy
különálló feladatba. Míg ez rendben van a produktív rendszereknél, aközben
új problémákat hozhat létre bizonyos helyzetekben, például
egységteszteknél. Ha kézzel hozza létre a bejegyzéseket az egységtesztben,
és arra számít, hogy azonnal kereshető lesz a létrehozás után, akkor
győződjön meg arról, hogy meghívta-e kézzel az új
<code class="literal">ArticleSearchIndexBuild()</code> metódust a bejegyzésobjektumon.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-5-to-6-sysconfig-changes"></a>Rendszerbeállítás API változások</h4></div></div></div><p>
            Ne feledje, hogy az OTRS 6-ban a rendszerbeállítások API megváltozott, ezért
ellenőriznie kell, hogy a metódusok léteznek-e még. Például a
<code class="literal">ConfigItemUpdate()</code> el lett távolítva. A helyettesítéshez
a következő metódusok kombinációját kell használnia:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">SettingLock()</code></p></li><li class="listitem"><p><code class="literal">SettingUpdate()</code></p></li><li class="listitem"><p><code class="literal">ConfigurationDeploy()</code></p></li></ul></div><p>
        </p><p>
            Abban az esetben, ha frissíteni szeretne egy konfigurációs beállítást egy
csomag <code class="literal">CodeInstall</code> szakasza közben, akkor használhatja a
<code class="literal">SettingsSet()</code> metódust. Ez elvégzi a korábban említett
összes lépést, és használható egyszerre több beállításnál is.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>Ne használja a <code class="literal">SettingSet()</code> metódust magán a
rendszerbeállítás grafikus felhasználói felületén.</p></div><p>
            </p><pre class="programlisting">
my $Success = $SysConfigObject-&gt;SettingsSet(
    UserID   =&gt; 1,                                      # (kötelező) Felhasználó-azonosító.
    Comments =&gt; 'Üzembe állítási megjegyzés.',          # (elhagyható) Megjegyzés.
    Settings =&gt; [                                       # (kötelező) Frissítendő beállítások listája.
        {
            Name                   =&gt; 'Setting::Name',  # (kötelező)
            EffectiveValue         =&gt; 'Value',          # (elhagyható)
            IsValid                =&gt; 1,                # (elhagyható)
            UserModificationActive =&gt; 1,                # (elhagyható)
        },
        ...
    ],
);
            </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-5-to-6-linkobject-changes"></a><code class="literal">LinkObject</code> API változások</h4></div></div></div><p>
            Ne feledje, hogy a <code class="literal">LinkObject</code> kissé módosult az OTRS
6-ban, valamint a <code class="literal">LinkList()</code> és a
<code class="literal">LinkKeyList()</code> metódusok különböző eredményt adhatnak
vissza, ha a <code class="literal">Direction</code> paramétert használják. Fontolja
meg a <code class="literal">Direction</code> paraméter megváltoztatását.
        </p><p>
            Régi kód:
        </p><p>
            </p><pre class="programlisting">
my $LinkList = $LinkObject-&gt;LinkList(
    Object    =&gt; 'Ticket',
    Key       =&gt; '321',
    Object2   =&gt; 'FAQ',
    State     =&gt; 'Valid',
    Type      =&gt; 'ParentChild',
    Direction =&gt; 'Target',
    UserID    =&gt; 1,
);
            </pre><p>
        </p><p>
            Új kód:
        </p><p>
            </p><pre class="programlisting">
my $LinkList = $LinkObject-&gt;LinkList(
    Object    =&gt; 'Ticket',
    Key       =&gt; '321',
    Object2   =&gt; 'FAQ',
    State     =&gt; 'Valid',
    Type      =&gt; 'ParentChild',
    Direction =&gt; 'Source',
    UserID    =&gt; 1,
);
            </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-5-to-6-postmaster-filter-communication-log"></a>Kommunikációs napló támogatás a további levelezési szűrőkhöz</h4></div></div></div><p>
            Az OTRS 6 e-mail kezelési továbbfejlesztésének részeként egy új naplózó
mechanizmus lett hozzáadva az OTRS 6-hoz, kifejezetten a bejövő és kimenő
kommunikációk használatához. Az összes levelezési szűrő fel lett javítva
ezzel az új <a class="link" href="ch02s03.html#log-mechanism-communication-log" title="Kommunikáció napló">kommunikációs
napló</a> API-val, amely azt jelenti, hogy a csomagokkal érkező bármely
további szűrő is kihasználhatja az új naplózási funkciót.
        </p><p>
            Ha a csomagja további levelezési szűrőket valósít meg, akkor győződjön meg
arról, hogy megismerje az <a class="link" href="ch02s03.html#log-mechanism-communication-log" title="Kommunikáció napló">API használati
utasításokat</a>. Kap egy példát is azzal kapcsolatban, hogy ezt a
naplózási mechanizmust hogyan kell megvalósítani, ha belenéz a
<code class="literal">Kernel::System::PostMaster::NewTicket</code> kódjába.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-5-to-6-process-mailqueue-for-ut"></a>Levelezési sor feldolgozása az egységtesztekhez</h4></div></div></div><p>
            Az OTRS 6 e-mail kezelési továbbfejlesztésének részeként az összes e-mail
mostantól aszinkron módon lesz elküldve, amely azt jelenti, hogy egy
várakozási sorba lesznek elmentve a későbbi feldolgozáshoz.
        </p><p>
            Ahhoz, hogy az e-mailektől függő egységtesztek továbbra is megfelelően
működjenek, az e-mail várakozási sor feldolgozásának kényszerítése
szükséges.
        </p><p>
            Győződjön meg arról, hogy egy tiszta várakozási sorral indul:
        </p><p>
            </p><pre class="programlisting">
                my $MailQueueObject = $Kernel::OM-&gt;Get('Kernel::System::MailQueue');
                $MailQueueObject-&gt;Delete();
            </pre><p>
        </p><p>
            Ha néhány esetben nem tudja teljesen kitakarítani a várakozási sort (például
Selenium egységteszteknél), akkor egyszerűen törölje azokat az elemeket,
amelyek a tesztek során jöttek létre:
        </p><p>
            </p><pre class="programlisting">
                my $MailQueueObject = $Kernel::OM-&gt;Get('Kernel::System::MailQueue');
                my %MailQueueCurrentItems = map { $_-&gt;{ID} =&gt; $_ } @{ $MailQueueObject-&gt;List() || [] };

                my $Items = $MailQueueObject-&gt;List();
                MAIL_QUEUE_ITEM:
                for my $Item ( @{$Items} ) {
                    next MAIL_QUEUE_ITEM if $MailQueueCurrentItems{ $Item-&gt;{ID} };
                    $MailQueueObject-&gt;Delete(
                        ID =&gt; $Item-&gt;{ID},
                    );
                }
            </pre><p>
        </p><p>
            Dolgozza fel a várakozási sort azután a kód után, amely várhatóan elküldi az
e-maileket:
        </p><p>
            </p><pre class="programlisting">
                my $MailQueueObject = $Kernel::OM-&gt;Get('Kernel::System::MailQueue');
                my $QueueItems      = $MailQueueObject-&gt;List();
                for my $Item ( @{$QueueItems} ) {
                    $MailQueueObject-&gt;Send( %{$Item} );
                }
            </pre><p>
        </p><p>
            Vagy csak azokat dolgozza fel, amelyek a tesztek során jöttek létre:
        </p><p>
            </p><pre class="programlisting">
                my $MailQueueObject = $Kernel::OM-&gt;Get('Kernel::System::MailQueue');
                my $QueueItems      = $MailQueueObject-&gt;List();
                MAIL_QUEUE_ITEM:
                for my $Item ( @{$QueueItems} ) {
                    next MAIL_QUEUE_ITEM if $MailQueueCurrentItems{ $Item-&gt;{ID} };
                    $MailQueueObject-&gt;Send( %{$Item} );
                }
            </pre><p>
        </p><p>
            Az esettől függően esetleg ki kell takarítania a várakozási sort a
feldolgozása után vagy előtt.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-5-to-6-agentticketzoom-widget-handling"></a>Felületi elem kezelés a jegynagyítás képernyőn</h4></div></div></div><p>
            A jegynagyítás képernyőn lévő felületi elemek továbbfejlesztésre kerültek,
hogy általánosabb módon működjenek. Az OTRS 6-tal mostantól lehetőség van új
felületi elemek hozzáadására a jegynagyítás képernyőhöz a
rendszerbeállításokon keresztül. Lehetőség van beállítani a használt modult,
a felületi elem helyzetét (például oldalsáv) és hogy a tartalmat szinkron
módon (alapértelmezett) vagy AJAX kérésen keresztül kell betölteni.
        </p><p>
            Itt egy beállítási példa az alapértelmezett felületi elemekhez:
        </p><p>
            </p><pre class="programlisting">
&lt;Setting Name="Ticket::Frontend::AgentTicketZoom###Widgets###0100-TicketInformation" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;AgentTicketZoom widget that displays ticket data in the side bar.&lt;/Description&gt;
    &lt;Navigation&gt;Frontend::Agent::View::TicketZoom&lt;/Navigation&gt;
    &lt;Value&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::TicketZoom::TicketInformation&lt;/Item&gt;
            &lt;Item Key="Location"&gt;Sidebar&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Value&gt;
&lt;/Setting&gt;
&lt;Setting Name="Ticket::Frontend::AgentTicketZoom###Widgets###0200-CustomerInformation" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;AgentTicketZoom widget that displays customer information for the ticket in the side bar.&lt;/Description&gt;
    &lt;Navigation&gt;Frontend::Agent::View::TicketZoom&lt;/Navigation&gt;
    &lt;Value&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::TicketZoom::CustomerInformation&lt;/Item&gt;
            &lt;Item Key="Location"&gt;Sidebar&lt;/Item&gt;
            &lt;Item Key="Async"&gt;1&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Value&gt;
&lt;/Setting&gt;
            </pre><p>
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
                Ezzel a változtatással a felületi elem kódjában lévő sablonblokkok
eltávolításra kerültek, ezért ellenőriznie kell, ha a régi felületi elem
blokkokat használja néhány kimeneti szűrőben a
<code class="literal">Frontend::Template::GenerateBlockHooks</code> funkcionalitáson
keresztül, és meg kell valósítania az új módszer szerint.
            </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="package-porting-4-to-5"></a>OTRS 4-ről 5-re</h3></div></div></div><p>
        Ez a szakasz azokat a változtatásokat sorolja fel, amelyeket meg kell
vizsgálnia, amikor átírja a csomagját az OTRS 4-ről 5-re.
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="id-1.5.4.4.3"></a>Átszerkesztett <code class="filename">Kernel/Output/HTML</code></h4></div></div></div><p>
            Az OTRS 5-ben a <code class="filename">Kernel/Output/HTML</code> átszerkesztésre
került. Az összes Perl modul (kivéve a <code class="filename">Layout.pm</code> fájlt)
alkönyvtárakba került áthelyezésre (minden modulréteghez egybe). A
sablonfájlok (témák) is áthelyezésre kerültek a
<code class="filename">Kernel/Output/HTML/Standard</code> könyvtárból a
<code class="filename">Kernel/Output/HTML/Templates/Standard</code>
könyvtárba. Végezze el ezeket a költöztetéseket a saját kódjában is.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="id-1.5.4.4.4"></a>Elő-kimenetszűrők</h4></div></div></div><p>
            Az OTRS 5-tel többé nincs támogatás a <code class="literal">pre</code>
kimenetszűrőkhöz. Ezek a szűrők azelőtt változtatták meg a sablon tartalmát,
mielőtt az feldolgozásra került volna, és potenciálisan rossz
teljesítményproblémákhoz vezethettek, ugyanis a sablonokat többé nem
lehetett gyorstárazni, és minden alkalommal fel kellett dolgozni és le
kellett fordítani.
        </p><p>
            Egyszerűen váltson a <code class="literal">pre</code> kimenetszűrőről a
<code class="literal">post</code> kimenetszűrőre. A tartalom lefordításához
futtathatja közvetlenül a <code class="code">$LayoutObject-&gt;Translate()</code>
függvényt. Ha egyéb sablonszolgáltatásokra van szüksége, akkor egyszerűen
határozzon meg egy kis sablonfájlt a kimenetszűrőhöz, és használja azt a
tartalom megjelenítéséhez, mielőtt beültetné azt a fő adatokba. Néhány
esetben hasznos lehet a jQuery DOM műveletek használata is a képernyőn lévő
tartalom sorrendjének megváltoztatásához vagy cseréjéhez a reguláris
kifejezések használata helyett. Ebben az esetben láthatatlan tartalomként
kellene beültetnie az új kódot valahova az oldalba (például a
<code class="literal">Hidden</code> osztállyal), majd ezután áthelyezni a jQuery
használatával a megfelelő helyre a DOM-ban, és megjeleníteni azt.
        </p><p>
            Az utó-kimenetszűrők használatának megkönnyítéséhez létezik egy új
mechanizmus is a HTML megjegyzéshorgok lekéréséhez bizonyos sablonoknál vagy
blokkoknál. Hozzáadhatja a modulbeállító XML-be a következőhöz hasonlóan:
        </p><p>
            </p><pre class="programlisting">
&lt;ConfigItem
Name="Frontend::Template::GenerateBlockHooks###100-OTRSBusiness-ContactWithData"
Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Generate HTML comment hooks for
the specified blocks so that filters can use them.&lt;/Description&gt;
    &lt;Group&gt;OTRSBusiness&lt;/Group&gt;
    &lt;SubGroup&gt;Core&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="AgentTicketZoom"&gt;
                &lt;Array&gt;
                    &lt;Item&gt;CustomerTable&lt;/Item&gt;
                &lt;/Array&gt;
            &lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            Ez azt fogja okozni, hogy az <code class="filename">AgentTicketZoom.tt</code> fájlban
lévő <code class="literal">CustomerTable</code> blokk át lesz alakítva a HTML
megjegyzésekben minden alkalommal, amikor megjelenítésre kerül:
        </p><p>
            </p><pre class="programlisting">
&lt;!--HookStartCustomerTable--&gt;
... blokk kimenet ...
&lt;!--HookEndCustomerTable--&gt;
            </pre><p>
        </p><p>
            Ezzel a mechanizmussal minden csomag csak azokat a blokkhorgokat kérheti,
amelyekre szüksége van, és következetesen kerülnek megjelenítésre. Ezek a
HTML megjegyzések használhatók ezután a kimenetszűrőben az egyszerű
reguláris kifejezés illesztéshez.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="id-1.5.4.4.5"></a>IE 8 és IE 9</h4></div></div></div><p>
            Az IE 8 és IE 9 támogatást <a class="ulink" href="https://github.com/OTRS/otrs/commit/3b1aff21984d7b32f626df95e072337245615b36" target="_top">eldobták</a>.
Eltávolíthat minden kerülőmegoldást a kódjából, amelyet ezekhez a
platformokhoz készített, valamint az összes olyan régi
<code class="literal">&lt;CSS_IE7&gt;</code> vagy <code class="literal">&lt;CSS_IE8&gt;</code>
betöltő címkét, amely még esetleg megbújik az XML beállítófájljaiban.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="id-1.5.4.4.6"></a>Általános felület API változás a „Ticket” csatlakozóban</h4></div></div></div><p>
            A <code class="code">TicketGet()</code> művelet másképpen ad vissza dinamikus mező
adatokat a jegyből és a bejegyzésből mint az OTRS 4-ben. Mostantól ezek
tisztán el vannak választva a többi statikus jegy- és bejegyzésmezőktől -
innentől kezdve csoportosítva vannak egy <code class="literal">DynamicField</code>
nevű listába. Eszerint alakítson át minden olyan alkalmazást, amely ezt a
műveletet használja.
        </p><p>
            </p><pre class="programlisting">
# megváltoztatva erről:

Ticket =&gt; [
{
    TicketNumber       =&gt; '20101027000001',
    Title              =&gt; 'valamilyen cím',
    ...
    DynamicField_X     =&gt; 'x_ertek',
},
]

# erre:

Ticket =&gt; [
{
    TicketNumber       =&gt; '20101027000001',
    Title              =&gt; 'valamilyen cím',
    ...
    DynamicField =&gt; [
        {
            Name  =&gt; 'valamilyen név',
            Value =&gt; 'valamilyen érték',
        },
    ],
},
]
            </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="id-1.5.4.4.7"></a>Előnézeti függvények a dinamikus statisztikákban</h4></div></div></div><p>
            Az új statisztikák grafikus felhasználói felülete egy előnézetet biztosít a
jelenlegi beállításhoz. Ezt meg kell valósítani a statisztikák moduljaiban,
és általában hamis vagy véletlenszerű adatokat adnak vissza sebességi
okokból. Így minden olyan dinamikus (mátrix) statisztikánál, amely a
<code class="code">GetStatElement()</code> metódust biztosítja, hozzá kell adnia egy
<code class="code">GetStatElementPreview()</code> metódust is, valamint minden olyan
dinamikus (tábla) statisztikánál, amely a <code class="code">GetStatTable()</code>
metódust biztosítja, hozzá kell adnia egy <code class="code">GetStatTablePreview()</code>
metódust ennek megfelelően. Egyébként az új statisztikák grafikus
felhasználói felületén lévő előnézet nem fog működni a saját
statisztikáinál. Példamegvalósításokat találhat az alapértelmezett OTRS
statisztikákban.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="id-1.5.4.4.8"></a>Eldobott HTML nyomtatás</h4></div></div></div><p>
            Az OTRS 5-ig a <code class="literal">PDF::API2</code> Perl modul nem volt megtalálható
minden rendszeren. Ezért létezett egy tartalék HTML nyomtatási mód. Az OTRS
5-tel a modul mostantól mellékelve van, és a HTML nyomtatás eldobásra
került. A <code class="code">$LayoutObject-&gt;PrintHeader()</code> és a
<code class="code">PrintFooter()</code> többé nem érhető el. Távolítsa el a tartalék HTML
nyomtatást a kódjából, és változtassa meg a PDF előállításához, ha
szükséges.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="id-1.5.4.4.9"></a>Továbbfejlesztett fordítási szöveg kinyerés</h4></div></div></div><p>
            Az OTRS 5-ig a lefordítható szövegeket nem lehetett kinyerni a Perl kódból
és az adatbázis XML meghatározásokból. Ez mostantól lehetséges, és elavulttá
tette az olyan üres sablonokat, mint például az <code class="filename">AAA*.tt</code>
sablont. A részletekért nézze meg <a class="link" href="localization-translation-mechanism.html" title="Honosítási és fordítási mechanizmus">ezt a szakaszt</a>.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="package-porting-33-to-4"></a>OTRS 3.3-ról 4-re</h3></div></div></div><p>
        Ez a szakasz azokat a változtatásokat sorolja fel, amelyeket meg kell
vizsgálnia, amikor átírja a csomagját az OTRS 3.3-ról 4-re.
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-33-to-4-objectmanager"></a>Új objektumkezelés</h4></div></div></div><p>
            Az OTRS 4-ig az objektumokat mind központilag, mind helyileg létre kellett
hozni, és ekkor az összes objektumot le kellett kezelni a konstruktornak
átadva azokat. Az OTRS 4-es és későbbi verzióinál mostantól létezik egy
<code class="literal">ObjectManager</code> objektum, amely központosítja az egyke
objektum létrehozását és hozzáférését.
        </p><p>
            Ez mindenek előtt azt fogja igényelni, hogy változtassa meg az összes felső
szintű Perl parancsfájlt (csak a .pl fájlokat!) az
<code class="literal">ObjectManager</code> betöltéséhez és biztosításához az összes
OTRS objektumnál. Példaként nézzük meg az
<code class="filename">otrs.CheckDB.pl</code> parancsfájlt az OTRS 3.3-ból:
        </p><p>
            </p><pre class="programlisting">
use strict;
use warnings;

use File::Basename;
use FindBin qw($RealBin);
use lib dirname($RealBin);
use lib dirname($RealBin) . '/Kernel/cpan-lib';
use lib dirname($RealBin) . '/Custom';

use Kernel::Config;
use Kernel::System::Encode;
use Kernel::System::Log;
use Kernel::System::Main;
use Kernel::System::DB;

# a szokásos objektumok létrehozása
my %CommonObject = ();
$CommonObject{ConfigObject} = Kernel::Config-&gt;new();
$CommonObject{EncodeObject} = Kernel::System::Encode-&gt;new(%CommonObject);
$CommonObject{LogObject}    = Kernel::System::Log-&gt;new(
    LogPrefix    =&gt; 'OTRS-otrs.CheckDB.pl',
    ConfigObject =&gt; $CommonObject{ConfigObject},
);
$CommonObject{MainObject} = Kernel::System::Main-&gt;new(%CommonObject);
$CommonObject{DBObject}   = Kernel::System::DB-&gt;new(%CommonObject);
            </pre><p>
        </p><p>
            Láthatjuk, hogy rengeteg kódot használnak a csomagok betöltéséhez és a
gyakori objektumok létrehozásához, amelyet a parancsfájlban át kell adni a
használandó OTRS objektumoknak. Az OTRS 4-gyel ez egy kicsit máshogy néz ki:
        </p><p>
            </p><pre class="programlisting">
use strict;
use warnings;

use File::Basename;
use FindBin qw($RealBin);
use lib dirname($RealBin);
use lib dirname($RealBin) . '/Kernel/cpan-lib';
use lib dirname($RealBin) . '/Custom';

use Kernel::System::ObjectManager;

# a szokásos objektumok létrehozása
local $Kernel::OM = Kernel::System::ObjectManager-&gt;new(
'Kernel::System::Log' =&gt; {
    LogPrefix =&gt; 'OTRS-otrs.CheckDB.pl',
},
);

# az adatbázis-objektum lekérése
my $DBObject = $Kernel::OM-&gt;Get('Kernel::System::DB');
            </pre><p>
        </p><p>
            Az új kód egy kicsivel rövidebb mint a régi. Többé nem szükséges az összes
csomag betöltése, elég csak az <code class="literal">ObjectManager</code>
objektumot. Azután a
<code class="literal">$Kernel::OM-&gt;Get('Sajat::Perl::Csomag')</code> használható az
objektumok példányainak lekéréséhez, amelyeket csak egyszer kell
létrehozni. A <code class="literal">LogPrefix</code> beállítás vezérli azokat a
naplóüzeneteket, amelyeket a <code class="literal">Kernel::System::Log</code> ír ki,
így az szintén elhagyható.
        </p><p>
            Ebből a példából kikövetkeztetheti az általános átírási irányelvet is,
amikor az objektumok hozzáférése jön: többé ne tárolja azokat a
<code class="literal">$Self</code> változóban (hacsak bizonyos okokból ez nem
szükséges). Egyszerűen kérje le és használja az objektumokat igény szerint,
úgymint
<code class="code">$Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(...)</code>. Ennek megvan
az az előnye is, hogy a <code class="literal">Log</code> objektumot csak akkor kell
majd létrehozni, ha valamit naplózni kell. Néha hasznos lehet helyi
változókat is létrehozni, ha egy objektumot többször használnak egy
függvényben, mint például a fenti példában lévő <code class="literal">$DBObject</code>
objektumot.
        </p><p>
            Nem kell sokkal többet tudnia az olyan csomagok átírásakor, amelyeknek
betölthetőnek kell lenniük az <code class="literal">ObjectManager</code>
használatával. Meg kell határozniuk azokat a modulokat, amelyeket használnak
(a <code class="code">$Kernel::OM-&gt;Get()</code> függvényen keresztül) ehhez hasonlóan:
        </p><p>
            </p><pre class="programlisting">
our @ObjectDependencies = (
'Kernel::Config',
'Kernel::System::Log',
'Kernel::System::Main',
);
            </pre><p>
        </p><p>
            Az <code class="literal">@ObjectDependencies</code> meghatározás szükséges az
<code class="literal">ObjectManager</code> objektumhoz a helyes sorrend megtartásához
az objektumok megsemmisítésekor.
        </p><p>
            Nézzük meg a <code class="filename">Valid.pm</code> fájlt az OTRS 3.3-ból és a 4-ből,
hogy lássuk a különbséget. A régi:
        </p><p>
            </p><pre class="programlisting">
package Kernel::System::Valid;

use strict;
use warnings;

use Kernel::System::CacheInternal;

...

sub new {
my ( $Type, %Param ) = @_;

# új kivonat lefoglalása az objektumhoz
my $Self = {};
bless( $Self, $Type );

# a szükséges objektumok ellenőrzése
for my $Object (qw(DBObject ConfigObject LogObject EncodeObject MainObject)) {
    $Self-&gt;{$Object} = $Param{$Object} || die "Nincs $Object!";
}

$Self-&gt;{CacheInternalObject} = Kernel::System::CacheInternal-&gt;new(
    %{$Self},
    Type =&gt; 'Valid',
    TTL  =&gt; 60 * 60 * 24 * 20,
);

return $Self;
}

...

sub ValidList {
my ( $Self, %Param ) = @_;

# gyorsítótár olvasása
my $CacheKey = 'ValidList';
my $Cache = $Self-&gt;{CacheInternalObject}-&gt;Get( Key =&gt; $CacheKey );
return %{$Cache} if $Cache;

# lista lekérése az adatbázisból
return if !$Self-&gt;{DBObject}-&gt;Prepare( SQL =&gt; 'SELECT id, name FROM valid' );

# az eredmény lekérése
my %Data;
while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
    $Data{ $Row[0] } = $Row[1];
}

# gyorsítótár beállítása
$Self-&gt;{CacheInternalObject}-&gt;Set( Key =&gt; $CacheKey, Value =&gt; \%Data );

return %Data;
}
            </pre><p>
        </p><p>
            Az új:
        </p><p>
            </p><pre class="programlisting">
package Kernel::System::Valid;

use strict;
use warnings;

our @ObjectDependencies = (
'Kernel::System::Cache',
'Kernel::System::DB',
'Kernel::System::Log',
);

...

sub new {
my ( $Type, %Param ) = @_;

# új kivonat lefoglalása az objektumhoz
my $Self = {};
bless( $Self, $Type );

$Self-&gt;{CacheType} = 'Valid';
$Self-&gt;{CacheTTL}  = 60 * 60 * 24 * 20;

return $Self;
}

...

sub ValidList {
my ( $Self, %Param ) = @_;

# gyorsítótár olvasása
my $CacheKey = 'ValidList';
my $Cache    = $Kernel::OM-&gt;Get('Kernel::System::Cache')-&gt;Get(
    Type =&gt; $Self-&gt;{CacheType},
    Key  =&gt; $CacheKey,
);
return %{$Cache} if $Cache;

# adatbázis-objektum lekérése
my $DBObject = $Kernel::OM-&gt;Get('Kernel::System::DB');

# lista lekérése az adatbázisból
return if !$DBObject-&gt;Prepare( SQL =&gt; 'SELECT id, name FROM valid' );

# az eredmény lekérése
my %Data;
while ( my @Row = $DBObject-&gt;FetchrowArray() ) {
    $Data{ $Row[0] } = $Row[1];
}

# gyorsítótár beállítása
$Kernel::OM-&gt;Get('Kernel::System::Cache')-&gt;Set(
    Type  =&gt; $Self-&gt;{CacheType},
    TTL   =&gt; $Self-&gt;{CacheTTL},
    Key   =&gt; $CacheKey,
    Value =&gt; \%Data
);

return %Data;
}
            </pre><p>
        </p><p>
            Láthatja, hogy meg vannak határozva a függőségek, és az objektumok csak
igény szerint vannak lekérve. A következő szakaszban a
<code class="literal">CacheInternalObject</code> objektumról fogunk beszélni.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-33-to-4-cache"></a>Eltávolított <code class="literal">CacheInternalObject</code></h4></div></div></div><p>
            Mivel a <code class="literal">Kernel::System::Cache</code> mostantól képes a
memóriában is gyorstárazni, a
<code class="literal">Kernel::System::CacheInternal</code> eldobásra került. Nézze meg
az előző példát, hogy a kódot hogyan kell átköltöztetni: a globális
<code class="literal">Cache</code> objektumot kell használnia, és át kell adnia a
<code class="literal">Type</code> beállítást a <code class="code">Get()</code>, <code class="code">Set()</code>,
<code class="code">Delete()</code> és <code class="code">CleanUp()</code> függvények minden egyes
hívásához. A <code class="literal">TTL</code> paraméter mostantól elhagyható, és
alapértelmezetten 20 nap, így csak akkor kell megadnia a <code class="code">Get()</code>
függvényben, ha eltérő <code class="literal">TTL</code> értékre van szüksége.
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Figyelem</h3><p>
                Különösen fontos a <code class="literal">Type</code> paraméter hozzáadása a
<code class="code">CleanUp()</code> függvényhez, mivel különben nem csak a jelenlegi
gyorsítótártípus, hanem a teljes gyorsítótár törölve lehet.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-33-to-4-scheduler-location"></a>Áthelyezett ütemező háttérprogram fájlok</h4></div></div></div><p>
            Az ütemező háttérprogram fájljai áthelyezésre kerültek a
<code class="filename">Kernel/Scheduler</code> mappából a
<code class="filename">Kernel/System/Scheduler</code> mappába. Ha valamilyen egyéni
feladatkezelő moduljai vannak, akkor azokat is át kell helyeznie.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-33-to-4-sopm-code-tags"></a><a class="link" href="package-building.html#package-code-install" title="&lt;CodeInstall&gt;">Kódszakaszok</a> frissítése az SOPM
fájlokban</h4></div></div></div><p>
            Az SOPM fájlokban lévő kódcímkéket is frissíteni kell. Többé ne használja a
<code class="literal">$Self</code> változót. Régebben ezt használták az olyan OTRS
objektumokhoz való hozzáféréshez, mint például a
<code class="literal">MainObject</code>. Mostantól használja az
<code class="literal">ObjectManager</code> objektumot. Itt egy példa a régi stílusra:
        </p><p>
            </p><pre class="programlisting">
&lt;CodeInstall Type="post"&gt;

# függvénynév meghatározása
my $FunctionName = 'CodeInstall';

# a csomagnév létrehozása
my $CodeModule = 'var::packagesetup::' . $Param{Structure}-&gt;{Name}-&gt;{Content};

# a modul betöltése
if ( $Self-&gt;{MainObject}-&gt;Require($CodeModule) ) {

# új példány létrehozása
my $CodeObject = $CodeModule-&gt;new( %{$Self} );

if ($CodeObject) {

    # metódus elindítása
    if ( !$CodeObject-&gt;$FunctionName(%{$Self}) ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'error',
            Message  =&gt; "Nem sikerült meghívni a(z) $FunctionName() metódust ebben: $CodeModule.pm."
        );
    }
}

# hibakezelés
else {
    $Self-&gt;{LogObject}-&gt;Log(
        Priority =&gt; 'error',
        Message  =&gt; "Nem sikerült meghívni a new() metódust ebben: $CodeModule.pm."
    );
}
}

&lt;/CodeInstall&gt;
            </pre><p>
        </p><p>
            Most ezt a következővel kell helyettesíteni:
        </p><p>
            </p><pre class="programlisting">
&lt;CodeInstall Type="post"&gt;&lt;![CDATA[
$Kernel::OM-&gt;Get('var::packagesetup::SajatCsomag')-&gt;CodeInstall();
]]&gt;&lt;/CodeInstall&gt;
            </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-33-to-4-template-engine"></a>Új sablonmotor</h4></div></div></div><p>
            Az OTRS 4-gyel a DTL sablonmotort a Template::Toolkit váltotta. A
részletekért nézze meg a <a class="link" href="TemplatingMechanism.html" title="Sablonozó mechanizmus">sablonozó
szakaszt</a>, hogy hogyan néz ki az új sablonszintaxis.
        </p><p>
            Ezek azok a változtatások, amelyet alkalmaznia kell, amikor a meglévő DTL
sablonokat az új Template::Toolkit szintaxisra alakítja át:
        </p><div class="table"><a name="id-1.5.4.5.7.4"></a><p class="title"><b>4.1. táblázat - Sablonváltoztatások az OTRS 3.3-ról 4-re</b></p><div class="table-contents"><table><thead><tr>
                     <td>DTL címke</td>
                     <td>Template::Toolkit címke</td>
                 </tr></thead><tbody><tr>
                    <td><code class="literal">$Data{"Name"}</code></td>
                    <td><code class="literal">[% Data.Name %]</code></td>
                </tr><tr>
                    <td><code class="literal">$Data{"Complex-Name"}</code></td>
                    <td><code class="literal">[% Data.item("Complex-Name") %]</code></td>
                </tr><tr>
                    <td><code class="literal">$QData{"Name"}</code></td>
                    <td><code class="literal">[% Data.Name | html %]</code></td>
                </tr><tr>
                    <td><code class="literal">$QData{"Name", "$Length"}</code></td>
                    <td><code class="literal">[% Data.Name | truncate($Length) | html %]</code></td>
                </tr><tr>
                    <td><code class="literal">$LQData{"Name"}</code></td>
                    <td><code class="literal">[% Data.Name | uri %]</code></td>
                </tr><tr>
                    <td><code class="literal">$Quote{"Szöveg", "$Length"}</code></td>
                    <td>nem lehet közvetlenül lecserélni, lásd a lenti példákat</td></tr><tr>
                    <td><code class="literal">$Quote{"$Config{"Name"}"}</code></td>
                    <td><code class="literal">[% Config("Name") | html %]</code></td>
                </tr><tr>
                    <td><code class="literal">$Quote{"$Data{"Name"}", "$Length"}</code></td>
                    <td><code class="literal">[% Data.Name | truncate($Length) | html %]</code></td>
                </tr><tr>
                    <td><code class="literal">$Quote{"$Data{"Content"}","$QData{"MaxLength"}"}</code></td>
                    <td><code class="literal">[% Data.Name | truncate(Data.MaxLength) | html %]</code></td>
                </tr><tr>
                    <td><code class="literal">$Quote{"$Text{"$Data{"Content"}"}","$QData{"MaxLength"}"}</code></td>
                    <td><code class="literal">[% Data.Content | Translate | truncate(Data.MaxLength) | html
%]</code></td>
                </tr><tr>
                    <td><code class="literal">$Config{"Name"}</code></td>
                    <td><code class="literal">[% Config("Name") %]</code></td>
                </tr><tr>
                    <td><code class="literal">$Env{"Name"}</code></td>
                    <td><code class="literal">[% Env("Name") %]</code></td>
                </tr><tr>
                    <td><code class="literal">$QEnv{"Name"}</code></td>
                    <td><code class="literal">[% Env("Name") | html %]</code></td>
                </tr><tr>
                    <td><code class="literal">$Text{"Szöveg %s helykitöltőkkel", "String"}</code></td>
                    <td><code class="literal">[% Translate("Szöveg %s helykitöltőkkel", "String") | html
%]</code></td>
                </tr><tr>
                    <td><code class="literal">$Text{"Szöveg dinamikus %s helykitöltőkkel",
"$QData{Name}"}</code></td>
                    <td><code class="literal">[% Translate("Szöveg dinamikus %s helykitöltőkkel", Data.Name) |
html %]</code></td>
                </tr><tr>
                    <td><code class="literal">'$JSText{"Szöveg dinamikus %s helykitöltőkkel",
"$QData{Name}"}'</code></td>
                    <td><code class="literal">[% Translate("Szöveg dinamikus %s helykitöltőkkel", Data.Name) |
JSON %]</code></td>
                </tr><tr>
                    <td><code class="literal">"$JSText{"Szöveg dinamikus %s helykitöltőkkel",
"$QData{Name}"}"</code></td>
                    <td><code class="literal">[% Translate("Szöveg dinamikus %s helykitöltőkkel", Data.Name) |
JSON %]</code></td>
                </tr><tr>
                    <td><code class="literal">$TimeLong{"$Data{"CreateTime"}"}</code></td>
                    <td><code class="literal">[% Data.CreateTime | Localize("TimeLong") %]</code></td>
                </tr><tr>
                    <td><code class="literal">$TimeShort{"$Data{"CreateTime"}"}</code></td>
                    <td><code class="literal">[% Data.CreateTime | Localize("TimeShort") %]</code></td>
                </tr><tr>
                    <td><code class="literal">$Date{"$Data{"CreateTime"}"}</code></td>
                    <td><code class="literal">[% Data.CreateTime | Localize("Date") %]</code></td>
                </tr><tr>
                    <td><code class="literal">&lt;-- dtl:block:Name --&gt;...&lt;-- dtl:block:Name
--&gt;</code></td>
                    <td><code class="literal">[% RenderBlockStart("Name") %]...[% RenderBlockEnd("Name")
%]</code></td>
                </tr><tr>
                    <td><code class="literal">&lt;-- dtl:js_on_document_complete --&gt;...&lt;--
dtl:js_on_document_complete --&gt;</code></td>
                    <td><code class="literal">[% WRAPPER JSOnDocumentComplete %]...[% END %]</code></td>
                </tr><tr>
                    <td><code class="literal">&lt;-- dtl:js_on_document_complete_placeholder --&gt;</code></td>
                    <td><code class="literal">[% PROCESS JSOnDocumentCompleteInsert %]</code></td>
                </tr><tr>
                    <td><code class="literal">$Include{"Copyright"}</code></td>
                    <td><code class="literal">[% InsertTemplate("Copyright") %]</code></td>
                </tr></tbody></table></div></div><br class="table-break"><p>
            Létezik egy <code class="filename">bin/otrs.MigrateDTLtoTT.pl</code> segítő
parancsfájl is, amely automatikusan át fogja írni önnek a DTL-fájlokat a
Template::Toolkit szintaxisra. Sikertelen lehet, ha hibák találhatók a
DTL-jében, ezért először javítsa ki ezeket, és azután futtassa újra a
parancsfájlt.
        </p><p>
            Van még további néhány dolog, amelyet tudomásul kell vennie a kód átírásakor
az új sablonmotorra:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        Az összes nyelvi fájlnak mostantól rendelkeznie kell a <code class="literal">use
utf8;</code> kikötéssel.
                    </p></li><li class="listitem"><p>
                        A <code class="code">Layout::Get()</code> mostantól elavult. Használja a
<code class="code">Layout::Translate()</code> függvényt helyette.
                    </p></li><li class="listitem"><p>
                        A Perl-kódban a <code class="literal">$Text{""}</code> összes előfordulását mostantól
le kell cserélni a <code class="code">Layout::Translate()</code> hívásaival.
                    </p><p>
                        Ez azért van, mert a DTL-ben nem volt különválasztás a sablon és az adatok
között. Ha DTL-címkék voltak beszúrva valamilyen adat részeként, akkor a
motornak továbbra is fel kellene dolgozni azokat. Ez többé nincs a
Template::Toolkit esetén, mert itt a sablon és az adatok szigorú
különválasztása van.
                    </p><p>
                        Tipp: ha valamikor interpolálnia kell a címkéket az adatokban, akkor ehhez
használhatja az <code class="literal">Interpolate</code> szűrőt (<code class="literal">[% Data.Name
| Interpolate %]</code>). Ez nem ajánlott biztonsági és teljesítménybeli
okok miatt!
                    </p></li><li class="listitem"><p>
                        Hasonló okból a <code class="literal">dtl:js_on_document_complete</code> által
körbezárt dinamikusan beágyazott JavaScript sem fog működni többé. Használja
a <code class="code">Layout::AddJSOnDocumentComplete()</code> függvényt ahelyett, hogy
ezt sablonadatként ágyazná be.
                    </p><p>
                        Erre találhat egy példát a
<code class="filename">Kernel/System/DynamicField/Driver/BaseSelect.pm</code>
fájlban.
                    </p></li><li class="listitem"><p>
                        Legyen óvatos a <code class="literal">pre</code> kimenetszűrőkkel (a
<code class="literal">Frontend::Output::FilterElementPre</code> objektumban
beállítottakkal). Ezek továbbra is működnek, de meg fogják akadályozni a
sablont, hogy gyorstárazza azokat. Ez komoly teljesítményproblémákhoz
vezethet. Határozottan ne legyen egyetlen olyan <code class="literal">pre</code>
kimenetszűrője sem, amely az összes sablonnal dolgozik, hanem korlátozza
azokat bizonyos sablonokra a konfigurációs beállításokon keresztül.
                    </p><p>
                        A <code class="literal">post</code> kimenetszűrőknek
(<code class="literal">Frontend::Output::FilterElementPost</code>) nincsenek ilyen
erős negatív teljesítményhatásaik. Azonban ezeket is körültekintéssel kell
használni, és nem minden sablonnál.
                    </p></li></ul></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-33-to-4-fontawesome"></a>Új FontAwesome verzió</h4></div></div></div><p>
            Az OTRS 4-gyel egy új verzióra frissítettük a FontAwesome betűkészletet
is. Ennek következtében az ikonok CSS-osztályai megváltoztak. Miközben a
korábbi ikonok egy <code class="literal">icon-{ikonnév}</code> szerű sémával voltak
meghatározva, ezt mostantól a <code class="literal">fa fa-{ikonnév}</code> formában
kell megadni.
        </p><p>
            Ezen változtatás miatt meg kell győződnie arról, hogy frissítette-e az
összes olyan egyéni előtétprogram-modul regisztrációit, amelyek ikonokat
használnak (például a felső navigációs sávnál) az új séma használatához. Ez
igaz az olyan sablonoknál is, ahol ikonelemeket használ, mint például
<code class="literal">&lt;i class="icon-{ikonnév}"&gt;&lt;/i&gt;</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-33-to-4-unit-tests"></a>Egységtesztek</h4></div></div></div><p>
            Az OTRS 4-gyel az egységtesztekben a <code class="literal">$Self</code> többé nem
szolgáltat olyan gyakori objektumokat, mint például a
<code class="literal">MainObject</code>. Mindig a <code class="code">$Kernel::OM-&gt;Get('...')</code>
függvényt használja ezen objektumok lekéréséhez.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="package-porting-33-to-4-custom-ticket-history-types"></a>Egyéni jegy előzmény típusok</h4></div></div></div><p>
            Ha bármilyen egyéni jegy előzmény típusokat használ, akkor két lépést kell
elvégeznie, hogy azok helyesen legyenek megjelenítve az OTRS 4+
<code class="literal">AgentTicketHistory</code> képernyőjén.
        </p><p>
            Először regisztrálnia kell az egyéni jegy előzmény típusait a
rendszerbeállításokon keresztül. Ez így nézhet ki:
        </p><p>
            </p><pre class="programlisting">
&lt;ConfigItem Name="Ticket::Frontend::HistoryTypes###100-MyCustomModule" Required="1" Valid="1"&gt;
&lt;Description Translatable="1"&gt;Controls how to display the ticket history entries as readable values.&lt;/Description&gt;
&lt;Group&gt;Ticket&lt;/Group&gt;
&lt;SubGroup&gt;Frontend::Agent::Ticket::ViewHistory&lt;/SubGroup&gt;
&lt;Setting&gt;
    &lt;Hash&gt;
        &lt;Item Key="MyCustomType" Translatable="1"&gt;Added information (%s)&lt;/Item&gt;
    &lt;/Hash&gt;
&lt;/Setting&gt;
&lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            A második lépés az egyéni jegy előzmény típusnál biztosított angol szöveg
lefordítása a nyelvi fájljaiban, ha szükséges. Ennyi!
        </p><p>
            Ha érdeklődik a részletek iránt, akkor nézze meg <a class="ulink" href="https://github.com/OTRS/otrs/commit/454dfac6d4eb85652a267e5e65514e386d3cf275" target="_top">ezt
a véglegesítést</a> azon változtatásokkal kapcsolatos további
információkról, amelyek az OTRS-ben történtek.
        </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="package-building.html">Vissza</a> </td><td width="20%" align="center"><a accesskey="u" href="how-to-publish-extensions.html">Fel</a></td><td width="40%" align="right"> <a accesskey="n" href="contributing.html">Előre</a></td></tr><tr><td width="40%" align="left" valign="top">Csomagkészítés </td><td width="20%" align="center"><a accesskey="h" href="index.html">Főoldal</a></td><td width="40%" align="right" valign="top"> 5. fejezet - Közreműködés az OTRS-ben</td></tr></table></div></body></html>
