<html><head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../documentation.js"></script>
<link rel="icon" type="image/png" sizes="32x32" href="../../../../../../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../../../../../images/favicon-16x16.png">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script>
$(document).ready(function() {

    // Hint languages to prevent false matches (php for example).
    hljs.configure({
        languages: ['perl', 'javascript', 'xml', 'html', 'css', 'json', 'yaml']
    });

    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Using the power of the OTRS module layers</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="OTRS 6 - Developer Manual"><link rel="up" href="how-to-extend-otrs.html" title="Chapter 3. How to Extend OTRS"><link rel="prev" href="how-to-extend-otrs.html" title="Chapter 3. How to Extend OTRS"><link rel="next" href="how-to-publish-extensions.html" title="Chapter 4. How to Publish Your OTRS Extensions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Using the power of the OTRS module layers</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="how-to-extend-otrs.html">Prev</a> </td><th width="60%" align="center">Chapter 3. How to Extend OTRS</th><td width="20%" align="right"> <a accesskey="n" href="how-to-publish-extensions.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="otrs-module-layers"></a>Using the power of the OTRS module layers</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="otrs-module-layers.html#authentication-user-management-modules">Authentication and user management</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module">Agent Authentication Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module">Authentication Synchronization Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-use_cases">Use Case Examples</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-releases">Release Availability</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-caveats">Caveats and Warnings</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module">Customer Authentication Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-releases">Release Availability</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#preferences-modules">Preferences</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module">Customer User Preferences Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module">Queue Preferences Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-use_cases">Use Case Examples</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module">Service Preferences Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module">SLA Preferences Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-releases">Release Availability</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#core-modules">Other core functions</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#log-module">Log Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#log-module-code">Code example: <code class="literal">Kernel::System::Log::CustomFile</code></a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#log-module-configuration">Configuration example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#log-module-use_cases">Use case examples</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#log-module-caveats">Caveats and Warnings</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#outputfilter">Output Filter</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#outputfilter_filterelement_post"><code class="literal">FilterElementPost</code></a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter_filtercontent"><code class="literal">FilterContent</code></a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter_filtertext"><code class="literal">FilterText</code></a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-code">Code example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-configuration">Configuration example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-usecases">Use Cases</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-caveats">Caveats and Warnings</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-bestpractice">Best Practices</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#module-stats">Stats Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#module-stats-dynamic">Dynamic Stats</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#module-stats-static">Static Stats</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator">Ticket Number Generator Modules</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-code">Code example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-configuration">Configuration example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-usecases">Use Cases</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-caveats">Caveats and Warnings</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#ticketevent">Ticket Event Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-code">Code example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-configuration">Configuration example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-usecases">Use Cases</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-caveats">Caveats and Warnings</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-releases">Release Availability</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#frontend-modules">Frontend Modules</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#module-dashboard">Dashboard Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dashboard-module-caveats">Caveats and Warnings</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dashboard-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#notify-module">Notification Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#notify-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#notify-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#notify-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#notify-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module">Ticket Menu Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-caveats">Caveats and Warnings</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-releases">Release Availability</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#genericinterface-modules">Generic Interface Modules</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#transport">Network Transport</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_transport">Transport backend</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#mapping">Mapping</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_mapping">Mapping backend</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#invoker">Invoker</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_invoker">Invoker backend</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#operation">Operation</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_operation">Operation backend</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#daemon-scheduler-modules">Daemon And Scheduler</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#daemon-overview">OTRS Daemon</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#daemon-modules">OTRS Daemon Modules</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#scheduler-overview">OTRS Scheduler</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#scheduler-task-managers">OTRS Scheduler Task Managers</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#scheduler-task-workers">OTRS Scheduler Task Workers</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#dynamicfields-modules">Dynamic Fields</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-overview">Overview</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework">Dynamic Fields Framework</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-backends">Dynamic Field Backend Modules</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-admin">Dynamic Fields Admin Modules</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-core">Dynamic Fields Core Modules</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-database">Dynamic Fields Database Tables</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-configuration-files">Dynamic Fields Configuration Files</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-interaction">Dynamic Field Interaction With Frontend Modules</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-options">How To Extend The Dynamic Fields</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-options-new-field">Create a New Dynamic Field Type (for ticket or article objects)</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-options-new-field-new-object">Create a New Dynamic Field Type (for other objects)</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-options-new-packages">Create a New package to use Dynamic Fields</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-options-backend-functionalities">Extend Backend and Drivers Functionalities</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-options-extend-other">Other Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-new-field">Creating A New Dynamic Field</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-new-field-files">Dynamic Field Password files</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend">Creating a Dynamic Field Functionality Extension</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extension-full-example-files">Dynamic Field Foo Extension files</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#email-handling-modules">Email Handling</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#ticket-postmaster-module">Ticket PostMaster Module</a></span></dt></dl></dd></dl></div><p>
        OTRS has a large number of so-called "module layers" which make it very easy to extend
        the system without patching existing code. One example is the number generation mechanism
        for tickets. It is a "module layer" with
        <a class="link" href="otrs-module-layers.html#ticketnumber-generator" title="Ticket Number Generator Modules">pluggable modules</a>, and you can add
        your own custom number generator modules if you wish to do so.
        Let's look at the different layers in detail!
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="authentication-user-management-modules"></a>Authentication and user management</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="agent-auth-module"></a>Agent Authentication Module</h4></div></div></div><p>
        There are several agent authentication modules (DB, LDAP and HTTPBasicAuth)
        which come with the OTRS framework. It is also possible to develop your own
        authentication modules. The agent authentication modules are located under
        <code class="filename">Kernel/System/Auth/*.pm</code>. For more information about their configuration see the admin manual.
        Following, there is an example of a simple agent auth module. Save it under <code class="filename">Kernel/System/Auth/Simple.pm</code>.
        You just need 3 functions: <code class="code">new()</code>, <code class="code">GetOption()</code> and <code class="code">Auth()</code>. Return the uid, then the
        authentication is ok.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called <code class="literal">Kernel::System::Auth</code>. The example agent authentication
            may be called <code class="literal">Kernel::System::Auth::CustomAuth</code>. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Auth/CustomAuth.pm - provides the CustomAuth authentication
# based on Martin Edenhofer's Kernel::System::Auth::DB
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# ID: CustomAuth.pm,v 1.1 2010/05/10 15:30:34 fk Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Auth::CustomAuth;

use strict;
use warnings;

use Authen::CustomAuth;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

    # get config
    $Self-&gt;{Die} = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Die' . $Param{Count} );

    # get user table
    $Self-&gt;{CustomAuthHost} = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Host' . $Param{Count} )
        || die "Need AuthModule::CustomAuth::Host$Param{Count}.";
    $Self-&gt;{CustomAuthSecret}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Password' . $Param{Count} )
        || die "Need AuthModule::CustomAuth::Password$Param{Count}.";

    return $Self;
}

sub GetOption {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{What} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need What!" );
        return;
    }

    # module options
    my %Option = ( PreAuth =&gt; 0, );

    # return option
    return $Option{ $Param{What} };
}

sub Auth {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{User} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need User!" );
        return;
    }

    # get params
    my $User       = $Param{User}      || '';
    my $Pw         = $Param{Pw}        || '';
    my $RemoteAddr = $ENV{REMOTE_ADDR} || 'Got no REMOTE_ADDR env!';
    my $UserID     = '';
    my $GetPw      = '';

    # just in case for debug!
    if ( $Self-&gt;{Debug} &gt; 0 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: '$User' tried to authenticate with Pw: '$Pw' ($RemoteAddr)",
        );
    }

    # just a note
    if ( !$User ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "No User given!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # just a note
    if ( !$Pw ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication without Pw!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # Create a RADIUS object
    my $CustomAuth = Authen::CustomAuth-&gt;new(
        Host   =&gt; $Self-&gt;{CustomAuthHost},
        Secret =&gt; $Self-&gt;{CustomAuthecret},
    );
    if ( !$CustomAuth ) {
        if ( $Self-&gt;{Die} ) {
            die "Can't connect to $Self-&gt;{CustomAuthHost}: $@";
        }
        else {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Can't connect to $Self-&gt;{CustomAuthHost}: $@",
            );
            return;
        }
    }
    my $AuthResult = $CustomAuth-&gt;check_pwd( $User, $Pw );

    # login note
    if ( defined($AuthResult) &amp;&amp; $AuthResult == 1 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication ok (REMOTE_ADDR: $RemoteAddr).",
        );
        return $User;
    }

    # just a note
    else {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication with wrong Pw!!! (REMOTE_ADDR: $RemoteAddr)"
        );
        return;
    }
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom agent authenticate module.
            This can be done using the Perl configuration below.
            It is not recommended to use the XML configuration because you can lock
            you out via the sysconfig.
        </p><p>
        </p><pre class="programlisting">
            $Self-&gt;{'AuthModule'} = 'Kernel::System::Auth::CustomAuth';
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            A useful example of an authentication implementation could be a SOAP backend.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>DB</td><td>1.0</td></tr><tr><td>HTTPBasicAuth</td><td>1.2</td></tr><tr><td>LDAP</td><td>1.0</td></tr><tr><td>RADIUS</td><td>1.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-sync-module"></a>Authentication Synchronization Module</h4></div></div></div><p>
        There is an LDAP authentication synchronization module
        which come with the OTRS framework. It is also possible to develop your own
        authentication modules. The authentication synchronization modules are located under
        <code class="filename">Kernel/System/Auth/Sync/*.pm</code>. For more information about their configuration see the admin manual.
        Following, there is an example of an authentication synchronization module.
        Save it under <code class="filename">Kernel/System/Auth/Sync/CustomAuthSync.pm</code>.
        You just need 2 functions: <code class="code">new()</code> and <code class="code">Sync()</code>. Return 1, then the
        synchronization is ok.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called <code class="literal">Kernel::System::Auth</code>. The example agent authentication
            may be called <code class="literal">Kernel::System::Auth::Sync::CustomAuthSync</code>. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Auth/Sync/CustomAuthSync.pm - provides the CustomAuthSync
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# Id: CustomAuthSync.pm,v 1.9 2010/03/25 14:42:45 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Auth::Sync::CustomAuthSync;

use strict;
use warnings;
use Net::LDAP;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject UserObject GroupObject EncodeObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

...

    return $Self;
}

sub Sync {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(User)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }
...
    return 1;
}

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            You should activate your custom synchronization module.
            This can be done using the Perl configuration below.
            It is not recommended to use the XML configuration because this
            would allow you to lock yourself out via SysConfig.
        </p><p>
        </p><pre class="programlisting">
            $Self-&gt;{'AuthSyncModule'} = 'Kernel::System::Auth::Sync::LDAP';
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-use_cases"></a>Use Case Examples</h5></div></div></div><p>
            Useful synchronization implementation could be a SOAP or RADIUS backend.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>LDAP</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
        Please note that the synchronization was part of the authentication class <code class="literal">Kernel::System::Auth</code> before framework 2.4.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="customer-auth-module"></a>Customer Authentication Module</h4></div></div></div><p>
        There are several customer authentication modules (DB, LDAP and HTTPBasicAuth)
        which come with the OTRS framework. It is also possible to develop your own
        authentication modules. The customer authentication modules are located under
        <code class="filename">Kernel/System/CustomerAuth/*.pm</code>. For more information about their configuration see the admin manual.
        Following, there is an example of a simple customer auth module. Save it under <code class="filename">Kernel/System/CustomerAuth/Simple.pm</code>.
        You just need 3 functions: <code class="code">new()</code>, <code class="code">GetOption()</code> and <code class="code">Auth()</code>. Return the uid, then the
        authentication is ok.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called <code class="literal">Kernel::System::CustomerAuth</code>. The example customer authentication
            may be called <code class="literal">Kernel::System::CustomerAuth::CustomAuth</code>. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/CustomerAuth/CustomAuth.pm - provides the custom Authentication
# based on Martin Edenhofer's Kernel::System::Auth::DB
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# Id: CustomAuth.pm,v 1.11 2009/09/22 15:16:05 mb Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::CustomerAuth::CustomAuth;

use strict;
use warnings;

use Authen::CustomAuth;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

    # get config
    $Self-&gt;{Die}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Die' . $Param{Count} );

    # get user table
    $Self-&gt;{CustomAuthHost}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Host' . $Param{Count} )
        || die "Need Customer::AuthModule::CustomAuth::Host$Param{Count} in Kernel/Config.pm";
    $Self-&gt;{CustomAuthSecret}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Password' . $Param{Count} )
        || die "Need Customer::AuthModule::CustomAuth::Password$Param{Count} in Kernel/Config.pm";

    return $Self;
}

sub GetOption {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{What} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need What!" );
        return;
    }

    # module options
    my %Option = ( PreAuth =&gt; 0, );

    # return option
    return $Option{ $Param{What} };
}

sub Auth {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{User} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need User!" );
        return;
    }

    # get params
    my $User       = $Param{User}      || '';
    my $Pw         = $Param{Pw}        || '';
    my $RemoteAddr = $ENV{REMOTE_ADDR} || 'Got no REMOTE_ADDR env!';
    my $UserID     = '';
    my $GetPw      = '';

    # just in case for debug!
    if ( $Self-&gt;{Debug} &gt; 0 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: '$User' tried to authentificate with Pw: '$Pw' ($RemoteAddr)",
        );
    }

    # just a note
    if ( !$User ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "No User given!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # just a note
    if ( !$Pw ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication without Pw!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # Create a custom object
    my $CustomAuth = Authen::CustomAuth-&gt;new(
        Host   =&gt; $Self-&gt;{CustomAuthHost},
        Secret =&gt; $Self-&gt;{CustomAuthSecret},
    );
    if ( !$CustomAuth ) {
        if ( $Self-&gt;{Die} ) {
            die "Can't connect to $Self-&gt;{CustomAuthHost}: $@";
        }
        else {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Can't connect to $Self-&gt;{CustomAuthHost}: $@",
            );
            return;
        }
    }
    my $AuthResult = $CustomAuth-&gt;check_pwd( $User, $Pw );

    # login note
    if ( defined($AuthResult) &amp;&amp; $AuthResult == 1 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication ok (REMOTE_ADDR: $RemoteAddr).",
        );
        return $User;
    }

    # just a note
    else {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication with wrong Pw!!! (REMOTE_ADDR: $RemoteAddr)"
        );
        return;
    }
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom customer authenticate module.
            This can be done using the XML configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="AuthModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Module to authenticate customers.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Modul zum Authentifizieren der Customer.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::CustomerAuthAuth&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Option Location="Kernel/System/CustomerAuth/*.pm" SelectedID="Kernel::System::CustomerAuth::CustomAuth"&gt;&lt;/Option&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful authentication implementation could be a SOAP backend.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>DB</td><td>1.0</td></tr><tr><td>HTTPBasicAuth</td><td>1.2</td></tr><tr><td>LDAP</td><td>1.0</td></tr><tr><td>RADIUS</td><td>1.3</td></tr></tbody></table></div><p>
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="preferences-modules"></a>Preferences</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="customer-user-preferences-module"></a>Customer User Preferences Module</h4></div></div></div><p>
        There is a DB customer-user preferences module which come with the OTRS framework.
        It is also possible to develop your own customer-user preferences modules.
        The customer-user preferences modules are located under
        <code class="filename">Kernel/System/CustomerUser/Preferences/*.pm</code>. For more information about their configuration see the admin manual.
        Following, there is an example of a customer-user preferences module.
        Save it under <code class="filename">Kernel/System/CustomerUser/Preferences/Custom.pm</code>.
        You just need 4 functions: <code class="code">new()</code>, <code class="code">SearchPreferences()</code>, <code class="code">SetPreferences()</code> and <code class="code">GetPreferences()</code>.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called <code class="literal">Kernel::System::CustomerUser</code>. The example customer-user preferences
            may be called <code class="literal">Kernel::System::CustomerUser::Preferences::Custom</code>. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/CustomerUser/Preferences/Custom.pm - some customer user functions
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# Id: Custom.pm,v 1.20 2009/10/07 20:41:50 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::CustomerUser::Preferences::Custom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable} = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{Table}
        || 'customer_preferences';
    $Self-&gt;{PreferencesTableKey}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableKey}
        || 'preferences_key';
    $Self-&gt;{PreferencesTableValue}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableValue}
        || 'preferences_value';
    $Self-&gt;{PreferencesTableUserID}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableUserID}
        || 'user_id';

    return $Self;
}

sub SetPreferences {
    my ( $Self, %Param ) = @_;

    my $UserID = $Param{UserID} || return;
    my $Key    = $Param{Key}    || return;
    my $Value = defined( $Param{Value} ) ? $Param{Value} : '';

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . " $Self-&gt;{PreferencesTableUserID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$UserID, \$Key ],
    );

    $Value .= 'Custom';

    # insert new data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableUserID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$UserID, \$Key, \$Value ],
    );

    return 1;
}

sub GetPreferences {
    my ( $Self, %Param ) = @_;

    my $UserID = $Param{UserID} || return;
    my %Data;

    # get preferences

    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableUserID} = ?",
        Bind =&gt; [ \$UserID ],
    );
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

sub SearchPreferences {
    my ( $Self, %Param ) = @_;

    my %UserID;
    my $Key   = $Param{Key}   || '';
    my $Value = $Param{Value} || '';

    # get preferences
    my $SQL = "SELECT $Self-&gt;{PreferencesTableUserID}, $Self-&gt;{PreferencesTableValue} "
        . " FROM "
        . " $Self-&gt;{PreferencesTable} "
        . " WHERE "
        . " $Self-&gt;{PreferencesTableKey} = '"
        . $Self-&gt;{DBObject}-&gt;Quote($Key) . "'" . " AND "
        . " LOWER($Self-&gt;{PreferencesTableValue}) LIKE LOWER('"
        . $Self-&gt;{DBObject}-&gt;Quote( $Value, 'Like' ) . "')";

    return if !$Self-&gt;{DBObject}-&gt;Prepare( SQL =&gt; $SQL );
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $UserID{ $Row[0] } = $Row[1];
    }

    # return data
    return %UserID;
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom customer-user preferences module.
            This can be done using the XML configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="CustomerPreferences" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Parameters for the customer preference table.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Parameter für die Tabelle mit den Einstellungen für die Customer.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Customer::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::System::CustomerUser::Preferences::Custom&lt;/Item&gt;
            &lt;Item  Key="Params"&gt;
                &lt;Hash&gt;
                    &lt;Item Key="Table"&gt;customer_preferences&lt;/Item&gt;
                    &lt;Item Key="TableKey"&gt;preferences_key&lt;/Item&gt;
                    &lt;Item Key="TableValue"&gt;preferences_value&lt;/Item&gt;
                    &lt;Item Key="TableUserID"&gt;user_id&lt;/Item&gt;
                &lt;/Hash&gt;
            &lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful preferences implementation could be a SOAP or LDAP backend.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>DB</td><td>2.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="queue-preferences-module"></a>Queue Preferences Module</h4></div></div></div><p>
        There is a DB queue preferences module which come with the OTRS framework.
        It is also possible to develop your own queue preferences modules.
        The queue preferences modules are located under
        <code class="filename">Kernel/System/Queue/*.pm</code>. For more information about their configuration see the admin manual.
        Following, there is an example of a queue preferences module.
        Save it under <code class="filename">Kernel/System/Queue/PreferencesCustom.pm</code>.
        You just need 3 functions: <code class="code">new()</code>, <code class="code">QueuePreferencesSet()</code> and <code class="code">QueuePreferencesGet()</code>. Return 1, then the
        synchronization is ok.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called <code class="literal">Kernel::System::Queue</code>. The example queue preferences
            may be called <code class="literal">Kernel::System::Queue::PreferencesCustom</code>. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Queue/PreferencesCustom.pm - some user functions
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# Id: PreferencesCustom.pm,v 1.5 2009/02/16 11:47:34 tr Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Queue::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}        = 'queue_preferences';
    $Self-&gt;{PreferencesTableKey}     = 'preferences_key';
    $Self-&gt;{PreferencesTableValue}   = 'preferences_value';
    $Self-&gt;{PreferencesTableQueueID} = 'queue_id';

    return $Self;
}

sub QueuePreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(QueueID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableQueueID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{QueueID}, \$Param{Key} ],
    );

    $Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableQueueID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{QueueID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub QueuePreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(QueueID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if queue preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('QueuePreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableQueueID} = ?",
        Bind =&gt; [ \$Param{QueueID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom queue preferences module.
            This can be done using the XML configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Queue::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Default queue preferences module.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Standard Queue Preferences Module.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Queue::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::Queue::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-use_cases"></a>Use Case Examples</h5></div></div></div><p>
            Useful preferences implementation could be a SOAP or RADIUS backend.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="service-preferences-module"></a>Service Preferences Module</h4></div></div></div><p>
        There is a DB service preferences module which come with the OTRS framework.
        It is also possible to develop your own service preferences modules.
        The service preferences modules are located under
        <code class="filename">Kernel/System/Service/*.pm</code>. For more information about their configuration see the admin manual.
        Following, there is an example of a service preferences module.
        Save it under <code class="filename">Kernel/System/Service/PreferencesCustom.pm</code>.
        You just need 3 functions: <code class="code">new()</code>, <code class="code">ServicePreferencesSet()</code> and <code class="code">ServicePreferencesGet()</code>. Return 1, then the
        synchronization is ok.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called <code class="literal">Kernel::System::Service</code>. The example service preferences
            may be called <code class="literal">Kernel::System::Service::PreferencesCustom</code>. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Service/PreferencesCustom - some user functions
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# Id: PreferencesCustom.pm,v 1.2 2009/02/16 11:47:34 tr Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Service::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}          = 'service_preferences';
    $Self-&gt;{PreferencesTableKey}       = 'preferences_key';
    $Self-&gt;{PreferencesTableValue}     = 'preferences_value';
    $Self-&gt;{PreferencesTableServiceID} = 'service_id';

    return $Self;
}

sub ServicePreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ServiceID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableServiceID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{ServiceID}, \$Param{Key} ],
    );

$Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableServiceID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{ServiceID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub ServicePreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ServiceID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if service preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('ServicePreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableServiceID} = ?",
        Bind =&gt; [ \$Param{ServiceID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom service preferences module.
            This can be done using the XML configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Service::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Default service preferences module.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Standard Service Preferences Module.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Service::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::Service::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful preferences implementation could be a SOAP or RADIUS backend.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sla-preferences-module"></a>SLA Preferences Module</h4></div></div></div><p>
        There is a DB SLA preferences module which come with the OTRS framework.
        It is also possible to develop your own SLA preferences modules.
        The SLA preferences modules are located under
        <code class="filename">Kernel/System/SLA/*.pm</code>. For more information about their configuration see the admin manual.
        Following, there is an example of an SLA preferences module.
        Save it under <code class="filename">Kernel/System/SLA/PreferencesCustom.pm</code>.
        You just need 3 functions: <code class="code">new()</code>, <code class="code">SLAPreferencesSet()</code> and <code class="code">SLAPreferencesGet()</code>.
        Make sure the function returns 1.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called <code class="literal">Kernel::System::SLA</code>. The example SLA preferences
            may be called <code class="literal">Kernel::System::SLA::PreferencesCustom</code>. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/SLA/PreferencesCustom.pm - some user functions
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::SLA::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}      = 'sla_preferences';
    $Self-&gt;{PreferencesTableKey}   = 'preferences_key';
    $Self-&gt;{PreferencesTableValue} = 'preferences_value';
    $Self-&gt;{PreferencesTableSLAID} = 'sla_id';

    return $Self;
}

sub SLAPreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(SLAID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableSLAID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{SLAID}, \$Param{Key} ],
    );

$Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableSLAID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{SLAID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub SLAPreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(SLAID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if SLA preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('SLAPreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableSLAID} = ?",
        Bind =&gt; [ \$Param{SLAID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom SLA preferences module.
            This can be done using the XML configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="SLA::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Default SLA preferences module.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::SLA::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::SLA::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful preferences implementation could be to store additional values on SLAs.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="core-modules"></a>Other core functions</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="log-module"></a>Log Module</h4></div></div></div><p>
There is a global log interface for OTRS that provides the possibility to create own log backends.
    </p><p>
Writing an own logging backend is as easy as reimplementing the <code class="literal">Kernel::System::Log::Log()</code> method.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-code"></a>Code example: <code class="literal">Kernel::System::Log::CustomFile</code></h5></div></div></div><p>
            In this small example, we'll write a little file logging backend which works similar to
            <code class="literal">Kernel::System::Log::File</code>, but prepends a string to each logging entry.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Log/CustomFile.pm - file log backend
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Log::CustomFile;

use strict;
use warnings;

umask "002";

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for (qw(ConfigObject EncodeObject)) {
        if ( $Param{$_} ) {
            $Self-&gt;{$_} = $Param{$_};
        }
        else {
            die "Got no $_!";
        }
    }

    # get logfile location
    $Self-&gt;{LogFile} = '/var/log/CustomFile.log';

    # set custom prefix
    $Self-&gt;{CustomPrefix} = 'CustomFileExample';

    # Fixed bug# 2265 - For IIS we need to create a own error log file.
    # Bind stderr to log file, because IIS do print stderr to web page.
    if ( $ENV{SERVER_SOFTWARE} &amp;&amp; $ENV{SERVER_SOFTWARE} =~ /^microsoft\-iis/i ) {
        if ( !open STDERR, '&gt;&gt;', $Self-&gt;{LogFile} . '.error' ) {
            print STDERR "ERROR: Can't write $Self-&gt;{LogFile}.error: $!";
        }
    }

    return $Self;
}

sub Log {
    my ( $Self, %Param ) = @_;

    my $FH;

    # open logfile
    if ( !open $FH, '&gt;&gt;', $Self-&gt;{LogFile} ) {

        # print error screen
        print STDERR "\n";
        print STDERR " &gt;&gt; Can't write $Self-&gt;{LogFile}: $! &lt;&lt;\n";
        print STDERR "\n";
        return;
    }

    # write log file
    $Self-&gt;{EncodeObject}-&gt;SetIO($FH);
    print $FH '[' . localtime() . ']';
    if ( lc $Param{Priority} eq 'debug' ) {
        print $FH "[Debug][$Param{Module}][$Param{Line}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'info' ) {
        print $FH "[Info][$Param{Module}]  $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'notice' ) {
        print $FH "[Notice][$Param{Module}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'error' ) {
        print $FH "[Error][$Param{Module}][$Param{Line}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    else {

        # print error messages to STDERR
        print STDERR
            "[Error][$Param{Module}] $Self-&gt;{CustomPrefix} Priority: '$Param{Priority}' not defined! Message: $Param{Message}\n";

        # and of course to logfile
        print $FH
            "[Error][$Param{Module}] $Self-&gt;{CustomPrefix} Priority: '$Param{Priority}' not defined! Message: $Param{Message}\n";
    }

    # close file handle
    close $FH;
    return 1;
}

1;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-configuration"></a>Configuration example</h5></div></div></div><p>
            To activate our custom logging module, the administrator can either set the existing
            configuration item <code class="literal">LogModule</code> manually to <code class="literal">Kernel::System::Log::CustomFile</code>. To realize
            this automatically, you can provide an XML configuration file which overrides the default
            setting.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="LogModule" Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Set Kernel::System::Log::CustomFile as default logging backend.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Core::Log&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Option Location="Kernel/System/Log/*.pm" SelectedID="Kernel::System::Log::CustomFile"&gt;&lt;/Option&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-use_cases"></a>Use case examples</h5></div></div></div><p>
Useful logging backends could be logging to a web service or to encrypted files.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
Please note that <code class="literal">Kernel::System::Log</code> has other methods than <code class="literal">Log()</code> which cannot be reimplemented,
for example code for working with shared memory segments and log data caching.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="outputfilter"></a>Output Filter</h4></div></div></div><p>
        Output filters allow to modify HTML on the fly. It is best practice to use output filters
        instead of modifying <code class="filename">.tt</code> files directly.
        There are three good reasons for that.
        When the same adaptation has to be applied to several frontend modules then the adaption only has to be implemented once.
        The second advantage is that when OTRS is upgraded
        there is a chance that the filter doesn't have to be updated, when the relevant pattern has not changed.
        When two extensions modify the same file there is a conflict during the installation of the second package.
        This conflict can be resolved by using two output filters that modify the same frontend module.
    </p><p>
        There are three different kinds of output filters. They are active at different stages of the
        generation of HTML content.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter_filterelement_post"></a><code class="literal">FilterElementPost</code></h5></div></div></div><p>
            These filters allow to modify the output of a template after it was rendered.
        </p><p>
            To translate content, you can run <code class="code">$LayoutObject-&gt;Translate()</code> directly. If you need other template features, just define a small template file for your output filter and use it to render your content before injecting it into the main data. It can also be helpful to use jQuery DOM operations to reorder/replace content on the screen in some cases instead of using regular expressions. In this case you would inject the new code somewhere in the page as invisible content (e. g. with the class <code class="literal">Hidden</code>), and then move it with jQuery to the correct location in the DOM and show it.
        </p><p>
            To make using post output filters easier, there is also a mechanism to request HTML comment hooks for certain templates/blocks. You can add in your module config XML like:
        </p><p>
            </p><pre class="programlisting">
&lt;ConfigItem
Name="Frontend::Template::GenerateBlockHooks###100-OTRSBusiness-ContactWithData"
Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Generate HTML comment hooks for
the specified blocks so that filters can use them.&lt;/Description&gt;
    &lt;Group&gt;OTRSBusiness&lt;/Group&gt;
    &lt;SubGroup&gt;Core&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="AgentTicketZoom"&gt;
                &lt;Array&gt;
                    &lt;Item&gt;CustomerTable&lt;/Item&gt;
                &lt;/Array&gt;
            &lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            This will cause the block <code class="literal">CustomerTable</code> in <code class="filename">AgentTicketZoom.tt</code> to be
            wrapped in HTML comments each time it is rendered:
        </p><p>
            </p><pre class="programlisting">
&lt;!--HookStartCustomerTable--&gt;
... block output ...
&lt;!--HookEndCustomerTable--&gt;
            </pre><p>
        </p><p>
            With this mechanism every package can request just the block hooks it
            needs, and they are consistently rendered. These HTML comments can then be used in your
            output filter for easy regular expression matching.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter_filtercontent"></a><code class="literal">FilterContent</code></h5></div></div></div><p>
            This kind of filter allows to process the complete HTML output for the request
            right before it is sent to the browser. This can be used for global transformations.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter_filtertext"></a><code class="literal">FilterText</code></h5></div></div></div><p>
            This kind of output filter is a plugin for the method
            <code class="literal">Kernel::Output::HTML::Layout::Ascii2HTML()</code>
            and is only active when the parameter <code class="literal">LinkFeature</code> is set to 1.
            Thus the <code class="literal">FilterText</code> output filters are currently only active for
            the display of the body of plain text articles.
            Plain text articles are generated by incoming non-HTML mails
            and when OTRS is configured to not use the Rich Text feature in the frontend.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-code"></a>Code example</h5></div></div></div><p>
            See package <code class="literal">TemplateModule</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-configuration"></a>Configuration example</h5></div></div></div><p>
            See package <code class="literal">TemplateModule</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-usecases"></a>Use Cases</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-10"></a>Show additional ticket attributes in <code class="literal">AgentTicketZoom</code></h6></div></div></div><p>
                This can be achieved with a <code class="literal">FilterElementPost</code> output filter.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-30"></a>Show the service selection as a multi level menu</h6></div></div></div><p>
                Use a <code class="literal">FilterElementPost</code> for this feature.
                The list of selectable services can be parsed from the processed template
                output. The multi level selection can be constructed from the service list and
                inserted into the template content. A <code class="literal">FilterElementPost</code> output
                filter must be used for that.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-40"></a>Create links within plain text article bodies</h6></div></div></div><p>
                A biotech company uses gene names like IPI00217472 in plain text articles.
                A <code class="literal">FilterText</code> output filter can be used to create links to a
                sequence database, e.g. http://srs.ebi.ac.uk/srsbin/cgi-bin/wgetz?-e+[IPI-acc:IPI00217472]+-vn+2,
                for the gene names.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-50"></a>Prohibit active content</h6></div></div></div><p>
                There is firewall rule that disallows all active content. In order to avoid
                rejection by the firewall, the HTML tag <code class="literal">&lt;applet&gt;</code> can be
                filtered with a <code class="literal">FilterContent</code> output filter.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
            Every <code class="literal">FilterElementPost</code> output filter is constructed and run
            for every configured Template that is needed for the current request.
            Thus low performance of the output filter or a large number of filters can
            severely degrade performance.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-bestpractice"></a>Best Practices</h5></div></div></div><p>
            In order to increase flexibility the list of affected templates should be
            configured in SysConfig.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-releases"></a>Release Availability</h5></div></div></div><p>
            The output filters are available since OTRS 2.4. The type <code class="literal">FilterElementPre</code>
            was dropped with OTRS 5.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="module-stats"></a>Stats Module</h4></div></div></div><p>
There are two different types of internal stats modules - dynamic and static. This section describes how such stats modules can be developed.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="module-stats-dynamic"></a>Dynamic Stats</h5></div></div></div><p>
In contrast to static stats modules, dynamic statistics can be configured via the OTRS web interface. In this section a simple statistic module is developed. Each dynamic stats module has to implement these subroutines:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">GetObjectName</code></p></li><li class="listitem"><p><code class="literal">GetObjectAttributes</code></p></li><li class="listitem"><p><code class="literal">ExportWrapper</code></p></li><li class="listitem"><p><code class="literal">ImportWrapper</code></p></li></ul></div><p>
        </p><p>
Furthermore the module has to implement either <code class="literal">GetStatElement</code> or <code class="literal">GetStatTable</code>. And if the header line of the result table should be changed, a sub called <code class="literal">GetHeaderLine</code> has to be developed.
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-subroutines"></a>Code example</h6></div></div></div><p>
In this section a sample stats module is shown and each subroutine is explained.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Dynamic/DynamicStatsTemplate.pm - all advice functions
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Stats::Dynamic::DynamicStatsTemplate;

use strict;
use warnings;

use Kernel::System::Queue;
use Kernel::System::State;
use Kernel::System::Ticket;
                </pre><p>
            </p><p>
This is a common boilerplate that can be found in common OTRS modules. The class/package name is declared via the <code class="literal">package</code> keyword. Then the needed modules are used via the <code class="literal">use</code> keyword.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (
        qw(DBObject ConfigObject LogObject UserObject TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    # created needed objects
    $Self-&gt;{QueueObject}    = Kernel::System::Queue-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject}   = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{StateObject}    = Kernel::System::State-&gt;new( %{$Self} );

    return $Self;
}
                </pre><p>
            </p><p>
The <code class="literal">new</code> is the constructor for this statistic module. It creates a new instance of the class. According to the coding guidelines objects of other classes that are needed in this module have to be created in <code class="literal">new</code>. In lines 27 to 29 the object of the stats module is created. Lines 31 to 37 check if objects that are needed in this code - either for creating other objects or in this module - are passed. After that the other objects are created.
            </p><p>
                </p><pre class="programlisting">
sub GetObjectName {
    my ( $Self, %Param ) = @_;

    return 'Sample Statistics';
}
                </pre><p>
            </p><p>
<code class="literal">GetObjectName</code> returns a name for the statistics module. This is the label that is shown in the drop down in the configuration as well as in the list of existing statistics (column "object").
            </p><p>
                </p><pre class="programlisting">
sub GetObjectAttributes {
    my ( $Self, %Param ) = @_;

    # get state list
    my %StateList = $Self-&gt;{StateObject}-&gt;StateList(
        UserID =&gt; 1,
    );

    # get queue list
    my %QueueList = $Self-&gt;{QueueObject}-&gt;GetAllQueues();

    # get current time to fix bug#3830
    my $TimeStamp = $Self-&gt;{TimeObject}-&gt;CurrentTimestamp();
    my ($Date) = split /\s+/, $TimeStamp;
    my $Today = sprintf "%s 23:59:59", $Date;

    my @ObjectAttributes = (
        {
            Name             =&gt; 'State',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'StateIDs',
            Block            =&gt; 'MultiSelectField',
            Values           =&gt; \%StateList,
        },
        {
            Name             =&gt; 'Created in Queue',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
        },
        {
            Name             =&gt; 'Create Time',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreateTime',
            TimePeriodFormat =&gt; 'DateInputFormat',    # 'DateInputFormatLong',
            Block            =&gt; 'Time',
            TimeStop         =&gt; $Today,
            Values           =&gt; {
                TimeStart =&gt; 'TicketCreateTimeNewerDate',
                TimeStop  =&gt; 'TicketCreateTimeOlderDate',
            },
        },
    );

    return @ObjectAttributes;
}
                </pre><p>
            </p><p>
In this sample stats module, we want to provide three attributes the user can chose from: a list of queues, a list of states and a time drop down. To get the values shown in the drop down, some operations are needed. In this case <code class="literal">StateList</code> and <code class="literal">GetAllQueues</code> are called.
            </p><p>
Then the list of attributes is created. Each attribute is defined via a hash reference. You can use these keys:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">Name</code></p><p>The label in the web interface.</p></li><li class="listitem"><p><code class="literal">UseAsXvalue</code></p><p>This attribute can be used on the x-axis.</p></li><li class="listitem"><p><code class="literal">UseAsValueSeries</code></p><p>This attribute can be used on the y-axis.</p></li><li class="listitem"><p><code class="literal">UseAsRestriction</code></p><p>This attribute can be used for restrictions.</p></li><li class="listitem"><p><code class="literal">Element</code></p><p>The HTML field name.</p></li><li class="listitem"><p><code class="literal">Block</code></p><p>The block name in the template file (e.g. <code class="filename">&lt;OTRS_HOME&gt;/Kernel/Output/HTML/Standard/AgentStatsEditXaxis.tt</code>).</p></li><li class="listitem"><p><code class="literal">Values</code></p><p>The values shown in the attribute.</p></li></ul></div><p>
            </p><p>
Hint: If you install this sample and you configure a statistic with some queues - lets say 'queue A' and 'queue B' - then these queues are the only ones that are shown to the user when he starts the statistic. Sometimes a dynamic drop down or multiselect field is needed. In this case, you can set <code class="literal">SelectedValues</code> in the definition of the attribute:
            </p><p>
                </p><pre class="programlisting">
        {
            Name             =&gt; 'Created in Queue',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
            SelectedValues   =&gt; [ @SelectedQueues ],
        },
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
sub GetStatElement {
    my ( $Self, %Param ) = @_;

    # search tickets
    return $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'COUNT',
        Permission =&gt; 'ro',
        Limit      =&gt; 100_000_000,
        %Param,
    );
}
                </pre><p>
            </p><p>
<code class="literal">GetStatElement</code> gets called for each cell in the result table. So it should be a numeric value. In this sample it does a simple ticket search. The hash <code class="literal">%Param</code> contains information about the "current" x-value and the y-value as well as any restrictions. So, for a cell that should count the created tickets for queue 'Misc' with state 'open' the passed parameter hash looks something like this:
            </p><p>
                </p><pre class="programlisting">
    'CreatedQueueIDs' =&gt; [
        '4'
    ],
    'StateIDs' =&gt; [
        '2'
    ]
                </pre><p>
            </p><p>
If the "per cell" calculation should be avoided, <code class="literal">GetStatTable</code> is an alternative. <code class="literal">GetStatTable</code> returns a list of rows, hence an array of array references. This leads to the same result as using <code class="literal">GetStatElement</code>.
            </p><p>
                </p><pre class="programlisting">
sub GetStatTable {
    my ( $Self, %Param ) = @_;

    my @StatData;

    for my $StateName ( keys %{ $Param{TableStructure} } ) {
        my @Row;
        for my $Params ( @{ $Param{TableStructure}-&gt;{$StateName} } ) {
            my $Tickets = $Self-&gt;{TicketObject}-&gt;TicketSearch(
                UserID     =&gt; 1,
                Result     =&gt; 'COUNT',
                Permission =&gt; 'ro',
                Limit      =&gt; 100_000_000,
                %{$Params},
            );

            push @Row, $Tickets;
        }

        push @StatData, [ $StateName, @Row ];
    }

    return @StatData;
}
                </pre><p>
            </p><p>
<code class="literal">GetStatTable</code> gets all information about the stats query that is needed. The passed parameters contain information about the attributes (<code class="literal">Restrictions</code>, attributes that are used for x/y-axis) and the table structure. The table structure is a hash reference where the keys are the values of the y-axis and their values are hash references with the parameters used for <code class="literal">GetStatElement</code> subroutines.
            </p><p>
                </p><pre class="programlisting">
    'Restrictions' =&gt; {},
    'TableStructure' =&gt; {
        'closed successful' =&gt; [
            {
                'CreatedQueueIDs' =&gt; [
                    '3'
                ],
                'StateIDs' =&gt; [
                    '2'
                ]
            },
        ],
        'closed unsuccessful' =&gt; [
            {
                'CreatedQueueIDs' =&gt; [
                    '3'
                ],
                'StateIDs' =&gt; [
                    '3'
                ]
            },
        ],
    },
    'ValueSeries' =&gt; [
        {
            'Block' =&gt; 'MultiSelectField',
            'Element' =&gt; 'StateIDs',
            'Name' =&gt; 'State',
            'SelectedValues' =&gt; [
                '5',
                '3',
                '2',
                '1',
                '4'
            ],
            'Translation' =&gt; 1,
            'Values' =&gt; {
                '1' =&gt; 'new',
                '10' =&gt; 'closed with workaround',
                '2' =&gt; 'closed successful',
                '3' =&gt; 'closed unsuccessful',
                '4' =&gt; 'open',
                '5' =&gt; 'removed',
                '6' =&gt; 'pending reminder',
                '7' =&gt; 'pending auto close+',
                '8' =&gt; 'pending auto close-',
                '9' =&gt; 'merged'
            }
        }
    ],
    'XValue' =&gt; {
        'Block' =&gt; 'MultiSelectField',
        'Element' =&gt; 'CreatedQueueIDs',
        'Name' =&gt; 'Created in Queue',
        'SelectedValues' =&gt; [
            '3',
            '4',
            '1',
            '2'
        ],
        'Translation' =&gt; 0,
        'Values' =&gt; {
            '1' =&gt; 'Postmaster',
            '2' =&gt; 'Raw',
            '3' =&gt; 'Junk',
            '4' =&gt; 'Misc'
        }
    }
                </pre><p>
            </p><p>
Sometimes the headers of the table have to be changed. In that case, a subroutine called <code class="literal">GetHeaderLine</code> has to be implemented. That subroutine has to return an array reference with the column headers as elements. It gets information about the x-values passed.
            </p><p>
                </p><pre class="programlisting">
sub GetHeaderLine {
    my ( $Self, %Param ) = @_;

    my @HeaderLine = ('');
    for my $SelectedXValue ( @{ $Param{XValue}-&gt;{SelectedValues} } ) {
        push @HeaderLine, $Param{XValue}-&gt;{Values}-&gt;{$SelectedXValue};
    }

    return \@HeaderLine;
}
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
sub ExportWrapper {
    my ( $Self, %Param ) = @_;

    # wrap ids to used spelling
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $Self-&gt;{QueueObject}-&gt;QueueLookup( QueueID =&gt; $ID-&gt;{Content} );
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                my %StateList = $Self-&gt;{StateObject}-&gt;StateList( UserID =&gt; 1 );
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $StateList{ $ID-&gt;{Content} };
                }
            }
        }
    }
    return \%Param;
}
                </pre><p>
            </p><p>
Configured statistics can be exported into XML format. But as queues with the same queue names can have different IDs on different OTRS instances it would be quite painful to export the IDs (the statistics would calculate the wrong numbers then). So an export wrapper should be written to use the names instead of ids. This should be done for each "dimension" of the stats module (x-axis, y-axis and restrictions).
            </p><p>
<code class="literal">ImportWrapper</code> works the other way around - it converts the name to the ID in the instance the configuration is imported to.
            </p><p>
This is a sample export:
            </p><p>
                </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;otrs_stats&gt;
&lt;Cache&gt;0&lt;/Cache&gt;
&lt;Description&gt;Sample stats module&lt;/Description&gt;
&lt;File&gt;&lt;/File&gt;
&lt;Format&gt;CSV&lt;/Format&gt;
&lt;Format&gt;Print&lt;/Format&gt;
&lt;Object&gt;DeveloperManualSample&lt;/Object&gt;
&lt;ObjectModule&gt;Kernel::System::Stats::Dynamic::DynamicStatsTemplate&lt;/ObjectModule&gt;
&lt;ObjectName&gt;Sample Statistics&lt;/ObjectName&gt;
&lt;Permission&gt;stats&lt;/Permission&gt;
&lt;StatType&gt;dynamic&lt;/StatType&gt;
&lt;SumCol&gt;0&lt;/SumCol&gt;
&lt;SumRow&gt;0&lt;/SumRow&gt;
&lt;Title&gt;Sample 1&lt;/Title&gt;
&lt;UseAsValueSeries Element="StateIDs" Fixed="1"&gt;
&lt;SelectedValues&gt;removed&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;closed unsuccessful&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;closed successful&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;new&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;open&lt;/SelectedValues&gt;
&lt;/UseAsValueSeries&gt;
&lt;UseAsXvalue Element="CreatedQueueIDs" Fixed="1"&gt;
&lt;SelectedValues&gt;Junk&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Misc&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Postmaster&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Raw&lt;/SelectedValues&gt;
&lt;/UseAsXvalue&gt;
&lt;Valid&gt;1&lt;/Valid&gt;
&lt;/otrs_stats&gt;
                </pre><p>
            </p><p>
Now, that all subroutines are explained, this is the complete sample stats module.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Dynamic/DynamicStatsTemplate.pm - all advice functions
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Stats::Dynamic::DynamicStatsTemplate;

use strict;
use warnings;

use Kernel::System::Queue;
use Kernel::System::State;
use Kernel::System::Ticket;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (
        qw(DBObject ConfigObject LogObject UserObject TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    # created needed objects
    $Self-&gt;{QueueObject}    = Kernel::System::Queue-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject}   = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{StateObject}    = Kernel::System::State-&gt;new( %{$Self} );

    return $Self;
}

sub GetObjectName {
    my ( $Self, %Param ) = @_;

    return 'Sample Statistics';
}

sub GetObjectAttributes {
    my ( $Self, %Param ) = @_;

    # get state list
    my %StateList = $Self-&gt;{StateObject}-&gt;StateList(
        UserID =&gt; 1,
    );

    # get queue list
    my %QueueList = $Self-&gt;{QueueObject}-&gt;GetAllQueues();

    # get current time to fix bug#3830
    my $TimeStamp = $Self-&gt;{TimeObject}-&gt;CurrentTimestamp();
    my ($Date) = split /\s+/, $TimeStamp;
    my $Today = sprintf "%s 23:59:59", $Date;

    my @ObjectAttributes = (
        {
            Name             =&gt; 'State',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'StateIDs',
            Block            =&gt; 'MultiSelectField',
            Values           =&gt; \%StateList,
        },
        {
            Name             =&gt; 'Created in Queue',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
        },
        {
            Name             =&gt; 'Create Time',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreateTime',
            TimePeriodFormat =&gt; 'DateInputFormat',    # 'DateInputFormatLong',
            Block            =&gt; 'Time',
            TimeStop         =&gt; $Today,
            Values           =&gt; {
                TimeStart =&gt; 'TicketCreateTimeNewerDate',
                TimeStop  =&gt; 'TicketCreateTimeOlderDate',
            },
        },
    );

    return @ObjectAttributes;
}

sub GetStatElement {
    my ( $Self, %Param ) = @_;

    # search tickets
    return $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'COUNT',
        Permission =&gt; 'ro',
        Limit      =&gt; 100_000_000,
        %Param,
    );
}

sub ExportWrapper {
    my ( $Self, %Param ) = @_;

    # wrap ids to used spelling
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $Self-&gt;{QueueObject}-&gt;QueueLookup( QueueID =&gt; $ID-&gt;{Content} );
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                my %StateList = $Self-&gt;{StateObject}-&gt;StateList( UserID =&gt; 1 );
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $StateList{ $ID-&gt;{Content} };
                }
            }
        }
    }
    return \%Param;
}

sub ImportWrapper {
    my ( $Self, %Param ) = @_;

    # wrap used spelling to ids
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    if ( $Self-&gt;{QueueObject}-&gt;QueueLookup( Queue =&gt; $ID-&gt;{Content} ) ) {
                        $ID-&gt;{Content}
                            = $Self-&gt;{QueueObject}-&gt;QueueLookup( Queue =&gt; $ID-&gt;{Content} );
                    }
                    else {
                        $Self-&gt;{LogObject}-&gt;Log(
                            Priority =&gt; 'error',
                            Message  =&gt; "Import: Can' find the queue $ID-&gt;{Content}!"
                        );
                        $ID = undef;
                    }
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;

                    my %State = $Self-&gt;{StateObject}-&gt;StateGet(
                        Name  =&gt; $ID-&gt;{Content},
                        Cache =&gt; 1,
                    );
                    if ( $State{ID} ) {
                        $ID-&gt;{Content} = $State{ID};
                    }
                    else {
                        $Self-&gt;{LogObject}-&gt;Log(
                            Priority =&gt; 'error',
                            Message  =&gt; "Import: Can' find state $ID-&gt;{Content}!"
                        );
                        $ID = undef;
                    }
                }
            }
        }
    }
    return \%Param;
}

1;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-configuration"></a>Configuration example</h6></div></div></div><p>
                </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;otrs_config version="1.0" init="Config"&gt;
    &lt;ConfigItem Name="Stats::DynamicObjectRegistration###DynamicStatsTemplate" Required="0" Valid="1"&gt;
        &lt;Description Lang="en"&gt;Here you can decide if the common stats module may generate stats about the number of default tickets a requester created.&lt;/Description&gt;
        &lt;Group&gt;Framework&lt;/Group&gt;
        &lt;SubGroup&gt;Core::Stats&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;Hash&gt;
                &lt;Item Key="Module"&gt;Kernel::System::Stats::Dynamic::DynamicStatsTemplate&lt;/Item&gt;
            &lt;/Hash&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
&lt;/otrs_config&gt;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-use_cases"></a>Use case examples</h6></div></div></div><p>
Use cases.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
If you have a lot of cells in the result table and the <code class="literal">GetStatElement</code> is quite complex, the request can take a long time.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-releases"></a>Release Availability</h6></div></div></div><p>
Dynamic stat modules are available since OTRS 2.0.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="module-stats-static"></a>Static Stats</h5></div></div></div><p>
The subsequent paragraphs describe the static stats. Static stats are very easy to create as these modules have to implement only three subroutines.
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">Param</code></p></li><li class="listitem"><p><code class="literal">Run</code></p></li></ul></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-subroutines"></a>Code example</h6></div></div></div><p>
The following paragraphs describe the subroutines needed in a static stats.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # check all needed objects
    for my $Needed (
        qw(DBObject ConfigObject LogObject
        TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Needed} = $Param{$Needed} || die "Got no $Needed";
    }

    # create needed objects
    $Self-&gt;{TypeObject}   = Kernel::System::Type-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject} = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{QueueObject}  = Kernel::System::Queue-&gt;new( %{$Self} );

    return $Self;
}
                </pre><p>
            </p><p>
The <code class="literal">new</code> creates a new instance of the static stats class. First it creates a new object and then it checks for the needed objects.
            </p><p>
                </p><pre class="programlisting">
sub Param {
    my $Self = shift;

    my %Queues = $Self-&gt;{QueueObject}-&gt;GetAllQueues();
    my %Types  = $Self-&gt;{TypeObject}-&gt;TypeList(
        Valid =&gt; 1,
    );

    my @Params = (
        {
            Frontend  =&gt; 'Type',
            Name      =&gt; 'TypeIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Types,
        },
        {
            Frontend  =&gt; 'Queue',
            Name      =&gt; 'QueueIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Queues,
        },
    );

    return @Params;
}
                </pre><p>
            </p><p>
The <code class="literal">Param</code> method provides the list of all parameters/attributes that can be selected to create a static stat. It gets some parameters passed: The values for the stats attributes provided in a request, the format of the stats and the name of the object (name of the module).
            </p><p>
The parameters/attributes have to be hash references with these key-value pairs:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">Frontend</code></p><p>The label in the web interface.</p></li><li class="listitem"><p><code class="literal">Name</code></p><p>The HTML field name.</p></li><li class="listitem"><p><code class="literal">Data</code></p><p>The values shown in the attribute.</p></li></ul></div><p>
            </p><p>
Other parameter for the <code class="literal">BuildSelection</code> method of the <code class="literal">LayoutObject</code> can be used, as it is done with <code class="literal">Size</code> and <code class="literal">Multiple</code> in this sample module.
            </p><p>
                </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Needed (qw(TypeIDs QueueIDs)) {
        if ( !$Param{$Needed} ) {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Need $Needed!",
            );
            return;
        }
    }

    # set report title
    my $Title = 'Tickets per Queue';

    # table headlines
    my @HeadData = (
        'Ticket Number',
        'Queue',
        'Type',
    );

    my @Data;
    my @TicketIDs = $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'ARRAY',
        Permission =&gt; 'ro',
        %Param,
    );

    for my $TicketID ( @TicketIDs ) {
        my %Ticket = $Self-&gt;{TicketObject}-&gt;TicketGet(
            UserID =&gt; 1,
            TicketID =&gt; $TicketID,
        );
        push @Data, [ $Ticket{TicketNumber}, $Ticket{Queue}, $Ticket{Type} ];
    }

    return ( [$Title], [@HeadData], @Data );
}
                </pre><p>
            </p><p>
The <code class="literal">Run</code> method actually generates the table data for the stats. It gets the attributes for this stats passed. In this sample in <code class="literal">%Param</code> a key <code class="literal">TypeIDs</code> and a key <code class="literal">QueueIDs</code> exist (see attributes in <code class="literal">Param</code> method) and their values are array references. The returned data consists of three parts: Two array references and an array. In the first array reference the title for the statistic is stored, the second array reference contains the headlines for the columns in the table. And then the data for the table body follow.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Static/StaticStatsTemplate.pm
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Stats::Static::StaticStatsTemplate;

use strict;
use warnings;

use Kernel::System::Type;
use Kernel::System::Ticket;
use Kernel::System::Queue;

=head1 NAME

StaticStatsTemplate.pm - the module that creates the stats about tickets in a queue

=head1 SYNOPSIS

All functions

=head1 PUBLIC INTERFACE

=over 4

=cut

=item new()

create an object

    use Kernel::Config;
    use Kernel::System::Encode;
    use Kernel::System::Log;
    use Kernel::System::Main;
    use Kernel::System::Time;
    use Kernel::System::DB;
    use Kernel::System::Stats::Static::StaticStatsTemplate;

    my $ConfigObject = Kernel::Config-&gt;new();
    my $EncodeObject = Kernel::System::Encode-&gt;new(
        ConfigObject =&gt; $ConfigObject,
    );
    my $LogObject    = Kernel::System::Log-&gt;new(
        ConfigObject =&gt; $ConfigObject,
    );
    my $MainObject = Kernel::System::Main-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
    );
    my $TimeObject = Kernel::System::Time-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
    );
    my $DBObject = Kernel::System::DB-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
        MainObject   =&gt; $MainObject,
    );
    my $StatsObject = Kernel::System::Stats::Static::StaticStatsTemplate-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
        MainObject   =&gt; $MainObject,
        TimeObject   =&gt; $TimeObject,
        DBObject     =&gt; $DBObject,
        EncodeObject =&gt; $EncodeObject,
    );

=cut

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # check all needed objects
    for my $Needed (
        qw(DBObject ConfigObject LogObject
        TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Needed} = $Param{$Needed} || die "Got no $Needed";
    }

    # create needed objects
    $Self-&gt;{TypeObject}   = Kernel::System::Type-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject} = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{QueueObject}  = Kernel::System::Queue-&gt;new( %{$Self} );

    return $Self;
}

=item Param()

Get all parameters a user can specify.

    my @Params = $StatsObject-&gt;Param();

=cut

sub Param {
    my $Self = shift;

    my %Queues = $Self-&gt;{QueueObject}-&gt;GetAllQueues();
    my %Types  = $Self-&gt;{TypeObject}-&gt;TypeList(
        Valid =&gt; 1,
    );

    my @Params = (
        {
            Frontend  =&gt; 'Type',
            Name      =&gt; 'TypeIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Types,
        },
        {
            Frontend  =&gt; 'Queue',
            Name      =&gt; 'QueueIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Queues,
        },
    );

    return @Params;
}

=item Run()

generate the statistic.

    my $StatsInfo = $StatsObject-&gt;Run(
        TypeIDs  =&gt; [
            1, 2, 4
        ],
        QueueIDs =&gt; [
            3, 4, 6
        ],
    );

=cut

sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Needed (qw(TypeIDs QueueIDs)) {
        if ( !$Param{$Needed} ) {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Need $Needed!",
            );
            return;
        }
    }

    # set report title
    my $Title = 'Tickets per Queue';

    # table headlines
    my @HeadData = (
        'Ticket Number',
        'Queue',
        'Type',
    );

    my @Data;
    my @TicketIDs = $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'ARRAY',
        Permission =&gt; 'ro',
        %Param,
    );

    for my $TicketID ( @TicketIDs ) {
        my %Ticket = $Self-&gt;{TicketObject}-&gt;TicketGet(
            UserID =&gt; 1,
            TicketID =&gt; $TicketID,
        );
        push @Data, [ $Ticket{TicketNumber}, $Ticket{Queue}, $Ticket{Type} ];
    }

    return ( [$Title], [@HeadData], @Data );
}

1;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-configuration"></a>Configuration example</h6></div></div></div><p>
There is no configuration needed. Right after installation, the module is available to create a statistic for this module.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-use_cases"></a>Use case examples</h6></div></div></div><p>
Use cases.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
Caveats and Warnings for static stats.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-releases"></a>Release Availability</h6></div></div></div><p>
Static stat modules are available since OTRS 1.3.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-using-old-stats"></a>Using old static stats</h6></div></div></div><p>
Standard OTRS versions 1.3 and 2.0 already facilitated the generation of stats.
Various stats for OTRS versions 1.3 and 2.0 which have been specially
developed to meet customers' requirements can be used in more recent versions too.
            </p><p>
The files must merely be moved from the
<code class="filename">Kernel/System/Stats/</code> path to
<code class="filename">Kernel/System/Stats/Static/</code>. Additionally
the package name of the respective script must be amended by
<code class="literal">::Static</code>.
            </p><p>
The following example shows how the first path is amended.
            </p><p>
                </p><pre class="programlisting">
    package Kernel::System::Stats::AccountedTime;
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
    package Kernel::System::Stats::Static::AccountedTime;
                </pre><p>
            </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ticketnumber-generator"></a>Ticket Number Generator Modules</h4></div></div></div><p>
        Ticket number generators are used to create distinct identifiers aka ticket number for
        new tickets.
        Any method of creating a string of numbers is possible, you should use common sense about
        the length of the resulting string (guideline: 5-10).
    </p><p>
        When creating a ticket number, make sure the result is prefixed by the SysConfig variable
        <code class="literal">SystemID</code> in order to enable the detection of ticket numbers on inbound email responses.
        A ticket number generator module needs the two functions <code class="code">TicketCreateNumber()</code> and
        <code class="code">GetTNByString()</code>.
    </p><p>
        The method <code class="code">TicketCreateNumber()</code> is called without parameters and returns the new ticket
        number.
    </p><p>
        The method <code class="code">GetTNByString()</code> is called with the param String which contains the string to be
        parsed for a ticket number and returns the ticket number if found.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-code"></a>Code example</h5></div></div></div><p>
            See <code class="filename">Kernel/System/Ticket/Number/UserRandom.pm</code> in the package <code class="literal">TemplateModule</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-configuration"></a>Configuration example</h5></div></div></div><p>
            See <code class="filename">Kernel/Config/Files/TicketNumberGenerator.xml</code> in the package <code class="literal">TemplateModule</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-usecases"></a>Use Cases</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="ticketnumber-generator-usecase-10"></a>Ticket numbers should follow a specific scheme.</h6></div></div></div><p>
                You will need to create a new ticket number generator if the default modules don't
                provide the ticket number scheme you'd like to use.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
            You should stick to the code of <code class="code">GetTNByString()</code> as used in existing ticket number
            generators to prevent problems with ticket number parsing.
            Also the routine to detect a loop in <code class="code">TicketCreateNumber()</code> should be kept intact to
            prevent duplicate ticket numbers.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-releases"></a>Release Availability</h5></div></div></div><p>
            Ticket number generators have been available in OTRS since OTRS 1.1.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ticketevent"></a>Ticket Event Module</h4></div></div></div><p>
        Ticket event modules are running right after a ticket action takes place.
        Per convention these modules are located in the directory <code class="filename">Kernel/System/Ticket/Event</code>.
        A ticket event module needs only two functions: <code class="code">new()</code> and <code class="code">Run()</code>.
        The method <code class="code">Run()</code> receives at least the parameters <code class="literal">Event</code>, <code class="literal">UserID</code> and <code class="literal">Data</code>.
        <code class="literal">Data</code> is a hash ref containing data of the ticket, and in case of Article-related events also
        containing Article data.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-code"></a>Code example</h5></div></div></div><p>
            See <code class="filename">Kernel/System/Ticket/Event/EventModulePostTemplate.pm</code> in the package <code class="literal">TemplateModule</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-configuration"></a>Configuration example</h5></div></div></div><p>
            See <code class="filename">Kernel/Config/Files/EventModulePostTemplate.xml</code> in the package <code class="literal">TemplateModule</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-usecases"></a>Use Cases</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-10"></a>A ticket should be unlocked after a move action.</h6></div></div></div><p>
                This standard feature has been implemented with the ticket event module
                <code class="literal">Kernel::System::Ticket::Event::ForceUnlock</code>.
                When this feature is not wanted, then it can be turned off by
                unsetting the SysConfig entry <code class="literal">Ticket::EventModulePost###910-ForceUnlockOnMove</code>.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-20"></a>Perform extra cleanup action when a ticket is deleted.</h6></div></div></div><p>
                A customized OTRS might hold non-standard data in additional database tables.
                When a ticket is deleted then this additional data needs to be deleted.
                This functionality can be achieved with a ticket event module listening to <code class="literal">TicketDelete</code> events.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-30"></a>New tickets should be twittered.</h6></div></div></div><p>
                A ticket event module listening to <code class="literal">TicketCreate</code> can send out tweets.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
            No caveats are known.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-releases"></a>Release Availability</h5></div></div></div><p>
            Ticket events have been available in OTRS since OTRS 2.0.
        </p><p>
            Ticket events available in OTRS 6.0:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>TicketCreate</p></li><li class="listitem"><p>TicketDelete</p></li><li class="listitem"><p>TicketTitleUpdate</p></li><li class="listitem"><p>TicketUnlockTimeoutUpdate</p></li><li class="listitem"><p>TicketQueueUpdate</p></li><li class="listitem"><p>TicketTypeUpdate</p></li><li class="listitem"><p>TicketServiceUpdate</p></li><li class="listitem"><p>TicketSLAUpdate</p></li><li class="listitem"><p>TicketCustomerUpdate</p></li><li class="listitem"><p>TicketPendingTimeUpdate</p></li><li class="listitem"><p>TicketLockUpdate</p></li><li class="listitem"><p>TicketArchiveFlagUpdate</p></li><li class="listitem"><p>TicketStateUpdate</p></li><li class="listitem"><p>TicketOwnerUpdate</p></li><li class="listitem"><p>TicketResponsibleUpdate</p></li><li class="listitem"><p>TicketPriorityUpdate</p></li><li class="listitem"><p>HistoryAdd</p></li><li class="listitem"><p>HistoryDelete</p></li><li class="listitem"><p>TicketAccountTime</p></li><li class="listitem"><p>TicketMerge</p></li><li class="listitem"><p>TicketSubscribe</p></li><li class="listitem"><p>TicketUnsubscribe</p></li><li class="listitem"><p>TicketFlagSet</p></li><li class="listitem"><p>TicketFlagDelete</p></li><li class="listitem"><p>EscalationResponseTimeNotifyBefore</p></li><li class="listitem"><p>EscalationUpdateTimeNotifyBefore</p></li><li class="listitem"><p>EscalationSolutionTimeNotifyBefore</p></li><li class="listitem"><p>EscalationResponseTimeStart</p></li><li class="listitem"><p>EscalationUpdateTimeStart</p></li><li class="listitem"><p>EscalationSolutionTimeStart</p></li><li class="listitem"><p>EscalationResponseTimeStop</p></li><li class="listitem"><p>EscalationUpdateTimeStop</p></li><li class="listitem"><p>EscalationSolutionTimeStop</p></li><li class="listitem"><p>NotificationNewTicket</p></li><li class="listitem"><p>NotificationFollowUp</p></li><li class="listitem"><p>NotificationLockTimeout</p></li><li class="listitem"><p>NotificationOwnerUpdate</p></li><li class="listitem"><p>NotificationResponsibleUpdate</p></li><li class="listitem"><p>NotificationAddNote</p></li><li class="listitem"><p>NotificationMove</p></li><li class="listitem"><p>NotificationPendingReminder</p></li><li class="listitem"><p>NotificationEscalation</p></li><li class="listitem"><p>NotificationEscalationNotifyBefore</p></li><li class="listitem"><p>NotificationServiceUpdate</p></li></ul></div><p>
        </p><p>
            Article events available in OTRS 6.0:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>ArticleCreate</p></li><li class="listitem"><p>ArticleUpdate</p></li><li class="listitem"><p>ArticleSend</p></li><li class="listitem"><p>ArticleBounce</p></li><li class="listitem"><p>ArticleAgentNotification</p></li><li class="listitem"><p>ArticleCustomerNotification</p></li><li class="listitem"><p>ArticleAutoResponse</p></li><li class="listitem"><p>ArticleFlagSet</p></li><li class="listitem"><p>ArticleFlagDelete</p></li><li class="listitem"><p>ArticleAgentNotification</p></li><li class="listitem"><p>ArticleCustomerNotification</p></li></ul></div><p>
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="frontend-modules"></a>Frontend Modules</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="module-dashboard"></a>Dashboard Module</h4></div></div></div><p>
Dashboard module to display statistics in the form of a line graph.
        </p><p>
            </p><div class="figure"><a name="id-1.4.3.6.2.3.1"></a><p class="title"><b>Figure 3.1. Dashboard Widget</b></p><div class="figure-contents"><div class="screenshot"><div><img src="screenshots/dashboard.png" alt="Dashboard Widget"></div></div></div></div><p><br class="figure-break">
        </p><p>
            </p><pre class="programlisting">
# --
# Kernel/Output/HTML/DashboardTicketStatsGeneric.pm - message of the day
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::Output::HTML::DashboardTicketStatsGeneric;

use strict;
use warnings;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # get needed objects
    for (
        qw(Config Name ConfigObject LogObject DBObject LayoutObject ParamObject TicketObject UserID)
        )
    {
        die "Got no $_!" if !$Self-&gt;{$_};
    }

    return $Self;
}

sub Preferences {
    my ( $Self, %Param ) = @_;

    return;
}

sub Config {
    my ( $Self, %Param ) = @_;

    my $Key = $Self-&gt;{LayoutObject}-&gt;{UserLanguage} . '-' . $Self-&gt;{Name};
    return (
        %{ $Self-&gt;{Config} },
        CacheKey =&gt; 'TicketStats' . '-' . $Self-&gt;{UserID} . '-' . $Key,
    );

}

sub Run {
    my ( $Self, %Param ) = @_;

    my %Axis = (
        '7Day' =&gt; {
            0 =&gt; { Day =&gt; 'Sun', Created =&gt; 0, Closed =&gt; 0, },
            1 =&gt; { Day =&gt; 'Mon', Created =&gt; 0, Closed =&gt; 0, },
            2 =&gt; { Day =&gt; 'Tue', Created =&gt; 0, Closed =&gt; 0, },
            3 =&gt; { Day =&gt; 'Wed', Created =&gt; 0, Closed =&gt; 0, },
            4 =&gt; { Day =&gt; 'Thu', Created =&gt; 0, Closed =&gt; 0, },
            5 =&gt; { Day =&gt; 'Fri', Created =&gt; 0, Closed =&gt; 0, },
            6 =&gt; { Day =&gt; 'Sat', Created =&gt; 0, Closed =&gt; 0, },
        },
    );

    my @Data;
    my $Max = 1;
    for my $Key ( 0 .. 6 ) {

        my $TimeNow = $Self-&gt;{TimeObject}-&gt;SystemTime();
        if ($Key) {
            $TimeNow = $TimeNow - ( 60 * 60 * 24 * $Key );
        }
        my ( $Sec, $Min, $Hour, $Day, $Month, $Year, $WeekDay )
            = $Self-&gt;{TimeObject}-&gt;SystemTime2Date(
            SystemTime =&gt; $TimeNow,
            );

        $Data[$Key]-&gt;{Day} = $Self-&gt;{LayoutObject}-&gt;{LanguageObject}-&gt;Get(
            $Axis{'7Day'}-&gt;{$WeekDay}-&gt;{Day}
        );

        my $CountCreated = $Self-&gt;{TicketObject}-&gt;TicketSearch(

            # cache search result 20 min
            CacheTTL =&gt; 60 * 20,

            # tickets with create time after ... (ticket newer than this date) (optional)
            TicketCreateTimeNewerDate =&gt; "$Year-$Month-$Day 00:00:00",

            # tickets with created time before ... (ticket older than this date) (optional)
            TicketCreateTimeOlderDate =&gt; "$Year-$Month-$Day 23:59:59",

            CustomerID =&gt; $Param{Data}-&gt;{UserCustomerID},
            Result     =&gt; 'COUNT',

            # search with user permissions
            Permission =&gt; $Self-&gt;{Config}-&gt;{Permission} || 'ro',
            UserID =&gt; $Self-&gt;{UserID},
        );
        $Data[$Key]-&gt;{Created} = $CountCreated;
        if ( $CountCreated &gt; $Max ) {
            $Max = $CountCreated;
        }

        my $CountClosed = $Self-&gt;{TicketObject}-&gt;TicketSearch(

            # cache search result 20 min
            CacheTTL =&gt; 60 * 20,

            # tickets with create time after ... (ticket newer than this date) (optional)
            TicketCloseTimeNewerDate =&gt; "$Year-$Month-$Day 00:00:00",

            # tickets with created time before ... (ticket older than this date) (optional)
            TicketCloseTimeOlderDate =&gt; "$Year-$Month-$Day 23:59:59",

            CustomerID =&gt; $Param{Data}-&gt;{UserCustomerID},
            Result     =&gt; 'COUNT',

            # search with user permissions
            Permission =&gt; $Self-&gt;{Config}-&gt;{Permission} || 'ro',
            UserID =&gt; $Self-&gt;{UserID},
        );
        $Data[$Key]-&gt;{Closed} = $CountClosed;
        if ( $CountClosed &gt; $Max ) {
            $Max = $CountClosed;
        }
    }

    @Data = reverse @Data;
    my $Source = $Self-&gt;{LayoutObject}-&gt;JSONEncode(
        Data =&gt; \@Data,
    );

    my $Content = $Self-&gt;{LayoutObject}-&gt;Output(
        TemplateFile =&gt; 'AgentDashboardTicketStats',
        Data         =&gt; {
            %{ $Self-&gt;{Config} },
            Key    =&gt; int rand 99999,
            Max    =&gt; $Max,
            Source =&gt; $Source,
        },
    );

    return $Content;
}

1;
            </pre><p>
        </p><p>
To use this module add the following to the <code class="filename">Kernel/Config.pm</code>
and restart your web server (if you use <code class="literal">mod_perl</code>).
        </p><p>
            </p><pre class="programlisting">
&lt;ConfigItem Name="DashboardBackend###0250-TicketStats" Required="0" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Parameters for the dashboard backend. "Group" are used to restricted access to the plugin (e. g. Group: admin;group1;group2;). "Default" means if the plugin is enabled per default or if the user needs to enable it manually. "CacheTTL" means the cache time in minutes for the plugin.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Parameter für das Dashboard Backend. "Group" ist verwendet um den Zugriff auf das Plugin einzuschränken (z. B. Group: admin;group1;group2;). ""Default" bedeutet ob das Plugin per default aktiviert ist oder ob dies der Anwender manuell machen muss. "CacheTTL" ist die Cache-Zeit in Minuten nach der das Plugin erneut aufgerufen wird.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::Dashboard&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::DashboardTicketStatsGeneric&lt;/Item&gt;
            &lt;Item Key="Title"&gt;7 Day Stats&lt;/Item&gt;
            &lt;Item Key="Created"&gt;1&lt;/Item&gt;
            &lt;Item Key="Closed"&gt;1&lt;/Item&gt;
            &lt;Item Key="Permission"&gt;rw&lt;/Item&gt;
            &lt;Item Key="Block"&gt;ContentSmall&lt;/Item&gt;
            &lt;Item Key="Group"&gt;&lt;/Item&gt;
            &lt;Item Key="Default"&gt;1&lt;/Item&gt;
            &lt;Item Key="CacheTTL"&gt;45&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
            </pre><p>
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dashboard-module-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
An excessive number of days or individual lines may lead to performance degradation.
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dashboard-module-releases"></a>Release Availability</h5></div></div></div><p>
From version 2.4.0.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="notify-module"></a>Notification Module</h4></div></div></div><p>
        Notification modules are used to display a notification below the
        main navigation. You can write and register your own notification
        module.
        There are currently 5 ticket menus in the OTRS framework.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">AgentOnline</code></p></li><li class="listitem"><p><code class="literal">AgentTicketEscalation</code></p></li><li class="listitem"><p><code class="literal">CharsetCheck</code></p></li><li class="listitem"><p><code class="literal">CustomerOnline</code></p></li><li class="listitem"><p><code class="literal">UIDCheck</code></p></li></ul></div><p>
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-code"></a>Code Example</h5></div></div></div><p>
            The notification modules are located under
            <code class="filename">Kernel/Output/HTML/TicketNotification*.pm</code>.
            Following, there is an example of a notify module.
            Save it under <code class="filename">Kernel/Output/HTML/TicketNotificationCustom.pm</code>.
            You just need 2 functions: <code class="code">new()</code> and <code class="code">Run()</code>.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/NotificationCustom.pm
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::Output::HTML::NotificationCustom;

use strict;
use warnings;

use Kernel::System::Custom;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for my $Object (qw(ConfigObject LogObject DBObject LayoutObject TimeObject UserID)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }
    $Self-&gt;{CustomObject} = Kernel::System::Custom-&gt;new(%Param);
    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;

    # get session info
    my %CustomParam      = ();
    my @Customs    = $Self-&gt;{CustomObject}-&gt;GetAllCustomIDs();
    my $IdleMinutes = $Param{Config}-&gt;{IdleMinutes} || 60 * 2;
    for (@Customs) {
        my %Data = $Self-&gt;{CustomObject}-&gt;GetCustomIDData( CustomID =&gt; $_, );
        if (
            $Self-&gt;{UserID} ne $Data{UserID}
            &amp;&amp; $Data{UserType} eq 'User'
            &amp;&amp; $Data{UserLastRequest}
            &amp;&amp; $Data{UserLastRequest} + ( $IdleMinutes * 60 ) &gt; $Self-&gt;{TimeObject}-&gt;SystemTime()
            &amp;&amp; $Data{UserFirstname}
            &amp;&amp; $Data{UserLastname}
            )
        {
            $CustomParam{ $Data{UserID} } = "$Data{UserFirstname} $Data{UserLastname}";
            if ( $Param{Config}-&gt;{ShowEmail} ) {
                $CustomParam{ $Data{UserID} } .= " ($Data{UserEmail})";
            }
        }
    }
    for ( sort { $CustomParam{$a} cmp $CustomParam{$b} } keys %CustomParam ) {
        if ( $Param{Message} ) {
            $Param{Message} .= ', ';
        }
        $Param{Message} .= "$CustomParam{$_}";
    }
    if ( $Param{Message} ) {
        return $Self-&gt;{LayoutObject}-&gt;Notify( Info =&gt; 'Custom Message: %s", "' . $Param{Message} );
    }
    else {
        return '';
    }
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom notification module.
            This can be done using the XML configuration below. There may
            be additional parameters in the config hash for your notification
            module.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Frontend::NotifyModule###3-Custom" Required="0" Valid="0"&gt;
    &lt;Description Lang="en"&gt;Module to show custom message in the agent interface.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Mit diesem Modul können eigene Meldungenen innerhalb des Agent-Interfaces angezeigt werden.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::ModuleNotify&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::NotificationCustom&lt;/Item&gt;
            &lt;Item Key="Key1"&gt;1&lt;/Item&gt;
            &lt;Item Key="Key2"&gt;2&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful ticket menu implementation could be a link to an external
            tool if parameters (e.g. <code class="literal">FreeTextField</code>) have been set.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>NotificationAgentOnline</td><td>2.0</td></tr><tr><td>NotificationAgentTicketEscalation</td><td>2.0</td></tr><tr><td>NotificationCharsetCheck</td><td>1.2</td></tr><tr><td>NotificationCustomerOnline</td><td>2.0</td></tr><tr><td>NotificationUIDCheck</td><td>1.2</td></tr></tbody></table></div><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ticket-menu-module"></a>Ticket Menu Module</h4></div></div></div><p>
        Ticket menu modules are used to display an additional link in the
        menu above a ticket. You can write and register your own ticket
        menu module.
        There are 4 ticket menus (Generic, Lock, Responsible and
        TicketWatcher) which come with the OTRS framework. For
        more information please have a look at the OTRS admin manual.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-code"></a>Code Example</h5></div></div></div><p>
            The ticket menu modules are located under
            <code class="filename">Kernel/Output/HTML/TicketMenu*.pm</code>.
            Following, there is an example of a ticket menu module.
            Save it under <code class="filename">Kernel/Output/HTML/TicketMenuCustom.pm</code>.
            You just need 2 functions: <code class="code">new()</code> and <code class="code">Run()</code>.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/TicketMenuCustom.pm
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# Id: TicketMenuCustom.pm,v 1.17 2010/04/12 21:34:06 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::Output::HTML::TicketMenuCustom;

use strict;
use warnings;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for my $Object (qw(ConfigObject LogObject DBObject LayoutObject UserID TicketObject)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{Ticket} ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'error',
            Message  =&gt; 'Need Ticket!'
        );
        return;
    }

    # check if frontend module registered, if not, do not show action
    if ( $Param{Config}-&gt;{Action} ) {
        my $Module = $Self-&gt;{ConfigObject}-&gt;Get('Frontend::Module')-&gt;{ $Param{Config}-&gt;{Action} };
        return if !$Module;
    }

    # check permission
    my $AccessOk = $Self-&gt;{TicketObject}-&gt;Permission(
        Type     =&gt; 'rw',
        TicketID =&gt; $Param{Ticket}-&gt;{TicketID},
        UserID   =&gt; $Self-&gt;{UserID},
        LogNo    =&gt; 1,
    );
    return if !$AccessOk;

    # check permission
    if ( $Self-&gt;{TicketObject}-&gt;CustomIsTicketCustom( TicketID =&gt; $Param{Ticket}-&gt;{TicketID} ) ) {
        my $AccessOk = $Self-&gt;{TicketObject}-&gt;OwnerCheck(
            TicketID =&gt; $Param{Ticket}-&gt;{TicketID},
            OwnerID  =&gt; $Self-&gt;{UserID},
        );
        return if !$AccessOk;
    }

    # check acl
    return
        if defined $Param{ACL}-&gt;{ $Param{Config}-&gt;{Action} }
            &amp;&amp; !$Param{ACL}-&gt;{ $Param{Config}-&gt;{Action} };

    # if ticket is customized
    if ( $Param{Ticket}-&gt;{Custom} eq 'lock' ) {

        # if it is locked for somebody else
        return if $Param{Ticket}-&gt;{OwnerID} ne $Self-&gt;{UserID};

        # show custom action
        return {
            %{ $Param{Config} },
            %{ $Param{Ticket} },
            %Param,
            Name        =&gt; 'Custom',
            Description =&gt; 'Custom to give it back to the queue!',
            Link        =&gt; 'Action=AgentTicketCustom;Subaction=Custom;TicketID=$QData{"TicketID"}',
        };
    }

    # if ticket is customized
    return {
        %{ $Param{Config} },
        %{ $Param{Ticket} },
        %Param,
        Name        =&gt; 'Custom',
        Description =&gt; 'Custom it to work on it!',
        Link        =&gt; 'Action=AgentTicketCustom;Subaction=Custom;TicketID=$QData{"TicketID"}',
    };
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom ticket menu module.
            This can be done using the XML configuration below. There may
            be additional parameters in the config hash for your ticket menu
            module.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Ticket::Frontend::MenuModule###110-Custom" Required="0" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Module to show custom link in menu.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Mit diesem Modul wird der Custom-Link in der Linkleiste der Ticketansicht angezeigt.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::Ticket::MenuModule&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::TicketMenuCustom&lt;/Item&gt;
            &lt;Item Key="Name"&gt;Custom&lt;/Item&gt;
            &lt;Item Key="Action"&gt;AgentTicketCustom&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful ticket menu implementation could be a link to a external
            tool if parameters (e.g. <code class="literal">FreeTextField</code>) have been set.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
                The ticket menu directs to an URL that can be handled.
                If you want to handle that request via the OTRS framework,
                you have to write your own frontend module.
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>TicketMenuGeneric</td><td>2.0</td></tr><tr><td>TicketMenuLock</td><td>2.0</td></tr><tr><td>TicketMenuResponsible</td><td>2.1</td></tr><tr><td>TicketMenuTicketWatcher</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="genericinterface-modules"></a>Generic Interface Modules</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="transport"></a>Network Transport</h4></div></div></div><p>
        The network transport is used as method to send and receive information between OTRS and a
        Remote System. The Generic Interface configuration allows a web service to use different
        network transport modules for provider and requester, but the most common scenario is that
        the same transport module is used for both.
    </p><p>
        <span class="emphasis"><em>OTRS as provider:</em></span>
    </p><p>
        OTRS uses the network transport modules to get the data from the Remote System and the
        operation to be executed. After the operation is performed OTRS uses them again to send the
        response back to the Remote System.
    </p><p>
        <span class="emphasis"><em>OTRS as requester:</em></span>
    </p><p>
        OTRS uses the network transport modules to send petitions to the Remote System to perform a
        remote action along with the required data. OTRS waits for the Remote System response and
        send it back to the Requester module.
    </p><p>
        In both ways network transport modules deal with the data in the Remote System format. It
        is not recommended to do any data transformation in this modules, as the Mapping layer is the
        responsible to perform any data transformation needed during the communication. An exception
        of this is the data conversion that is required specifically by for the transport e.g. XML
        or JSON from / to Perl conversions.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="adding_transport"></a>Transport backend</h5></div></div></div><p>
            Next we will show how to develop a new transport backend. Each transport backend has to
            implement these subroutines:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">ProviderProcessRequest</code></p></li><li class="listitem"><p><code class="literal">ProviderGenerateResponse</code></p></li><li class="listitem"><p><code class="literal">RequesterPerformRequest</code></p></li></ul></div><p>
        </p><p>
            We should implement each one of this methods in order to be able to communicate
            correctly with a Remote System in both ways. All network transport backends are
            handled by the transport module (<code class="filename">Kernel/GenericInterface/Transport.pm</code>).
        </p><p>
            Currently Generic Interface implements the HTTP SOAP and HTTP REST transports. If the
            planned web service can use HTTP SOAP or HTTP SOAP there is no need to create a new
            network transport module, instead we recommend to take a look into HTTP SOAP or HTTP
            REST configurations to check their settings and how it can be tuned according to the
            remote system.
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="transport_code_example"></a>Code example</h6></div></div></div><p>
                In case that the provided network transports does not match the web service needs,
                then in this section a sample network transport module is shown and each subroutine
                is explained. Normally transport modules uses CPAN modules as backends. For example
                the HTTP SOAP transport modules uses <code class="literal">SOAP::Lite</code> module as backend.
            </p><p>
                For this example a custom package is used to return the data without doing a real
                network request to a Remote System, instead this custom module acts as a loop-back
                interface.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Transport/HTTP/Test.pm - GenericInterface network transport interface for testing
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::GenericInterface::Transport::HTTP::Test;

use strict;
use warnings;

use HTTP::Request::Common;
use LWP::UserAgent;
use LWP::Protocol;

# prevent 'Used once' warning for Kernel::OM
use Kernel::System::ObjectManager;

our $ObjectManagerDisabled = 1;
                </pre><p>
            </p><p>
                This is common header that can be found in common OTRS modules. The class/package
                name is declared via the <code class="literal">package</code> keyword. Transports can not be instantiated by the Object Manager.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {};
    bless( $Self, $Type );

    for my $Needed (qw( DebuggerObject TransportConfig)) {
        $Self-&gt;{$Needed} = $Param{$Needed} || return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "Got no $Needed!"
        };
    }

    return $Self;
}

                </pre><p>
            </p><p>
                The constructor <code class="literal">new</code> creates a new instance of the class. According to the coding
                guidelines only objects of other classes not handled by the object manager that are
                needed in this module have to be created in <code class="literal">new</code>.
            </p><p>
                </p><pre class="programlisting">
sub ProviderProcessRequest {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{TransportConfig}-&gt;{Config}-&gt;{Fail} ) {

        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "HTTP status code: 500",
            Data         =&gt; {},
        };
    }

    my $ParamObject = $Kernel::OM-&gt;Get('Kernel::System::Web::Request');

    my %Result;
    for my $ParamName ( $ParamObject-&gt;GetParamNames() ) {
        $Result{$ParamName} = $ParamObject-&gt;GetParam( Param =&gt; $ParamName );
    }

    # special handling for empty post request
    if ( scalar keys %Result == 1 &amp;&amp; exists $Result{POSTDATA} &amp;&amp; !$Result{POSTDATA} ) {
        %Result = ();
    }

    if ( !%Result ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'No request data found.',
        );
    }

    return {
        Success   =&gt; 1,
        Data      =&gt; \%Result,
        Operation =&gt; 'test_operation',
    };
}
                </pre><p>
            </p><p>
                The <code class="literal">ProviderProcessRequest</code> function gets the request from the Remote System (in
                this case the same OTRS) and extracts the data and the operation to perform from
                the request. For this example the operation is always <code class="literal">test_operation</code>.
            </p><p>
                The way this function parses the request to get the data and the operation name,
                depends completely on the protocol to be implemented and the external modules that
                are used for.
            </p><p>
                </p><pre class="programlisting">
sub ProviderGenerateResponse {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{TransportConfig}-&gt;{Config}-&gt;{Fail} ) {

        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; 'Test response generation failed',
        };
    }

    my $Response;

    if ( !$Param{Success} ) {
        $Response
            = HTTP::Response-&gt;new( 500 =&gt; ( $Param{ErrorMessage} || 'Internal Server Error' ) );
        $Response-&gt;protocol('HTTP/1.0');
        $Response-&gt;content_type("text/plain; charset=UTF-8");
        $Response-&gt;date(time);
    }
    else {

        # generate a request string from the data
        my $Request
            = HTTP::Request::Common::POST( 'http://testhost.local/', Content =&gt; $Param{Data} );

        $Response = HTTP::Response-&gt;new( 200 =&gt; "OK" );
        $Response-&gt;protocol('HTTP/1.0');
        $Response-&gt;content_type("text/plain; charset=UTF-8");
        $Response-&gt;add_content_utf8( $Request-&gt;content() );
        $Response-&gt;date(time);
    }

    $Self-&gt;{DebuggerObject}-&gt;Debug(
        Summary =&gt; 'Sending HTTP response',
        Data    =&gt; $Response-&gt;as_string(),
    );

    # now send response to client
    print STDOUT $Response-&gt;as_string();

    return {
        Success =&gt; 1,
    };
}
                </pre><p>
            </p><p>
                This function sends the response back to the Remote System for the requested
                operation.
            </p><p>
                For this particular example we return a standard HTTP response success (200) or
                not (500), along with the required data on each case.
            </p><p>
                </p><pre class="programlisting">
sub RequesterPerformRequest {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{TransportConfig}-&gt;{Config}-&gt;{Fail} ) {

        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "HTTP status code: 500",
            Data         =&gt; {},
        };
    }

    # use custom protocol handler to avoid sending out real network requests
    LWP::Protocol::implementor(
        testhttp =&gt; 'Kernel::GenericInterface::Transport::HTTP::Test::CustomHTTPProtocol'
    );
    my $UserAgent = LWP::UserAgent-&gt;new();
    my $Response = $UserAgent-&gt;post( 'testhttp://localhost.local/', Content =&gt; $Param{Data} );

    return {
        Success =&gt; 1,
        Data    =&gt; {
            ResponseContent =&gt; $Response-&gt;content(),
        },
    };
}
                </pre><p>
            </p><p>
                This is the only function that is used by OTRS as requester. It sends the request
                to the Remote System and waits for its response.
            </p><p>
                For this example we use a custom protocol handler to avoid send the request to the
                real network. This custom protocol is specified below.
            </p><p>
                </p><pre class="programlisting">
package Kernel::GenericInterface::Transport::HTTP::Test::CustomHTTPProtocol;

use base qw(LWP::Protocol);

sub new {
    my $Class = shift;

    return $Class-&gt;SUPER::new(@_);
}

sub request {    ## no critic
    my $Self = shift;

    my ( $Request, $Proxy, $Arg, $Size, $Timeout ) = @_;

    my $Response = HTTP::Response-&gt;new( 200 =&gt; "OK" );
    $Response-&gt;protocol('HTTP/1.0');
    $Response-&gt;content_type("text/plain; charset=UTF-8");
    $Response-&gt;add_content_utf8( $Request-&gt;content() );
    $Response-&gt;date(time);

    #print $Request-&gt;as_string();
    #print $Response-&gt;as_string();

    return $Response;
}

                </pre><p>
            </p><p>
                This is the code for the custom protocol that we use. This approach is only useful
                for training or for testing environments where the Remote Systems are not available.
            </p><p>
                For a new module development we do not recommend to use this approach, a real
                protocol needs to be implemented.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="transport-configuration"></a>Configuration Example</h6></div></div></div><p>
                There is the need to register this network transport module to be accessible in the
                OTRS GUI. This can be done using the XML configuration below.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Transport::Module###HTTP::Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the transport layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Transport::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Name"&gt;Test&lt;/Item&gt;
            &lt;Item Key="Protocol"&gt;HTTP&lt;/Item&gt;
            &lt;Item Key="ConfigDialog"&gt;AdminGenericInterfaceTransportHTTPTest&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mapping"></a>Mapping</h4></div></div></div><p>
        The mapping is used to convert data from OTRS to the external systems, and vice versa.
        This data can be represented as key =&gt; value pairs. Mapping modules can be developed to
        transform not just values but also the keys.
    </p><p>
        <span class="emphasis"><em>For example:</em></span>
    </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>From</th><th>To</th></tr></thead><tbody><tr><td>Prio =&gt; Warning</td><td>PriorityID =&gt; 3</td></tr></tbody></table></div><p>
        The mapping layer is not absolutely necessary, a web service can skip it completely
        depending on the web service configuration and how invokers and operation are implemented.
        But if some data transformations are needed, is highly recommended to use an existing
        mapping module or create a new one.
    </p><p>
        Mapping modules can be called more than one time during a normal communication, take a
        look to the following examples.
    </p><p>
        <span class="emphasis"><em>OTRS as provider example:</em></span>
    </p><p>
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    The remote system sends the request with the data in the remote system format
                </p></li><li class="listitem"><p>
                    The data is mapped from the remote system format to the OTRS format
                </p></li><li class="listitem"><p>
                    OTRS performs the operation and return the response in OTRS format
                </p></li><li class="listitem"><p>
                    The data is mapped from the OTRS format to the remote system format
                </p></li><li class="listitem"><p>
                    The response with the data in the remote system format is sent to the remote
                    system
                </p></li></ol></div><p>
    </p><p>
        <span class="emphasis"><em>OTRS as requester example:</em></span>
    </p><p>
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    OTRS prepares the request to the remote system using the data in the OTRS format
                </p></li><li class="listitem"><p>
                    The data is mapped from the OTRS format to the remote system format
                </p></li><li class="listitem"><p>
                    The request is sent to the remote system which performs the action and sends the
                    response back to OTRS with the data in remote system format
                </p></li><li class="listitem"><p>
                    The data is mapped form remote system format (again) to the OTRS format
                </p></li><li class="listitem"><p>
                    OTRS processes the response
                </p></li></ol></div><p>
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="adding_mapping"></a>Mapping backend</h5></div></div></div><p>
            Generic Interface provides a mapping module called <span class="emphasis"><em>Simple</em></span>.
            With this module most of the data transformations including key and value mapping
            can be done, and also it defines rules for to handling the default mappings for both
            keys and values.
        </p><p>
            So it is highly probable that you don't need to develop a custom mapping module.
            Please check <span class="emphasis"><em>Simple</em></span> mapping module (<code class="filename">Kernel/GenericInterface/Mapping/Simple.pm</code>)
            and its on-line documentation before continue.
        </p><p>
            If <span class="emphasis"><em>Simple</em></span> mapping module does not match your needs then we will show how to develop a
            new mapping backend. Each mapping backend has to implement these subroutines:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">Map</code></p></li></ul></div><p>
        </p><p>
            We should implement each one of this methods in order to be able to map the data in the
            communication, handled either by the requester or provider. All mapping backends are
            handled by the mapping module (<code class="filename">Kernel/GenericInterface/Mapping.pm</code>).
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="mapping_code_example"></a>Code example</h6></div></div></div><p>
                In this section a sample mapping module is shown and each subroutine is explained.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Mapping/Test.pm - GenericInterface test data mapping backend
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::GenericInterface::Mapping::Test;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(IsHashRefWithData IsStringWithData);

our $ObjectManagerDisabled = 1;
                </pre><p>
            </p><p>
                This is common header that can be found in common OTRS modules. The class/package
                name is declared via the <code class="literal">package</code> keyword.
            </p><p>
                We also include <code class="literal">VariableCheck</code> module to perform certain validation over some
                variables. Mappings can not be instantiated by the Object Manager.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed params
    for my $Needed (qw(DebuggerObject MappingConfig)) {
        if ( !$Param{$Needed} ) {

            return {
                Success      =&gt; 0,
                ErrorMessage =&gt; "Got no $Needed!"
            };
        }
        $Self-&gt;{$Needed} = $Param{$Needed};
    }

    # check mapping config
    if ( !IsHashRefWithData( $Param{MappingConfig} ) ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Got no MappingConfig as hash ref with content!',
        );
    }

    # check config - if we have a map config, it has to be a non-empty hash ref
    if (
        defined $Param{MappingConfig}-&gt;{Config}
        &amp;&amp; !IsHashRefWithData( $Param{MappingConfig}-&gt;{Config} )
        )
    {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Got MappingConfig with Data, but Data is no hash ref with content!',
        );
    }

    return $Self;
}
                </pre><p>
            </p><p>
                The constructor <code class="literal">new</code> creates a new instance of the class. According to the coding
                guidelines only objects of other classes not handled by the object manager that are
                needed in this module have to be created in <code class="literal">new</code>.
            </p><p>
                </p><pre class="programlisting">
sub Map {
    my ( $Self, %Param ) = @_;

    # check data - only accept undef or hash ref
    if ( defined $Param{Data} &amp;&amp; ref $Param{Data} ne 'HASH' ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Got Data but it is not a hash ref in Mapping Test backend!'
        );
    }

    # return if data is empty
    if ( !defined $Param{Data} || !%{ $Param{Data} } ) {

        return {
            Success =&gt; 1,
            Data    =&gt; {},
        };
    }

    # no config means that we just return input data
    if (
        !defined $Self-&gt;{MappingConfig}-&gt;{Config}
        || !defined $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption}
        )
    {

        return {
            Success =&gt; 1,
            Data    =&gt; $Param{Data},
        };
    }

    # check TestOption format
    if ( !IsStringWithData( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} ) ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Got no TestOption as string with value!',
        );
    }

    # parse data according to configuration
    my $ReturnData = {};
    if ( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} eq 'ToUpper' ) {
        $ReturnData = $Self-&gt;_ToUpper( Data =&gt; $Param{Data} );
    }
    elsif ( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} eq 'ToLower' ) {
        $ReturnData = $Self-&gt;_ToLower( Data =&gt; $Param{Data} );
    }
    elsif ( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} eq 'Empty' ) {
        $ReturnData = $Self-&gt;_Empty( Data =&gt; $Param{Data} );
    }
    else {
        $ReturnData = $Param{Data};
    }

    # return result
    return {
        Success =&gt; 1,
        Data    =&gt; $ReturnData,
    };
}
                </pre><p>
            </p><p>
                The <code class="literal">Map</code> function is the main part of each mapping module. It receives the mapping
                configuration (rules) and the data in the original format (either OTRS or remote
                system format) and converts it to a new format, even if the structure of the data can
                be changed during the mapping process.
            </p><p>
                In this particular example there are three rules to map the values. This rules are
                set in the mapping configuration key <code class="literal">TestOption</code> and they are <code class="literal">ToUpper</code>, <code class="literal">ToLower</code> and
                <code class="literal">Empty</code>.
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>
                        <code class="literal">ToUpper</code>: converts each data value to upper case.
                    </p></li><li class="listitem"><p>
                        <code class="literal">ToLower</code>: converts each data value to lower case.
                    </p></li><li class="listitem"><p>
                        <code class="literal">Empty</code>: converts each data value into an empty string.
                    </p></li></ul></div><p>
                In this example no data key transformations were implemented.
            </p><p>
                </p><pre class="programlisting">
sub _ToUpper {
    my ( $Self, %Param ) = @_;

    my $ReturnData = {};
    for my $Key ( sort keys %{ $Param{Data} } ) {
        $ReturnData-&gt;{$Key} = uc $Param{Data}-&gt;{$Key};
    }

    return $ReturnData;
}

sub _ToLower {
    my ( $Self, %Param ) = @_;

    my $ReturnData = {};
    for my $Key ( sort keys %{ $Param{Data} } ) {
        $ReturnData-&gt;{$Key} = lc $Param{Data}-&gt;{$Key};
    }

    return $ReturnData;
}

sub _Empty {
    my ( $Self, %Param ) = @_;

    my $ReturnData = {};
    for my $Key ( sort keys %{ $Param{Data} } ) {
        $ReturnData-&gt;{$Key} = '';
    }

    return $ReturnData;
}

                </pre><p>
            </p><p>
                This are the helper functions that actually performs the string conversions.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="mapping-configuration"></a>Configuration Example</h6></div></div></div><p>
                There is the need to register this mapping module to be accessible in the OTRS GUI.
                This can be done using the XML configuration below.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Mapping::Module###Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the mapping layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Mapping::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="ConfigDialog"&gt;&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="invoker"></a>Invoker</h4></div></div></div><p>
        The invoker is used to create a request from OTRS to a Remote System. This part of the GI
        is in charge of perform necessary tasks in OTRS side, to gather the necessary data in order
        to construct the request.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="adding_invoker"></a>Invoker backend</h5></div></div></div><p>
            Next we will show how to develop a new Invoker. Each invoker has to implement these
            subroutines:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">PrepareRequest</code></p></li><li class="listitem"><p><code class="literal">HandleResponse</code></p></li></ul></div><p>
        </p><p>
            We should implement each one of this methods in order to be able to execute a request
            using the request handler (<code class="filename">Kernel/GenericInterface/Requester.pm</code>).
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="invoker_code_example"></a>Code example</h6></div></div></div><p>
                In this section a sample invoker module is shown and each subroutine is explained.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Invoker/Test.pm - GenericInterface test data Invoker backend
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::GenericInterface::Invoker::Test::Test;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(IsString IsStringWithData);

# prevent 'Used once' warning for Kernel::OM
use Kernel::System::ObjectManager;

our $ObjectManagerDisabled = 1;
                </pre><p>
            </p><p>
                This is common header that can be found in common OTRS modules. The class/package
                name is declared via the <code class="literal">package</code> keyword. Invokers can not be instantiated by the
                Object Manager.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed params
    if ( !$Param{DebuggerObject} ) {
        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "Got no DebuggerObject!"
        };
    }

    $Self-&gt;{DebuggerObject} = $Param{DebuggerObject};

    return $Self;
}
                </pre><p>
            </p><p>
                The constructor <code class="literal">new</code> creates a new instance of the class. According to the coding
                guidelines only objects of other classes not handled by the object manager that are
                needed in this module have to be created in <code class="literal">new</code>.
            </p><p>
                </p><pre class="programlisting">
sub PrepareRequest {
    my ( $Self, %Param ) = @_;

    # we need a TicketNumber
    if ( !IsStringWithData( $Param{Data}-&gt;{TicketNumber} ) ) {
        return $Self-&gt;{DebuggerObject}-&gt;Error( Summary =&gt; 'Got no TicketNumber' );
    }

    my %ReturnData;

    $ReturnData{TicketNumber} = $Param{Data}-&gt;{TicketNumber};

    # check Action
    if ( IsStringWithData( $Param{Data}-&gt;{Action} ) ) {
        $ReturnData{Action} = $Param{Data}-&gt;{Action} . 'Test';
    }

    # check request for system time
    if ( IsStringWithData( $Param{Data}-&gt;{GetSystemTime} ) &amp;&amp; $Param{Data}-&gt;{GetSystemTime} ) {
        $ReturnData{SystemTime} = $Kernel::OM-&gt;Get('Kernel::System::Time')-&gt;SystemTime();
    }

    return {
        Success =&gt; 1,
        Data    =&gt; \%ReturnData,
    };
}
                </pre><p>
            </p><p>
                The <code class="literal">PrepareRequest</code> function is used to handle and collect all needed data to be
                sent into the request. Here we can receive data from the request handler, use it,
                extend it, generate new data, and after that, we can transfer the results to the
                mapping layer.
            </p><p>
                For this example we are expecting to receive a ticket number. If there isn't then we
                use the debugger method <code class="code">Error()</code> that creates an entry in the debug log and also
                returns a structure with the parameter <code class="literal">Success</code> as 0 and an error message as the passed
                <code class="literal">Summary</code>.
            </p><p>
                Also this example appends the word "Test" to the parameter <code class="literal">Action</code> and if
                <code class="literal">GetSystemTime</code> is requested, it will fill the <code class="literal">SystemTime</code> parameter with the current
                system time. This part of the code is to prepare the data to be sent. On a real
                invoker some calls to core modules (<code class="filename">Kernel/System/*.pm</code>) should be made here.
            </p><p>
                If during any part of the <code class="literal">PrepareRequest</code> function the request need to be stop
                without generating and error an entry in the debug log the following code can be
                used:
            </p><p>
                </p><pre class="programlisting">
# stop requester communication
return {
    Success           =&gt; 1,
    StopCommunication =&gt; 1,
};
                </pre><p>
            </p><p>
                Using this, the Requester will understand that the request should not continue
                (it will not be sent to Mapping layer and will also not be sent to the
                Network Transport). The Requester will not send an error on the debug log, it will only
                silently stop.
            </p><p>
                </p><pre class="programlisting">
sub HandleResponse {
    my ( $Self, %Param ) = @_;

    # if there was an error in the response, forward it
    if ( !$Param{ResponseSuccess} ) {
        if ( !IsStringWithData( $Param{ResponseErrorMessage} ) ) {

            return $Self-&gt;{DebuggerObject}-&gt;Error(
                Summary =&gt; 'Got response error, but no response error message!',
            );
        }

        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; $Param{ResponseErrorMessage},
        };
    }

    # we need a TicketNumber
    if ( !IsStringWithData( $Param{Data}-&gt;{TicketNumber} ) ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error( Summary =&gt; 'Got no TicketNumber!' );
    }

    # prepare TicketNumber
    my %ReturnData = (
        TicketNumber =&gt; $Param{Data}-&gt;{TicketNumber},
    );

    # check Action
    if ( IsStringWithData( $Param{Data}-&gt;{Action} ) ) {
        if ( $Param{Data}-&gt;{Action} !~ m{ \A ( .*? ) Test \z }xms ) {

            return $Self-&gt;{DebuggerObject}-&gt;Error(
                Summary =&gt; 'Got Action but it is not in required format!',
            );
        }
        $ReturnData{Action} = $1;
    }

    return {
        Success =&gt; 1,
        Data    =&gt; \%ReturnData,
    };
}
                </pre><p>
            </p><p>
                The <code class="literal">HandleResponse</code> function is used to receive  and process the data from the
                previous request, that was made to the Remote System. This data already passed by
                Mapping layer, to transform it from Remote System format to OTRS format (if
                needed).
            </p><p>
                For this particular example it checks the ticket number again and check if the
                action ends with the word 'Test' (as was done in the <code class="literal">PrepareRequest</code> function).
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    This invoker is only used for tests, a real invoker will check if the response
                    was on the format described by the Remote System and can perform some actions
                    like: call another invoker, perform a call to a Core Module, update the database,
                    send an error, etc.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="invoker-configuration"></a>Configuration Example</h6></div></div></div><p>
                There is the need to register this invoker module to be accessible in the OTRS GUI.
                This can be done using the XML configuration below.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Invoker::Module###Test::Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the invoker layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Invoker::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Name"&gt;Test&lt;/Item&gt;
            &lt;Item Key="Controller"&gt;Test&lt;/Item&gt;
            &lt;Item Key="ConfigDialog"&gt;AdminGenericInterfaceInvokerDefault&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="operation"></a>Operation</h4></div></div></div><p>
        The operation is used to perform an action within OTRS. This action is requested by the
        external system and can include special parameters in order to correctly execute the action.
        After the action is performed, OTRS sends a defined confirmation to the external system.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="adding_operation"></a>Operation backend</h5></div></div></div><p>
            Next we will show how to develop a new Operation, each operation has to implement these
            subroutines:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">Run</code></p></li></ul></div><p>
        </p><p>
            We should implement each one of this methods in order to be able to execute the action
            handled by the provider (<code class="filename">Kernel/GenericInterface/Provider.pm</code>).
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation_code_example"></a>Code example</h6></div></div></div><p>
                In this section a sample operation module is shown and each subroutine is explained.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Operation/Test/Test.pm - GenericInterface test operation backend
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::GenericInterface::Operation::Test::Test;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(IsHashRefWithData);

our $ObjectManagerDisabled = 1;
                </pre><p>
            </p><p>
                This is common header that can be found in common OTRS modules. The class/package
                name is declared via the <code class="literal">package</code> keyword.
            </p><p>
                We also include <code class="literal">VariableCheck</code> module to perform certain validation over some
                variables. Operations can not be instantiated by the Object Manager.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Needed (qw(DebuggerObject)) {
        if ( !$Param{$Needed} ) {
            return {
                Success      =&gt; 0,
                ErrorMessage =&gt; "Got no $Needed!"
            };
        }

        $Self-&gt;{$Needed} = $Param{$Needed};
    }

    return $Self;
}
                </pre><p>
            </p><p>
                The constructor <code class="literal">new</code> creates a new instance of the class. According to the coding
                guidelines only objects of other classes not handled by the object manager that are
                needed in this module have to be created in <code class="literal">new</code>.
            </p><p>
                </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    # check data - only accept undef or hash ref
    if ( defined $Param{Data} &amp;&amp; ref $Param{Data} ne 'HASH' ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Got Data but it is not a hash ref in Operation Test backend)!'
        );
    }

    if ( defined $Param{Data} &amp;&amp; $Param{Data}-&gt;{TestError} ) {

        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "Error message for error code: $Param{Data}-&gt;{TestError}",
            Data         =&gt; {
                ErrorData =&gt; $Param{Data}-&gt;{ErrorData},
            },
        };
    }

    # copy data
    my $ReturnData;

    if ( ref $Param{Data} eq 'HASH' ) {
        $ReturnData = \%{ $Param{Data} };
    }
    else {
        $ReturnData = undef;
    }

    # return result
    return {
        Success =&gt; 1,
        Data    =&gt; $ReturnData,
    };
}
                </pre><p>
            </p><p>
                The <code class="literal">Run</code> function is the main part of each operation. It receives all internal
                mapped data from remote system needed by the provider to execute the action, it
                performs the action and returns the result to the provider to be external mapped
                and deliver back to the remote system.
            </p><p>
                This particular example returns the same data as came from the remote system,
                unless <code class="literal">TestError</code> parameter is passed. In this case it returns an error.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-configuration"></a>Configuration Example</h6></div></div></div><p>
                There is the need to register this operation module to be accessible in the OTRS
                GUI. This can be done using the XML configuration below.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Operation::Module###Test::Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the operation layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Operation::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Name"&gt;Test&lt;/Item&gt;
            &lt;Item Key="Controller"&gt;Test&lt;/Item&gt;
            &lt;Item Key="ConfigDialog"&gt;AdminGenericInterfaceOperationDefault&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-unittest"></a>Unit Test Example</h6></div></div></div><p>
                Unit Test for Generic Interface operations does not differs from other unit tests
                but it is needed to consider testing locally, but also simulating a remote
                connection. It is a good practice to test both separately since results could be
                slightly different.
            </p><p>
                To learn more about unit tests, please take a look to the
                <a class="link" href="unit-tests.html" title="Unit Tests">Unit Test Chapter</a>.
            </p><p>
                The following is just the starting point for a unit test:
            </p><p>
                </p><pre class="programlisting">
# --
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

## no critic (Modules::RequireExplicitPackage)
use strict;
use warnings;
use utf8;

use vars (qw($Self));

use Kernel::GenericInterface::Debugger;
use Kernel::GenericInterface::Operation::Test::Test;

use Kernel::System::VariableCheck qw(:all);

# Skip SSL certificate verification (RestoreDatabase must not be used in this test).
$Kernel::OM-&gt;ObjectParamAdd(
    'Kernel::System::UnitTest::Helper' =&gt; {
        SkipSSLVerify =&gt; 1,
    },
);
my $Helper = $Kernel::OM-&gt;Get('Kernel::System::UnitTest::Helper');

# get a random number
my $RandomID = $Helper-&gt;GetRandomNumber();

# create a new user for current test
my $UserLogin = $Helper-&gt;TestUserCreate(
    Groups =&gt; ['users'],
);
my $Password = $UserLogin;

my $UserID = $Kernel::OM-&gt;Get('Kernel::System::User')-&gt;UserLookup(
    UserLogin =&gt; $UserLogin,
);

# set web-service name
my $WebserviceName = '-Test-' . $RandomID;

# create web-service object
my $WebserviceObject = $Kernel::OM-&gt;Get('Kernel::System::GenericInterface::Webservice');
$Self-&gt;Is(
    'Kernel::System::GenericInterface::Webservice',
    ref $WebserviceObject,
    "Create web service object",
);

my $WebserviceID = $WebserviceObject-&gt;WebserviceAdd(
    Name   =&gt; $WebserviceName,
    Config =&gt; {
        Debugger =&gt; {
            DebugThreshold =&gt; 'debug',
        },
        Provider =&gt; {
            Transport =&gt; {
                Type =&gt; '',
            },
        },
    },
    ValidID =&gt; 1,
    UserID  =&gt; 1,
);
$Self-&gt;True(
    $WebserviceID,
    "Added Web Service",
);

# get remote host with some precautions for certain unit test systems
my $Host = $Helper-&gt;GetTestHTTPHostname();

my $ConfigObject = $Kernel::OM-&gt;Get('Kernel::Config');

# prepare web-service config
my $RemoteSystem =
    $ConfigObject-&gt;Get('HttpType')
    . '://'
    . $Host
    . '/'
    . $ConfigObject-&gt;Get('ScriptAlias')
    . '/nph-genericinterface.pl/WebserviceID/'
    . $WebserviceID;

my $WebserviceConfig = {
    Description =&gt;
        'Test for Ticket Connector using SOAP transport backend.',
    Debugger =&gt; {
        DebugThreshold =&gt; 'debug',
        TestMode       =&gt; 1,
    },
    Provider =&gt; {
        Transport =&gt; {
            Type   =&gt; 'HTTP::SOAP',
            Config =&gt; {
                MaxLength =&gt; 10000000,
                NameSpace =&gt; 'http://otrs.org/SoapTestInterface/',
                Endpoint  =&gt; $RemoteSystem,
            },
        },
        Operation =&gt; {
            Test =&gt; {
                Type =&gt; 'Test::Test',
            },
        },
    },
    Requester =&gt; {
        Transport =&gt; {
            Type   =&gt; 'HTTP::SOAP',
            Config =&gt; {
                NameSpace =&gt; 'http://otrs.org/SoapTestInterface/',
                Encoding  =&gt; 'UTF-8',
                Endpoint  =&gt; $RemoteSystem,
            },
        },
        Invoker =&gt; {
            Test =&gt; {
                Type =&gt; 'Test::TestSimple'
                ,    # requester needs to be Test::TestSimple in order to simulate a request to a remote system
            },
        },
    },
};

# update web-service with real config
# the update is needed because we are using
# the WebserviceID for the Endpoint in config
my $WebserviceUpdate = $WebserviceObject-&gt;WebserviceUpdate(
    ID      =&gt; $WebserviceID,
    Name    =&gt; $WebserviceName,
    Config  =&gt; $WebserviceConfig,
    ValidID =&gt; 1,
    UserID  =&gt; $UserID,
);
$Self-&gt;True(
    $WebserviceUpdate,
    "Updated Web Service $WebserviceID - $WebserviceName",
);

# debugger object
my $DebuggerObject = Kernel::GenericInterface::Debugger-&gt;new(
    DebuggerConfig =&gt; {
        DebugThreshold =&gt; 'debug',
        TestMode       =&gt; 1,
    },
    WebserviceID      =&gt; $WebserviceID,
    CommunicationType =&gt; 'Provider',
);
$Self-&gt;Is(
    ref $DebuggerObject,
    'Kernel::GenericInterface::Debugger',
    'DebuggerObject instantiate correctly',
);

# define test cases
my @Tests = (
    {
        Name           =&gt; 'Test case name',
        SuccessRequest =&gt; 1,                  # 1 or 0
        RequestData    =&gt; {

            # ... add test data
        },
        ExpectedReturnLocalData =&gt; {
            Data =&gt; {

                # ... add expected local results
            },
            Success =&gt; 1,                     # 1 or 0
        },
        ExpectedReturnRemoteData =&gt; {
            Data =&gt; {

                # ... add expected remote results
            },
            Success =&gt; 1,                     # 1 or 0
        },
        Operation =&gt; 'Test',
    },

    # ... add more test cases
);

TEST:
for my $Test (@Tests) {

    # create local object
    my $LocalObject = "Kernel::GenericInterface::Operation::Test::$Test-&gt;{Operation}"-&gt;new(
        DebuggerObject =&gt; $DebuggerObject,
        WebserviceID   =&gt; $WebserviceID,
    );

    $Self-&gt;Is(
        "Kernel::GenericInterface::Operation::Test::$Test-&gt;{Operation}",
        ref $LocalObject,
        "$Test-&gt;{Name} - Create local object",
    );

    my %Auth = (
        UserLogin =&gt; $UserLogin,
        Password  =&gt; $Password,
    );
    if ( IsHashRefWithData( $Test-&gt;{Auth} ) ) {
        %Auth = %{ $Test-&gt;{Auth} };
    }

    # start requester with our web-service
    my $LocalResult = $LocalObject-&gt;Run(
        WebserviceID =&gt; $WebserviceID,
        Invoker      =&gt; $Test-&gt;{Operation},
        Data         =&gt; {
            %Auth,
            %{ $Test-&gt;{RequestData} },
        },
    );

    # check result
    $Self-&gt;Is(
        'HASH',
        ref $LocalResult,
        "$Test-&gt;{Name} - Local result structure is valid",
    );

    # create requester object
    my $RequesterObject = $Kernel::OM-&gt;Get('Kernel::GenericInterface::Requester');
    $Self-&gt;Is(
        'Kernel::GenericInterface::Requester',
        ref $RequesterObject,
        "$Test-&gt;{Name} - Create requester object",
    );

    # start requester with our web-service
    my $RequesterResult = $RequesterObject-&gt;Run(
        WebserviceID =&gt; $WebserviceID,
        Invoker      =&gt; $Test-&gt;{Operation},
        Data         =&gt; {
            %Auth,
            %{ $Test-&gt;{RequestData} },
        },
    );

    # check result
    $Self-&gt;Is(
        'HASH',
        ref $RequesterResult,
        "$Test-&gt;{Name} - Requester result structure is valid",
    );

    $Self-&gt;Is(
        $RequesterResult-&gt;{Success},
        $Test-&gt;{SuccessRequest},
        "$Test-&gt;{Name} - Requester successful result",
    );

    # ... add tests for the results
}

# delete web service
my $WebserviceDelete = $WebserviceObject-&gt;WebserviceDelete(
    ID     =&gt; $WebserviceID,
    UserID =&gt; $UserID,
);
$Self-&gt;True(
    $WebserviceDelete,
    "Deleted Web Service $WebserviceID",
);

# also delete any other added data during the this test, since RestoreDatabase must not be used.

1;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-wsdl"></a>WSDL Extension Example</h6></div></div></div><p>
                WSDL files contain the definitions of the web services and its operations for SOAP
                messages, in case we will extend
                <code class="filename">development/webservices/GenericTickeConnectorSOAP.wsdl</code>
                in some places:
            </p><p>
                Port Type:
            </p><p>
                </p><pre class="programlisting">
    &lt;wsdl:portType name="GenericTicketConnector_PortType"&gt;
        &lt;!-- ... --&gt;
        &lt;wsdl:operation name="Test"&gt;
            &lt;wsdl:input message="tns:TestRequest"/&gt;
            &lt;wsdl:output message="tns:TestResponse"/&gt;
        &lt;/wsdl:operation&gt;
    &lt;!-- ... --&gt;
                </pre><p>
            </p><p>
                Binding:
            </p><p>
                </p><pre class="programlisting">
    &lt;wsdl:binding name="GenericTicketConnector_Binding" type="tns:GenericTicketConnector_PortType"&gt;
        &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;
        &lt;!-- ... --&gt;
        &lt;wsdl:operation name="Test"&gt;
            &lt;soap:operation soapAction="http://www.otrs.org/TicketConnector/Test"/&gt;
            &lt;wsdl:input&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:input&gt;
            &lt;wsdl:output&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:output&gt;
        &lt;/wsdl:operation&gt;
        &lt;!-- ... --&gt;
    &lt;/wsdl:binding&gt;
                </pre><p>
            </p><p>
                Type:
            </p><p>
                </p><pre class="programlisting">
    &lt;wsdl:types&gt;
        &lt;xsd:schema targetNamespace="http://www.otrs.org/TicketConnector/" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
        &lt;!-- ... --&gt;
            &lt;xsd:element name="Test"&gt;
                &lt;xsd:complexType&gt;
                    &lt;xsd:sequence&gt;
                            &lt;xsd:element minOccurs="0" name="Param1" type="xsd:string"/&gt;
                            &lt;xsd:element minOccurs="0" name="Param2" type="xsd:positiveInteger"/&gt;
                    &lt;/xsd:sequence&gt;
                &lt;/xsd:complexType&gt;
            &lt;/xsd:element&gt;
            &lt;xsd:element name="TestResponse"&gt;
                &lt;xsd:complexType&gt;
                    &lt;xsd:sequence&gt;
                        &lt;xsd:element maxOccurs="unbounded" minOccurs="1" name="Attribute1" type="xsd:string"/&gt;
                    &lt;/xsd:sequence&gt;
                &lt;/xsd:complexType&gt;
            &lt;/xsd:element&gt;
        &lt;!-- ... --&gt;
        &lt;/xsd:schema&gt;
    &lt;/wsdl:types&gt;
                </pre><p>
            </p><p>
                Message:
            </p><p>
                </p><pre class="programlisting">
    &lt;!-- ... --&gt;
    &lt;wsdl:message name="TestRequest"&gt;
        &lt;wsdl:part element="tns:Test" name="parameters"/&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:message name="TestResponse"&gt;
        &lt;wsdl:part element="tns:TestResponse" name="parameters"/&gt;
    &lt;/wsdl:message&gt;
    &lt;!-- ... --&gt;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-wadl"></a>WADL Extension Example</h6></div></div></div><p>
                WADL files contain the definitions of the web services and its operations for REST
                interface, add a new resource to
                <code class="filename">development/webservices/GenericTickeConnectorREST.wadl</code>.
            </p><p>
                </p><pre class="programlisting">
  &lt;resources base="http://localhost/otrs/nph-genericinterface.pl/Webservice/GenericTicketConnectorREST"&gt;
    &lt;!-- ... --&gt;
    &lt;resource path="Test" id="Test"&gt;
      &lt;doc xml:lang="en" title="Test"/&gt;
        &lt;param name="Param1" type="xs:string" required="false" default="" style="query" xmlns:xs="http://www.w3.org/2001/XMLSchema"/&gt;
        &lt;param name="Param2" type="xs:string" required="false" default="" style="query" xmlns:xs="http://www.w3.org/2001/XMLSchema"/&gt;
        &lt;method name="GET" id="GET_Test"&gt;
          &lt;doc xml:lang="en" title="GET_Test"/&gt;
          &lt;request/&gt;
          &lt;response status="200"&gt;
            &lt;representation mediaType="application/json; charset=UTF-8"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/resource&gt;
    &lt;/resource&gt;
    &lt;!-- ... --&gt;
  &lt;/resources&gt;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-soap"></a>Web Service SOAP Extension Example</h6></div></div></div><p>
                Web services can be imported into OTRS by a YAML with a predefined structure
                in this case we will extend
                <code class="filename">development/webservices/GenericTickeConnectorSOAP.yml</code> for a
                SOAP web service.
            </p><p>
                </p><pre class="programlisting">
Provider:
  Operation:
    # ...
    Test:
      Description: This is only a test
      MappingInbound: {}
      MappingOutbound: {}
      Type: Test::Test
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-rest"></a>Web Service REST Extension Example</h6></div></div></div><p>
                Web services can be imported into OTRS by a YAML with a predefined structure
                in this case we will extend
                <code class="filename">development/webservices/GenericTickeConnectorREST.yml</code> for a
                REST web service.
            </p><p>
                </p><pre class="programlisting">
Provider:
  Operation:
    # ...
    Test:
      Description: This is only a test
      MappingInbound: {}
      MappingOutbound: {}
      Type: Test::Test
  # ...
  Transport:
    Config:
      # ...
      RouteOperationMapping:
        # ..
        Test:
          RequestMethod:
          - GET
          Route: /Test
                </pre><p>
            </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="daemon-scheduler-modules"></a>Daemon And Scheduler</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="daemon-overview"></a>OTRS Daemon</h4></div></div></div><p>
        The OTRS Daemon is a separated process that helps OTRS to execute certain actions
        asynchronously and detached of the web server process, but sharing the same database.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="daemon-modules"></a>OTRS Daemon Modules</h5></div></div></div><p>
            The OTRS Daemon <code class="filename">bin/otrs.Daemon.pl</code> main purpose is to call
            (Daemonize) all the registered daemon modules in the System Configuration.
        </p><p>
            Each daemon module must implement a common API in order to be correctly called by the
            OTRS Daemon and be a semi persistent process in the system. Persistent process could
            grow in size and memory usage over the time and normally they do not respond to
            changes in the configuration. That is why the daemon modules should implement a discard
            mechanism to be stopped and re-spawned again from time to time, freeing system resources
            and re-reading the configuration.
        </p><p>
            A daemon module could be an all-in-one solution to perform a certain job, but there
            could be the case that a solution requires different daemon modules due to its complexity.
            That is exactly the case of the OTRS Scheduler Daemon that is split into several daemon
            modules including some daemon modules for task management and task execution.
        </p><p>
            It is not always necessary to create a new daemon module to perform certain task,
            usually the OTRS Scheduler Daemon can deal with the majority of them, either if it is an
            OTRS function that needs to be executed on a regular basis (CRON like) or if it's
            triggered by an OTRS event, the OTRS Scheduler should be capable to deal with it out of
            the box or by adding a new scheduler task worker module.
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="creating-new-daemon-module"></a>Creating A New Daemon Module</h6></div></div></div><p>
                All daemon modules requires to be registered in the System Configuration in order
                to be called by the main OTRS Daemon.
            </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="daemon-module-registration-code-example"></a>Daemon Module Registration Code Example</h6></div></div></div><p>
                    </p><pre class="programlisting">
&lt;Setting Name="DaemonModules###TestDaemon" Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;The daemon registration for the scheduler generic agent task manager.&lt;/Description&gt;
    &lt;Navigation&gt;Daemon::ModuleRegistration&lt;/Navigation&gt;
    &lt;Value&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::System::Daemon::DaemonModules::TestDaemon&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Value&gt;
&lt;/Setting&gt;
                    </pre><p>
                </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="demon-module-code-example"></a>Daemon Module Code Example</h6></div></div></div><p>
                    The following code implements a daemon module that displays the system time
                    every 2 seconds.
                </p><p>
                    </p><pre class="programlisting">
# --
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Daemon::DaemonModules::TestDaemon;

use strict;
use warnings;
use utf8;

use Kernel::System::VariableCheck qw(:all);

use parent qw(Kernel::System::Daemon::BaseDaemon);

our @ObjectDependencies = (
    'Kernel::Config',
    'Kernel::System::Cache',
    'Kernel::System::DB',
);
                    </pre><p>
                </p><p>
                    This is common header that can be found in most OTRS modules. The
                    class/package name is declared via the <code class="literal">package</code> keyword.
                </p><p>
                    In this case we are inheriting from <code class="literal">BaseDaemon</code> class, and the object manager
                    dependencies are set.
                </p><p>
                    </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # Allocate new hash for object.
    my $Self = {};
    bless $Self, $Type;

    # Get objects in constructor to save performance.
    $Self-&gt;{ConfigObject} = $Kernel::OM-&gt;Get('Kernel::Config');
    $Self-&gt;{CacheObject}  = $Kernel::OM-&gt;Get('Kernel::System::Cache');
    $Self-&gt;{DBObject}     = $Kernel::OM-&gt;Get('Kernel::System::DB');

    # Disable in memory cache to be clusterable.
    $Self-&gt;{CacheObject}-&gt;Configure(
        CacheInMemory  =&gt; 0,
        CacheInBackend =&gt; 1,
    );

    $Self-&gt;{SleepPost} = 2;          # sleep 2 seconds after each loop
    $Self-&gt;{Discard}   = 60 * 60;    # discard every hour

    $Self-&gt;{DiscardCount} = $Self-&gt;{Discard} / $Self-&gt;{SleepPost};

    $Self-&gt;{Debug}      = $Param{Debug};
    $Self-&gt;{DaemonName} = 'Daemon: TestDaemon';

    return $Self;
}
                    </pre><p>
                </p><p>
                    The constructor <code class="literal">new</code> creates a new instance of the class.
                    Some used objects are also created here. It is highly recommended to disable
                    in-memory cache in daemon modules especially if OTRS runs in a cluster
                    environment.
                </p><p>
                    In order to make this daemon module to be executed every two seconds it is necessary
                    to define a sleep time accordingly, otherwise it will be executed as soon as
                    possible.
                </p><p>
                    Refreshing the daemon module from time to time is necessary in order to define when it
                    should be discarded.
                </p><p>
                    For the following functions (<code class="literal">PreRun</code>, <code class="literal">Run</code> and
                    <code class="literal">PostRun</code>) if they return false, the main OTRS Daemon will discard
                    the object and create a new one as soon as possible.
                </p><p>
                    </p><pre class="programlisting">
sub PreRun {
    my ( $Self, %Param ) = @_;

    # Check if database is on-line.
    return 1 if $Self-&gt;{DBObject}-&gt;Ping();

    sleep 10;

    return;
}
                    </pre><p>
                </p><p>
                    The <code class="literal">PreRun</code> method is executed before the main daemon module method,
                    and the its purpose is to perform some test before the real operation. In this case a check
                    to the database is done (always recommended), otherwise it sleeps for 10 seconds. This is
                    needed in order to wait for DB connection to be reestablished.
                </p><p>
                    </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    print "Current time " . localtime . "\n";

    return 1;
}
                    </pre><p>
                </p><p>
                    The <code class="literal">Run</code> method is where the main daemon module code resides, in this case
                    it only prints the current time.
                </p><p>
                    </p><pre class="programlisting">
sub PostRun {
    my ( $Self, %Param ) = @_;
    sleep $Self-&gt;{SleepPost};
    $Self-&gt;{DiscardCount}--;

    if ( $Self-&gt;{Debug} ) {
        print "  $Self-&gt;{DaemonName} Discard Count: $Self-&gt;{DiscardCount}\n";
    }

    return if $Self-&gt;{DiscardCount} &lt;= 0;

    return 1;
}
                    </pre><p>
                </p><p>
                    The <code class="literal">PostRun</code> method is used to perform the sleeps (preventing the daemon
                    module to be executed too often) and also to manage the safe discarding of the object. Other
                    operations like verification or cleanup can be done here.
                </p><p>
                    </p><pre class="programlisting">
sub Summary {
    my ( $Self, %Param ) = @_;

    my %Summary = (
        Header =&gt; 'Test Daemon Summary:',
        Column =&gt; [
            {
                Name        =&gt; 'SomeColumn',
                DisplayName =&gt; 'Some Column',
                Size        =&gt; 15,
            },
            {
                Name        =&gt; 'AnotherColumn',
                DisplayName =&gt; 'Another Column',
                Size        =&gt; 15,
            },
            # ...
        ],
        Data =&gt; [
            {
                SomeColumn    =&gt; 'Some Data 1',
                AnotherColumn =&gt; 'Another Data 1',
            },
            {
                SomeColumn    =&gt; 'Some Data 2',
                AnotherColumn =&gt; 'Another Data 2',
            },
            # ...
        ],
        NoDataMesssage =&gt; '',
    );

    return \%Summary;
}
                    </pre><p>
                </p><p>
                    The <code class="literal">Summary</code> method is called by the console command
                    <code class="literal">Maint::Daemon::Summary</code> and it's required to return <code class="literal">Header</code>,
                    <code class="literal">Column</code>, <code class="literal">Data</code> and <code class="literal">NoDataMessages</code> keys.
                    <code class="literal">Column</code> and <code class="literal">Data</code> needs to be an array of hashes.
                    It is used to display useful information of what the daemon module is currently
                    doing, or what has been done so far. This method is optional.
                </p><p>
                    </p><pre class="programlisting">
1;
                    </pre><p>
                </p><p>
                    End of file.
                </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="scheduler-overview"></a>OTRS Scheduler</h4></div></div></div><p>
        The OTRS Scheduler is a conjunction of daemon modules and task workers that runs together
        in order to perform all needed OTRS tasks asynchronously from the web server process.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="scheduler-task-managers"></a>OTRS Scheduler Task Managers</h5></div></div></div><p>
            <code class="literal">SchedulerCronTaskManager</code> reads registered cron tasks from the OTRS
            SysConfig and determines the correct time to create a task to be executed.
        </p><p>
            <code class="literal">SchedulerFutureTaskManager</code> checks the tasks that are set to be executed
            just one time in the future and sets this task to be executed in time. For example, when a
            Generic Interface Invoker can not reach the remote server, it can self schedule to be run
            again 5 minutes later.
        </p><p>
            <code class="literal">SchedulerGenericAgentTaskManager</code> continuously reads the
            <code class="literal">GenericAgent</code> tasks that are set to be run on regular time basis and sets
            their execution accordingly.
        </p><p>
            Whenever these tasks managers are not enough, a new daemon module can be created. At a
            certain point of its <code class="literal">Run()</code> method it needs to call <code class="literal">TaskAdd()</code>
            from the <code class="literal">chedulerDB</code> object to register a task, and as soon as it is registered,
            it will be executed in the next free slot by the <code class="literal">SchedulerTaskWorker</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="scheduler-task-workers"></a>OTRS Scheduler Task Workers</h5></div></div></div><p>
                <code class="literal">SchedulerTaskWorker</code> execute all tasks planned by the previous tasks
                managers plus the ones that come directly from the code by using the Asynchronous Executor.
            </p><p>
                In order to execute each task, the <code class="literal">SchedulerTaskWorker</code> calls a backend
                module (Task Worker) to perform the specific task. The worker module is determined by the
                task type. If a new task type is added, it will require a new task worker.
            </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="creating-new-scheduler-task-worker"></a>Creating A New Scheduler Task Worker</h6></div></div></div><p>
                    All files placed under
                    <code class="filename">Kernel/System/Daemon/DaemonModules/SchedulerTaskWorker</code>
                    could potentially be task workers and they do not require any registration in
                    the system configuration.
                </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="scheduler-task-worker-code-example"></a>Scheduler Task Worker Code Example</h6></div></div></div><p>
                        </p><pre class="programlisting">
# --
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Daemon::DaemonModules::SchedulerTaskWorker::TestWorker;

use strict;
use warnings;

use parent qw(Kernel::System::Daemon::DaemonModules::BaseTaskWorker);

our @ObjectDependencies = (
    'Kernel::System::Log',
);
                        </pre><p>
                    </p><p>
                        This is common header that can be found in most OTRS modules. The
                        class/package name is declared via the <code class="literal">package</code> keyword.
                    </p><p>
                        In this case we are inheriting from <code class="literal">BaseTaskWorker</code> class,
                        and the object manager dependencies are set.
                    </p><p>
                        </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {};
    bless( $Self, $Type );

    $Self-&gt;{Debug}      = $Param{Debug};
    $Self-&gt;{WorkerName} = 'Worker: Test';

    return $Self;
}
                        </pre><p>
                    </p><p>
                        The constructor <code class="literal">new</code> creates a new instance of the class.
                    </p><p>
                        </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    # Check task params.
    my $CheckResult = $Self-&gt;_CheckTaskParams(
        %Param,
        NeededDataAttributes =&gt; [ 'NeededAtrribute1', 'NeededAtrribute2' ],
        DataParamsRef        =&gt; 'HASH', # or 'ARRAT'
    );

    # Stop execution if an error in params is detected.
    return if !$CheckResult;

    my $Success;
    my $ErrorMessage;

    if ( $Self-&gt;{Debug} ) {
        print "    $Self-&gt;{WorkerName} executes task: $Param{TaskName}\n";
    }

    do {

        # Localize the standard error.
        local *STDERR;

        # Redirect the standard error to a variable.
        open STDERR, "&gt;&gt;", \$ErrorMessage;

        $Success = $Kernel::OM-&gt;Get('Kernel::System::MyPackage')-&gt;Run(
            Param1 =&gt; 'someparam',
        );
    };

    if ( !$Success ) {

        $ErrorMessage ||= "$Param{TaskName} execution failed without an error message!";

        $Self-&gt;_HandleError(
            TaskName     =&gt; $Param{TaskName},
            TaskType     =&gt; 'Test',
            LogMessage   =&gt; "There was an error executing $Param{TaskName}: $ErrorMessage",
            ErrorMessage =&gt; "$ErrorMessage",
        );
    }

    return $Success;
}
                        </pre><p>
                    </p><p>
                        The <code class="literal">Run</code> is the main method. A call to
                        <code class="literal">_CheckTaskParams()</code> from the base class will save some lines
                        of code. Executing the task while capturing the STDERR is a very good practice,
                        since the OTRS Scheduler runs normally unattended, and saving all errors to a
                        variable will make it available for further processing.
                        <code class="literal">_HandleError()</code> provides a common interface to send the error
                        messages as email to the recipient specified in the System Configuration.
                    </p><p>
                        </p><pre class="programlisting">
1;
                        </pre><p>
                    </p><p>
                        End of file.
                    </p></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dynamicfields-modules"></a>Dynamic Fields</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-overview"></a>Overview</h4></div></div></div><p>
        Dynamic Fields are custom fields that can be added to a screen to enhance and add
        information to an object (e.g. a ticket or an article).
    </p><p>
        The Dynamic Fields are the evolution of the ticket and article Free Fields
        (<code class="literal">TikcetFreeText</code>, <code class="literal">TicketFreeKey</code>,
        <code class="literal">TicketFreeTime</code>, <code class="literal">ArticleFreeText</code>,
        <code class="literal">ArticleFreeKey</code> and <code class="literal">ArticleFreeTime</code>) from older
        versions of OTRS.
    </p><p>
        From OTRS version 3.1 the old Free Fields has been replaced with the new Dynamic Fields.
        For a better backward compatibility and data preservation when updating from previous
        versions, a migration script has been developed to convert the existing Free Fields to
        Dynamic Fields and to move their values from the <span class="emphasis"><em>ticket</em></span> and
        <span class="emphasis"><em>article</em></span> tables in the database to new dynamic fields tables.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            Any custom development that uses Free Fields needs to be ported to the new Dynamic
            Fields code structure, otherwise it will not work anymore. For this reason is very
            important to know that only updated installations of OTRS 3.0 has the old Free
            Fields converted to Dynamic Fields, new or clean installations of OTRS has no Dynamic
            Fields defined "out of the box" and any Dynamic Field needed by the custom development
            needs to be added.
        </p></div><p>
        The restriction on the number of the fields per ticket or article has been removed. This
        means that a ticket or article could have as many fields as needed. And now it is also
        possible to use the Dynamic Fields framework for other objects rather than just ticket or
        article.
    </p><p>
        The new Dynamic Fields can store the same data types as the Free Fields
        (Text and Date/Time), and they can be also defined as them (Single line input, drop-down and
        date-time), but Dynamic Fields go beyond that, a new integer data type has been added
        and also new options to define the fields like Multiple-line inputs, check-boxes,
        Multiple-select and date (without time) fields. Each field type defines its own data type.
    </p><p>
        Due to its modular design each Dynamic Field type can be seen as a plug-in to a framework,
        and this plug-in can be an OTRS standard package to extend the available types of the
        Dynamic Fields or even to extend current Dynamic Field with more functions.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-framework"></a>Dynamic Fields Framework</h4></div></div></div><p>
        Before creating new Dynamic Fields is necessary to understand its framework and how OTRS
        screens interact with them, as well as their underlying API.
    </p><p>
        The following picture shows the architecture of the Dynamic Fields framework.
    </p><p>
        </p><div class="figure"><a name="id-1.4.3.9.3.4.1"></a><p class="title"><b>Figure 3.2. Dynamic Fields Architecture</b></p><div class="figure-contents"><div class="screenshot"><div><img src="screenshots/dfframework.png" alt="Dynamic Fields Architecture"></div></div></div></div><p><br class="figure-break">
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-backends"></a>Dynamic Field Backend Modules</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-backends-backend"></a>Dynamic Field (Backend)</h6></div></div></div><p>
                Normally called as <code class="literal">BackendObject</code> in the frontend modules is the mediator between
                the frontend modules and each specific Dynamic Field implementation or Driver. It
                defines a Generic middle API for all Dynamic Field Drivers, and each Driver has
                the responsibility to implement the middle API for the specific needs for the field.
            </p><p>
                The Dynamic Field Backend is the master controller of all the Drivers. Each
                function in this module is responsible to check the required parameters and call
                the same function in the specific Driver according to the Dynamic Field
                Configuration parameter received.
            </p><p>
                This module is also responsible to call specific functions on each Object Type
                Delegate (like Ticket or Article) e.g. to add a history entry or fire an event.
            </p><p>
                This module is located in <code class="filename">$OTRS_HOME/Kernel/System/DynamicField/Backend.pm</code>.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-backends-drivers"></a>Dynamic Field Drivers</h6></div></div></div><p>
                A Dynamic Field Driver is the implementation of the Dynamic Field. Each Driver
                must implement all the mandatory functions specified in the Backend (there are
                some functions that depends on a behavior and it is not needed to implement those
                if the Dynamic Field does not have that particular behavior).
            </p><p>
                A Driver is responsible to know how to get its own value or values from a web
                request, or from a profile (like a search profile). It also needs to know the HTML
                code to render the field in edit or display screens, or how to interact with the
                stats module, among other functions.
            </p><p>
                These modules are located in <code class="filename">$OTRS_HOME/Kernel/System/DynamicField/Driver/*.pm</code>.
            </p><p>
                It exists some base drivers like <code class="filename">Base.pm</code>, <code class="filename">BaseText.pm</code>, <code class="filename">BaseSelect.pm</code> and
                <code class="filename">BaseDateTime.pm</code>, that implements common functions for certain drivers (e.g. Driver
                <code class="filename">TextArea.pm</code> uses <code class="filename">BaseText.pm</code> that also uses <code class="filename">Base.pm</code> then <code class="literal">TextArea</code> only needs to
                implement the functions that are missing in <code class="filename">Base.pm</code> and <code class="filename">BateText.pm</code> or the ones that
                are special cases).
            </p><p>
                The following is the Drivers inheritance tree:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>Base.pm</p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>BaseText.pm</p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>Text.pm</p></li><li class="listitem"><p>TextArea.pm</p></li></ul></div></li><li class="listitem"><p>BaseSelect.pm</p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>Dropdown.pm</p></li><li class="listitem"><p>Multiselect.pm</p></li></ul></div></li><li class="listitem"><p>BaseDateTime.pm</p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>DateTime.pm</p></li><li class="listitem"><p>Date.pm</p></li></ul></div></li><li class="listitem"><p>Checkbox.pm</p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-backends-object-type-delegates"></a>Object Type Delegate</h6></div></div></div><p>
                An Object Type Delegate is responsible to perform specific functions on the
                object linked to the dynamic field. These functions are triggered by the
                Backend object as they are needed.
            </p><p>
                These modules are located in <code class="filename">$OTRS_HOME/Kernel/System/DynamicField/ObjectType/*.pm</code>.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-admin"></a>Dynamic Fields Admin Modules</h5></div></div></div><p>
            To manage the Dynamic Fields (Add, Edit and List) a series of modules has been already
            developed. There is one specific master module (<code class="filename">AdminDynamicField.pm</code>) that shows the
            list of defined Dynamic Fields, and from within other modules are called to create new
            Dynamic Fields or modify an existing ones.
        </p><p>
            Normally a Dynamic Field Driver needs its own Admin Module (Admin Dialog) to define
            its properties. This dialog might differ from other Drivers. But this is not mandatory,
            Drivers can share Admin Dialogs, if they can provide needed information for all
            the Drivers that are linked to them, no matter if they are from different type. What is
            mandatory is that each Driver must be linked to an Admin Dialog (e.g. Text and
            TextArea Drivers share <code class="filename">AdminDynamicFieldText.pm</code> Admin Dialog, and Date and Date/Time
            Drivers share <code class="filename">AdminDynamicFieldDateTime.pm</code> Admin Dialog).
        </p><p>
            Admin Dialogs follow the normal OTRS Admin Module rules and architecture. But for
            standardization all configuration common parts to all Dynamic Fields should have the
            same look and feel among all Admin Dialogs.
        </p><p>
            These modules are located in <code class="filename">$OTRS_HOME/Kernel/Modules/*.pm</code>.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Each Admin Dialog needs its corresponding HTML template file (<code class="filename">.tt</code>).
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-core"></a>Dynamic Fields Core Modules</h5></div></div></div><p>
            This modules reads and writes the Dynamic Fields information from and to the database
            tables.
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-core-dynamicfield"></a><code class="filename">DynamicField.pm</code> Core Module</h6></div></div></div><p>
                This module is responsible to manage the Dynamic Field definitions. It provides the
                basic API for add, change, delete, list and get Dynamic Fields. This module is located
                in <code class="filename">$OTRS_HOME/Kernel/System/DynamicField.pm</code>.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-core-dynamicfieldvalue"></a><code class="filename">DynamicFieldValue.pm</code> Core Module</h6></div></div></div><p>
                This module is responsible to read and write Dynamic Field values into the form and
                into the database. This module is highly used by the Drivers and is located in
                <code class="filename">$OTRS_HOME/Kernel/System/DynamicFieldValue.pm</code>.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-database"></a>Dynamic Fields Database Tables</h5></div></div></div><p>
            There are two tables in the database to store the dynamic field information:
        </p><p>
            <span class="emphasis"><em>dynamic_field</em></span>: Used by the Core Module <code class="filename">DynamicField.pm</code>, it stores
            the Dynamic Field definitions.
        </p><p>
            <span class="emphasis"><em>dynamic_field_value</em></span>: Used by the Core Module <code class="filename">DynamicFieldValue.pm</code>
            to save the Dynamic Field values for each Dynamic Field and each Object Type instance.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-configuration-files"></a>Dynamic Fields Configuration Files</h5></div></div></div><p>
            The Backend module needs a way to know which Drivers exists and since the amount of
            Drivers can be easily extended. The easiest way to manage them is to use the system
            configuration, where the information of Dynamic Field Drivers and Object Type Drivers
            can be stored and extended.
        </p><p>
            The master Admin Module also needs to know this information about the available Dynamic
            Field Drivers to use the Admin Dialog linked with, to create or modify the Dynamic
            Fields.
        </p><p>
            Frontend modules need to read the system configuration to know which Dynamic Fields
            are active for each screen and which ones are also mandatory. For example:
            <code class="literal">Ticket::Frontend::AgentTicketPhone###DynamicField</code> stores the active, mandatory and
            inactive Dynamic Fields for New Phone Ticket Screen.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-interaction"></a>Dynamic Field Interaction With Frontend Modules</h4></div></div></div><p>
        Knowing about how Frontend modules interact with Dynamic fields is not strictly necessary to
        extend Dynamic Fields for the Ticket or Article objects, since all the screens that could
        use the Dynamic Fields are already prepared. But in case of custom developments or to
        extend the Dynamic Fields to other objects is very useful to know how to access
        Dynamic Fields framework from a Frontend Module.
    </p><p>
        The following picture shows a simple example of how the Dynamic Fields interact with other
        OTRS framework parts.
    </p><p>
        </p><div class="figure"><a name="id-1.4.3.9.4.4.1"></a><p class="title"><b>Figure 3.3. Dynamic Field Interaction</b></p><div class="figure-contents"><div class="screenshot"><div><img src="screenshots/dfInteraction.png" alt="Dynamic Field Interaction"></div></div></div></div><p><br class="figure-break">
    </p><p>
        The first step is that the Frontend module reads the configured Dynamic Fields. For example
        <code class="literal">AgentTicketNote</code> should read
        <code class="literal">Ticket::Frontend::AgentTicketNote###DynamicField</code> setting. This setting
        can be used as the filter parameter for DynamicField Core Module function
        <code class="code">DynamicFieldListGet()</code>. The screen can store the results of this
        function to have the list of the Dynamic Fields activated for this particular screen.
    </p><p>
        Next, the screen should try to get the values from the web request. It can use the
        Backend Object function <code class="code">EditFieldValueGet()</code> for this purpose, and can
        use this values to trigger ACLs. The Backend Object will use each Driver to perform the
        specific actions for all functions.
    </p><p>
        To continue, the screen should get the HTML for each field to display it. The Backend Object
        function <code class="code">EditFieldRender()</code> can be used to perform this action and the
        ACLs restriction as well as the Values from the web request can be passed to this function
        in order to get better results. In case of a submit the screen could also use the
        BackendObject function <code class="code">EditFieldValueValidate()</code> to check the mandatory
        fields.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            Other screens could use <code class="code">DisplayFieldRender()</code> instead of
            <code class="code">EditFieldRender()</code> if the screen only shows the field value,
            and in such case no value validation is needed.
        </p></div><p>
        To store the value of the Dynamic Field is necessary to get the Object ID. For this example
        if the Dynamic Field is linked to a ticket object, the screen should already have the
        TicketID, otherwise if the field is linked to an article object in order to set the value of
        the field is necessary to create the article first. <code class="code">ValueSet()</code> from
        the Backend Object can be used to set the Dynamic Field value.
    </p><p>
        In summary the Frontend modules does not need to know how each Dynamic Field works
        internally to get or set their values or to display them. It just needs to call the
        Backend Object module and use the fields in a generic way.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-extend-options"></a>How To Extend The Dynamic Fields</h4></div></div></div><p>
        There are many ways to extend the Dynamic Fields. The following sections will try to cover
        the most common scenarios.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-options-new-field"></a>Create a New Dynamic Field Type (for ticket or article objects)</h5></div></div></div><p>
            To create a new Dynamic Field Type is necessary to:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>
                    Create a Dynamic Field Driver
                </p><p>
                    This is the main module of the new field.
                </p></li><li class="listitem"><p>
                    Create or use an existing Admin Dialog
                </p><p>
                    To have a management interface and set its configuration options.
                </p></li><li class="listitem"><p>
                    Create a Configuration File
                </p><p>
                    To register the new field in the Backend (or new Admin Dialogs in the framework
                    if needed) and be able to create instances or it.
                </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-options-new-field-new-object"></a>Create a New Dynamic Field Type (for other objects)</h5></div></div></div><p>
            To create a new Dynamic Field Type for other objects is necessary to:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>
                    Create a Dynamic Field Driver
                </p><p>
                    This is the main module of the new field.
                </p></li><li class="listitem"><p>
                    Create an Object Type Delegate
                </p><p>
                    This is necessary, even if the "other object" does not require any specific
                    data handling in its functions (e.g. after a value is set). All Object Type
                    Delegates must implement the functions that the Backend requires.
                </p><p>
                    Take a look in the current Object Type Delegates to implement the same
                    functions, even if they just return a successful value for the "other object".
                </p></li><li class="listitem"><p>
                    Create or use an existing Admin Dialog
                </p><p>
                    To have a management interface and set its configuration options.
                </p></li><li class="listitem"><p>
                    Implement Dynamic Fields in the Frontend Modules
                </p><p>
                    To be able to use the Dynamic Fields.
                </p></li><li class="listitem"><p>
                    Create a Configuration File
                </p><p>
                    To register the new field in the Backend (or new Admin Dialogs in the framework
                    if needed) and be able to create instances or it. And make the needed settings
                    to show, hide or show the Dynamic Fields as Mandatory in the new screens.
                </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-options-new-packages"></a>Create a New package to use Dynamic Fields</h5></div></div></div><p>
            To create a package to use existing dynamic fields is necessary to:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>
                    Implement Dynamic Fields in the Frontend Modules
                </p><p>
                    To be able to use the Dynamic Fields.
                </p></li><li class="listitem"><p>
                    Create a Configuration File
                </p><p>
                    To give the end user the possibility to show, hide or show the Dynamic Fields as
                    Mandatory in the new screens.
                </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-options-backend-functionalities"></a>Extend Backend and Drivers Functionalities</h5></div></div></div><p>
            It might be possible that the Backend object does not have a needed function for
            custom developments, or could also be possible that it has the function needed, but the
            return format does not match the needs of the custom development, or that a new behavior
            is needed to execute the new or the old functions.
        </p><p>
            The easiest way to do this, is to extend the current field files. For this it is necessary
            to create a new Backend extension file that defines the new functions and create also
            Drivers extensions that implement these new functions for each field. These new drivers
            will only need to implement the new functions since the original drivers takes care of
            the standard functions. All these new files do not need a constructor as they will
            be loaded as a base for the Backend object and the drivers.
        </p><p>
            The only restrictions are that the functions should be named different than the ones
            on the Backend and Drivers, otherwise they will be overwritten with current objects.
        </p><p>
            Put the new Backend extension into the <code class="filename">DynamicField</code> directory (e.g.
            <code class="filename">/$OTRS_HOME/Kernel/System/DynamicField/NewPackageBackend.pm</code> and its Drivers in
            <code class="filename">/$OTRS_HOME/Kernel/System/DynamicField/Driver/NewPackage*.pm</code>).
        </p><p>
            New behaviors only need a small setting in the extensions configuration file.
        </p><p>
            To create new Backend functions is needed to:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>
                    Create a New Backend extension module
                </p><p>
                    To define only the new functions.
                </p></li><li class="listitem"><p>
                    Create the Dynamic Fields Driver extensions
                </p><p>
                    To implement only the new functions.
                </p></li><li class="listitem"><p>
                    Implement New Dynamic Fields functions in the Frontend Modules
                </p><p>
                    To be able to use the new Dynamic Fields functions.
                </p></li><li class="listitem"><p>
                    Create a Configuration File
                </p><p>
                    To register the new backend and drivers extensions and behaviors.
                </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-options-extend-other"></a>Other Extensions</h5></div></div></div><p>
            Other extensions could be a combination of the above examples.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-new-field"></a>Creating A New Dynamic Field</h4></div></div></div><p>
        To illustrate this process a new Dynamic Field "Password" will be created. This new Dynamic
        Field Type will show a New password field to Ticket or Article objects. Since is very
        similar to a Text Dynamic Field we will use the <code class="literal">Base</code> and
        <code class="literal">BaseText</code> Drivers as a basis to build this new field.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            This new password field implementation is just for educational purposes, it does not
            provide any level of security and is not recommended for production systems.
        </p></div><p>
        To create this new Dynamic Field we will create 4 files: a Configuration File (XML),
        to register the modules, an Admin Dialog Module (Perl), to setup the field options, a
        template module, for the Admin Dialog and a Dynamic Field Driver (Perl).
    </p><p>
        File Structure:
    </p><pre class="programlisting">
$HOME (e. g. /opt/otrs/)
|
...
|--/Kernel/
|   |--/Config/
|   |   |--/Files/
|   |   |   |DynamicFieldPassword.xml
...
|   |--/Modules/
|   |   |AdminDynamicFieldPassword.pm
...
|   |--/Output/
|   |   |--/HTML/
|   |   |   |--/Standard/
|   |   |   |   |AdminDynamicFieldPassword.tt
...
|   |--/System/
|   |   |--/DynamicField/
|   |   |   |--/Driver/
|   |   |   |   |Password.pm
...
        </pre><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-new-field-files"></a>Dynamic Field Password files</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-config"></a>Dynamic Field Configuration File Example</h6></div></div></div><p>
        The configuration files are used to register the Dynamic Field Types (Driver) and
        the Object Type Drivers for the <code class="literal">BackendObject</code>. They also store standard registrations for
        Admin Modules in the framework.
    </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-config-code"></a>Code Example:</h6></div></div></div><p>
                In this section a configuration file for password Dynamic Field is shown and
                explained.
            </p><p>
            </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;otrs_config version="1.0" init="Application"&gt;
            </pre><p>
        </p><p>
            This is the normal header for a configuration file.
        </p><p>
            </p><pre class="programlisting">
    &lt;ConfigItem Name="DynamicFields::Driver###Password" Required="0" Valid="1"&gt;
        &lt;Description Translatable="1"&gt;DynamicField backend registration.&lt;/Description&gt;
        &lt;Group&gt;DynamicFieldPassword&lt;/Group&gt;
        &lt;SubGroup&gt;DynamicFields::Backend::Registration&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;Hash&gt;
                &lt;Item Key="DisplayName" Translatable="1"&gt;Password&lt;/Item&gt;
                &lt;Item Key="Module"&gt;Kernel::System::DynamicField::Driver::Password&lt;/Item&gt;
                &lt;Item Key="ConfigDialog"&gt;AdminDynamicFieldPassword&lt;/Item&gt;
            &lt;/Hash&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            This setting registers the Password Dynamic Field Driver for the Backend module so it
            can be included in the list of available Dynamic Fields Types. It also specify its own
            Admin Dialog in the key <code class="literal">ConfigDialog</code>. This key is used by the Master Dynamic Field
            Admin Module to manage this new Dynamic Field Type.
        </p><p>
            </p><pre class="programlisting">
    &lt;ConfigItem Name="Frontend::Module###AdminDynamicFieldPassword" Required="0" Valid="1"&gt;
        &lt;Description Translatable="1"&gt;Frontend module registration for the agent interface.&lt;/Description&gt;
        &lt;Group&gt;DynamicFieldPassword&lt;/Group&gt;
        &lt;SubGroup&gt;Frontend::Admin::ModuleRegistration&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;FrontendModuleReg&gt;
                &lt;Group&gt;admin&lt;/Group&gt;
                &lt;Description&gt;Admin&lt;/Description&gt;
                &lt;Title Translatable="1"&gt;Dynamic Fields Text Backend GUI&lt;/Title&gt;
                &lt;Loader&gt;
                    &lt;JavaScript&gt;Core.Agent.Admin.DynamicField.js&lt;/JavaScript&gt;
                &lt;/Loader&gt;
            &lt;/FrontendModuleReg&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            This is a standard module registration for the Password Admin Dialog in the Admin
            Interface.
        </p><p>
            </p><pre class="programlisting">
&lt;/otrs_config&gt;
            </pre><p>
        </p><p>
            Standard closure of a configuration file.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module"></a>Dynamic Field Admin Dialog Example</h6></div></div></div><p>
        The Admin Dialogs are standard Admin modules to manage (add or edit) the Dynamic Fields.
    </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module-code"></a>Code Example:</h6></div></div></div><p>
                In this section an Admin Dialog for password dynamic field is shown and
                explained.
            </p><p>
            </p><pre class="programlisting">
# --
# Kernel/Modules/AdminDynamicFieldPassword.pm - provides a dynamic fields password config view for admins
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::Modules::AdminDynamicFieldPassword;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(:all);
use Kernel::System::Valid;
use Kernel::System::CheckItem;
use Kernel::System::DynamicField;
            </pre><p>
        </p><p>
            This is common header that can be found in common OTRS modules. The class/package
            name is declared via the <code class="literal">package</code> keyword.
        </p><p>
            </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {%Param};
    bless( $Self, $Type );

    for (qw(ParamObject LayoutObject LogObject ConfigObject)) {
        if ( !$Self-&gt;{$_} ) {
            $Self-&gt;{LayoutObject}-&gt;FatalError( Message =&gt; "Got no $_!" );
        }
    }

    # create additional objects
    $Self-&gt;{ValidObject} = Kernel::System::Valid-&gt;new( %{$Self} );

    $Self-&gt;{DynamicFieldObject} = Kernel::System::DynamicField-&gt;new( %{$Self} );

    # get configured object types
    $Self-&gt;{ObjectTypeConfig} = $Self-&gt;{ConfigObject}-&gt;Get('DynamicFields::ObjectType');

    # get the fields config
    $Self-&gt;{FieldTypeConfig} = $Self-&gt;{ConfigObject}-&gt;Get('DynamicFields::Backend') || {};

    $Self-&gt;{DefaultValueMask} = '****';
    return $Self;
}
            </pre><p>
        </p><p>
            The constructor <code class="literal">new</code> creates a new instance of the class. According to the coding
            guidelines objects of other classes that are needed in this module have to be created in <code class="literal">new</code>.
        </p><p>
            </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{Subaction} eq 'Add' ) {
        return $Self-&gt;_Add(
            %Param,
        );
    }
    elsif ( $Self-&gt;{Subaction} eq 'AddAction' ) {

        # challenge token check for write action
        $Self-&gt;{LayoutObject}-&gt;ChallengeTokenCheck();

        return $Self-&gt;_AddAction(
            %Param,
        );
    }
    if ( $Self-&gt;{Subaction} eq 'Change' ) {

        return $Self-&gt;_Change(
            %Param,
        );
    }
    elsif ( $Self-&gt;{Subaction} eq 'ChangeAction' ) {

        # challenge token check for write action
        $Self-&gt;{LayoutObject}-&gt;ChallengeTokenCheck();

        return $Self-&gt;_ChangeAction(
            %Param,
        );
    }

    return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
        Message =&gt; "Undefined subaction.",
    );
}
            </pre><p>
        </p><p>
            <code class="literal">Run</code> is the default function to be called by the web request. We
            try to make this function as simple as possible and let the helper functions to do
            the "hard" work.
        </p><p>
            </p><pre class="programlisting">
sub _Add {
    my ( $Self, %Param ) = @_;

    my %GetParam;
    for my $Needed (qw(ObjectType FieldType FieldOrder)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$Needed ) {

            return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
                Message =&gt; "Need $Needed",
            );
        }
    }

    # get the object type and field type display name
    my $ObjectTypeName = $Self-&gt;{ObjectTypeConfig}-&gt;{ $GetParam{ObjectType} }-&gt;{DisplayName} || '';
    my $FieldTypeName  = $Self-&gt;{FieldTypeConfig}-&gt;{ $GetParam{FieldType} }-&gt;{DisplayName}   || '';

    return $Self-&gt;_ShowScreen(
        %Param,
        %GetParam,
        Mode           =&gt; 'Add',
        ObjectTypeName =&gt; $ObjectTypeName,
        FieldTypeName  =&gt; $FieldTypeName,
    );
}
            </pre><p>
        </p><p>
            <code class="code">_Add</code> function  is also pretty simple, it just get some parameters
            from the web request and call the <code class="code">_ShowScreen()</code> function. Normally
            this function is not needed to be modified.
        </p><p>
            </p><pre class="programlisting">
sub _AddAction {
    my ( $Self, %Param ) = @_;

    my %Errors;
    my %GetParam;

    for my $Needed (qw(Name Label FieldOrder)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$GetParam{$Needed} ) {
            $Errors{ $Needed . 'ServerError' }        = 'ServerError';
            $Errors{ $Needed . 'ServerErrorMessage' } = 'This field is required.';
        }
    }

    if ( $GetParam{Name} ) {

        # check if name is alphanumeric
        if ( $GetParam{Name} !~ m{\A ( ?: [a-zA-Z] | \d )+ \z}xms ) {

            # add server error error class
            $Errors{NameServerError} = 'ServerError';
            $Errors{NameServerErrorMessage} =
                'The field does not contain only ASCII letters and numbers.';
        }

        # check if name is duplicated
        my %DynamicFieldsList = %{
            $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldList(
                Valid      =&gt; 0,
                ResultType =&gt; 'HASH',
                )
        };

        %DynamicFieldsList = reverse %DynamicFieldsList;

        if ( $DynamicFieldsList{ $GetParam{Name} } ) {

            # add server error error class
            $Errors{NameServerError}        = 'ServerError';
            $Errors{NameServerErrorMessage} = 'There is another field with the same name.';
        }
    }

    if ( $GetParam{FieldOrder} ) {

        # check if field order is numeric and positive
        if ( $GetParam{FieldOrder} !~ m{\A ( ?: \d )+ \z}xms ) {

            # add server error error class
            $Errors{FieldOrderServerError}        = 'ServerError';
            $Errors{FieldOrderServerErrorMessage} = 'The field must be numeric.';
        }
    }

    for my $ConfigParam (
        qw(
        ObjectType ObjectTypeName FieldType FieldTypeName DefaultValue ValidID ShowValue
        ValueMask
        )
        )
    {
        $GetParam{$ConfigParam} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $ConfigParam );
    }

    # uncorrectable errors
    if ( !$GetParam{ValidID} ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Need ValidID",
        );
    }

    # return to add screen if errors
    if (%Errors) {

        return $Self-&gt;_ShowScreen(
            %Param,
            %Errors,
            %GetParam,
            Mode =&gt; 'Add',
        );
    }

    # set specific config
    my $FieldConfig = {
        DefaultValue =&gt; $GetParam{DefaultValue},
        ShowValue    =&gt; $GetParam{ShowValue},
        ValueMask    =&gt; $GetParam{ValueMask} || $Self-&gt;{DefaultValueMask},
    };

    # create a new field
    my $FieldID = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldAdd(
        Name       =&gt; $GetParam{Name},
        Label      =&gt; $GetParam{Label},
        FieldOrder =&gt; $GetParam{FieldOrder},
        FieldType  =&gt; $GetParam{FieldType},
        ObjectType =&gt; $GetParam{ObjectType},
        Config     =&gt; $FieldConfig,
        ValidID    =&gt; $GetParam{ValidID},
        UserID     =&gt; $Self-&gt;{UserID},
    );

    if ( !$FieldID ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Could not create the new field",
        );
    }

    return $Self-&gt;{LayoutObject}-&gt;Redirect(
        OP =&gt; "Action=AdminDynamicField",
    );
}
            </pre><p>
        </p><p>
            The <code class="code">_AddAction</code> function gets the configuration parameters from
            a new dynamic field, and it validates that the Dynamic Field name only contains letters and
            numbers. This function could validate any other parameter.
        </p><p>
            <code class="literal">Name</code>, <code class="literal">Label</code>, <code class="literal">FieldOrder</code>, <code class="literal">Validity</code> are common parameters for all Dynamic Fields and they
            are required. Each Dynamic Field has its specific configuration that must contain at
            least the <code class="literal">DefaultValue</code> parameter. In this case it also have
            <code class="literal">ShowValue</code> and <code class="literal">ValueMask</code> parameters for Password field.
        </p><p>
            If the field has the ability to store a fixed list of values they should be stored
            in the <code class="literal">PossibleValues</code> parameter inside the specific configuration hash.
        </p><p>
            As in other Admin Modules, if a parameter is not valid this function returns to the
            Add screen highlighting the erroneous form fields.
        </p><p>
            If all the parameters are correct it creates a new Dynamic Field.
        </p><p>
            </p><pre class="programlisting">
sub _Change {
    my ( $Self, %Param ) = @_;

    my %GetParam;
    for my $Needed (qw(ObjectType FieldType)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$Needed ) {

            return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
                Message =&gt; "Need $Needed",
            );
        }
    }

    # get the object type and field type display name
    my $ObjectTypeName = $Self-&gt;{ObjectTypeConfig}-&gt;{ $GetParam{ObjectType} }-&gt;{DisplayName} || '';
    my $FieldTypeName  = $Self-&gt;{FieldTypeConfig}-&gt;{ $GetParam{FieldType} }-&gt;{DisplayName}   || '';

    my $FieldID = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; 'ID' );

    if ( !$FieldID ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Need ID",
        );
    }

    # get dynamic field data
    my $DynamicFieldData = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldGet(
        ID =&gt; $FieldID,
    );

    # check for valid dynamic field configuration
    if ( !IsHashRefWithData($DynamicFieldData) ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Could not get data for dynamic field $FieldID",
        );
    }

    my %Config = ();

    # extract configuration
    if ( IsHashRefWithData( $DynamicFieldData-&gt;{Config} ) ) {
        %Config = %{ $DynamicFieldData-&gt;{Config} };
    }

    return $Self-&gt;_ShowScreen(
        %Param,
        %GetParam,
        %${DynamicFieldData},
        %Config,
        ID             =&gt; $FieldID,
        Mode           =&gt; 'Change',
        ObjectTypeName =&gt; $ObjectTypeName,
        FieldTypeName  =&gt; $FieldTypeName,
    );
}
            </pre><p>
        </p><p>
            The <code class="code">_Change</code> function is very similar to the <code class="code">_Add</code> function but since this function is
            used to edit an existing field it needs to validated the <code class="literal">FieldID</code> parameter and gather
            the current Dynamic Field data.
        </p><p>
            </p><pre class="programlisting">
sub _ChangeAction {
    my ( $Self, %Param ) = @_;

    my %Errors;
    my %GetParam;

    for my $Needed (qw(Name Label FieldOrder)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$GetParam{$Needed} ) {
            $Errors{ $Needed . 'ServerError' }        = 'ServerError';
            $Errors{ $Needed . 'ServerErrorMessage' } = 'This field is required.';
        }
    }

    my $FieldID = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; 'ID' );
    if ( !$FieldID ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Need ID",
        );
    }

    if ( $GetParam{Name} ) {

        # check if name is lowercase
        if ( $GetParam{Name} !~ m{\A ( ?: [a-zA-Z] | \d )+ \z}xms ) {

            # add server error error class
            $Errors{NameServerError} = 'ServerError';
            $Errors{NameServerErrorMessage} =
                'The field does not contain only ASCII letters and numbers.';
        }

        # check if name is duplicated
        my %DynamicFieldsList = %{
            $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldList(
                Valid      =&gt; 0,
                ResultType =&gt; 'HASH',
                )
        };

        %DynamicFieldsList = reverse %DynamicFieldsList;

        if (
            $DynamicFieldsList{ $GetParam{Name} } &amp;&amp;
            $DynamicFieldsList{ $GetParam{Name} } ne $FieldID
            )
        {

            # add server error class
            $Errors{NameServerError}        = 'ServerError';
            $Errors{NameServerErrorMessage} = 'There is another field with the same name.';
        }
    }

    if ( $GetParam{FieldOrder} ) {

        # check if field order is numeric and positive
        if ( $GetParam{FieldOrder} !~ m{\A ( ?: \d )+ \z}xms ) {

            # add server error error class
            $Errors{FieldOrderServerError}        = 'ServerError';
            $Errors{FieldOrderServerErrorMessage} = 'The field must be numeric.';
        }
    }

    for my $ConfigParam (
        qw(
        ObjectType ObjectTypeName FieldType FieldTypeName DefaultValue ValidID ShowValue
        ValueMask
        )
        )
    {
        $GetParam{$ConfigParam} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $ConfigParam );
    }

    # uncorrectable errors
    if ( !$GetParam{ValidID} ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Need ValidID",
        );
    }

    # get dynamic field data
    my $DynamicFieldData = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldGet(
        ID =&gt; $FieldID,
    );

    # check for valid dynamic field configuration
    if ( !IsHashRefWithData($DynamicFieldData) ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Could not get data for dynamic field $FieldID",
        );
    }

    # return to change screen if errors
    if (%Errors) {

        return $Self-&gt;_ShowScreen(
            %Param,
            %Errors,
            %GetParam,
            ID   =&gt; $FieldID,
            Mode =&gt; 'Change',
        );
    }

    # set specific config
    my $FieldConfig = {
        DefaultValue =&gt; $GetParam{DefaultValue},
        ShowValue    =&gt; $GetParam{ShowValue},
        ValueMask    =&gt; $GetParam{ValueMask},
    };

    # update dynamic field (FieldType and ObjectType cannot be changed; use old values)
    my $UpdateSuccess = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldUpdate(
        ID         =&gt; $FieldID,
        Name       =&gt; $GetParam{Name},
        Label      =&gt; $GetParam{Label},
        FieldOrder =&gt; $GetParam{FieldOrder},
        FieldType  =&gt; $DynamicFieldData-&gt;{FieldType},
        ObjectType =&gt; $DynamicFieldData-&gt;{ObjectType},
        Config     =&gt; $FieldConfig,
        ValidID    =&gt; $GetParam{ValidID},
        UserID     =&gt; $Self-&gt;{UserID},
    );

    if ( !$UpdateSuccess ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Could not update the field $GetParam{Name}",
        );
    }

    return $Self-&gt;{LayoutObject}-&gt;Redirect(
        OP =&gt; "Action=AdminDynamicField",
    );
}
            </pre><p>
        </p><p>
            <code class="code">_ChangeAction()</code> is very similar to
            <code class="code">_AddAction()</code>, but adapted for the update of an existing field
            instead of creating a new one.
        </p><p>
            </p><pre class="programlisting">
sub _ShowScreen {
    my ( $Self, %Param ) = @_;

    $Param{DisplayFieldName} = 'New';

    if ( $Param{Mode} eq 'Change' ) {
        $Param{ShowWarning}      = 'ShowWarning';
        $Param{DisplayFieldName} = $Param{Name};
    }

    # header
    my $Output = $Self-&gt;{LayoutObject}-&gt;Header();
    $Output .= $Self-&gt;{LayoutObject}-&gt;NavigationBar();

    # get all fields
    my $DynamicFieldList = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldListGet(
        Valid =&gt; 0,
    );

    # get the list of order numbers (is already sorted).
    my @DynamicfieldOrderList;
    for my $Dynamicfield ( @{$DynamicFieldList} ) {
        push @DynamicfieldOrderList, $Dynamicfield-&gt;{FieldOrder};
    }

    # when adding we need to create an extra order number for the new field
    if ( $Param{Mode} eq 'Add' ) {

        # get the last element from the order list and add 1
        my $LastOrderNumber = $DynamicfieldOrderList[-1];
        $LastOrderNumber++;

        # add this new order number to the end of the list
        push @DynamicfieldOrderList, $LastOrderNumber;
    }

    my $DynamicFieldOrderSrtg = $Self-&gt;{LayoutObject}-&gt;BuildSelection(
        Data          =&gt; \@DynamicfieldOrderList,
        Name          =&gt; 'FieldOrder',
        SelectedValue =&gt; $Param{FieldOrder} || 1,
        PossibleNone  =&gt; 0,
        Class         =&gt; 'W50pc Validate_Number',
    );

    my %ValidList = $Self-&gt;{ValidObject}-&gt;ValidList();

    # create the Validity select
    my $ValidityStrg = $Self-&gt;{LayoutObject}-&gt;BuildSelection(
        Data         =&gt; \%ValidList,
        Name         =&gt; 'ValidID',
        SelectedID   =&gt; $Param{ValidID} || 1,
        PossibleNone =&gt; 0,
        Translation  =&gt; 1,
        Class        =&gt; 'W50pc',
    );

    # define config field specific settings
    my $DefaultValue = ( defined $Param{DefaultValue} ? $Param{DefaultValue} : '' );

    # create the Show value select
    my $ShowValueStrg = $Self-&gt;{LayoutObject}-&gt;BuildSelection(
        Data =&gt; [ 'No', 'Yes' ],
        Name =&gt; 'ShowValue',
        SelectedValue =&gt; $Param{ShowValue} || 'No',
        PossibleNone  =&gt; 0,
        Translation   =&gt; 1,
        Class         =&gt; 'W50pc',
    );

    # generate output
    $Output .= $Self-&gt;{LayoutObject}-&gt;Output(
        TemplateFile =&gt; 'AdminDynamicFieldPassword',
        Data         =&gt; {
            %Param,
            ValidityStrg          =&gt; $ValidityStrg,
            DynamicFieldOrderSrtg =&gt; $DynamicFieldOrderSrtg,
            DefaultValue          =&gt; $DefaultValue,
            ShowValueStrg         =&gt; $ShowValueStrg,
            ValueMask             =&gt; $Param{ValueMask} || $Self-&gt;{DefaultValueMask},
        },
    );

    $Output .= $Self-&gt;{LayoutObject}-&gt;Footer();

    return $Output;
}

1;
            </pre><p>
        </p><p>
            The <code class="code">_ShowScreen</code> function is used to set and define the HTML
            elements and blocks from a template to generate the Admin Dialog HTML code.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module-template"></a>Dynamic Field Template for Admin Dialog Example</h6></div></div></div><p>
        The template is the place where the HTML code of the dialog is stored.
    </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module-template-code"></a>Code Example:</h6></div></div></div><p>
                In this section an Admin Dialog template for the password Dynamic Field is
                shown and explained.
            </p><p>
            </p><pre class="programlisting">
# --
# AdminDynamicFieldPassword.tt - provides HTML form for AdminDynamicFieldPassword
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --
            </pre><p>
        </p><p>
            This is common header that can be found in common OTRS modules.
        </p><p>
            </p><pre class="programlisting">
&lt;div class="MainBox ARIARoleMain LayoutFixedSidebar SidebarFirst"&gt;
    &lt;h1&gt;[% Translate("Dynamic Fields") | html %] - [% Translate(Data.ObjectTypeName) | html %]: [% Translate(Data.Mode) | html %] [% Translate(Data.FieldTypeName) | html %] [% Translate("Field") | html %]&lt;/h1&gt;

    &lt;div class="Clear"&gt;&lt;/div&gt;

    &lt;div class="SidebarColumn"&gt;
        &lt;div class="WidgetSimple"&gt;
            &lt;div class="Header"&gt;
                &lt;h2&gt;[% Translate("Actions") | html %]&lt;/h2&gt;
            &lt;/div&gt;
            &lt;div class="Content"&gt;
                &lt;ul class="ActionList"&gt;
                    &lt;li&gt;
                        &lt;a href="[% Env("Baselink") %]Action=AdminDynamicField" class="CallForAction"&gt;&lt;span&gt;[% Translate("Go back to overview") | html %]&lt;/span&gt;&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
            </pre><p>
        </p><p>
            This part of the code has the main box and also the actions side bar. No
            modifications are needed in this section.
        </p><p>
            </p><pre class="programlisting">
    &lt;div class="ContentColumn"&gt;
        &lt;form action="[% Env("CGIHandle") %]" method="post" class="Validate PreventMultipleSubmits"&gt;
            &lt;input type="hidden" name="Action" value="AdminDynamicFieldPassword" /&gt;
            &lt;input type="hidden" name="Subaction" value="[% Data.Mode | html %]Action" /&gt;
            &lt;input type="hidden" name="ObjectType" value="[% Data.ObjectType | html %]" /&gt;
            &lt;input type="hidden" name="FieldType" value="[% Data.FieldType | html %]" /&gt;
            &lt;input type="hidden" name="ID" value="[% Data.ID | html %]" /&gt;
            </pre><p>
        </p><p>
            In this section of the code is defined the right part of the dialog. Notice that the
            value of the <code class="literal">Action</code> hidden input must match with the name of the Admin Dialog.
        </p><p>
            </p><pre class="programlisting">
            &lt;div class="WidgetSimple"&gt;
                &lt;div class="Header"&gt;
                    &lt;h2&gt;[% Translate("General") | html %]&lt;/h2&gt;
                &lt;/div&gt;
                &lt;div class="Content"&gt;
                    &lt;div class="LayoutGrid ColumnsWithSpacing"&gt;
                        &lt;div class="Size1of2"&gt;
                            &lt;fieldset class="TableLike"&gt;
                                &lt;label class="Mandatory" for="Name"&gt;&lt;span class="Marker"&gt;*&lt;/span&gt; [% Translate("Name") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="Name" class="W50pc [% Data.NameServerError | html %] [% Data.ShowWarning | html %]  Validate_Alphanumeric" type="text" maxlength="200" value="[% Data.Name | html %]" name="Name"/&gt;
                                    &lt;div id="NameError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate("This field is required, and the value should be alphabetic and numeric characters only.") | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;div id="NameServerError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate(Data.NameServerErrorMessage) | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;p class="FieldExplanation"&gt;[% Translate("Must be unique and only accept alphabetic and numeric characters.") | html %]&lt;/p&gt;
                                    &lt;p class="Warning Hidden"&gt;[% Translate("Changing this value will require manual changes in the system.") | html %]&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;

                                &lt;label class="Mandatory" for="Label"&gt;&lt;span class="Marker"&gt;*&lt;/span&gt; [% Translate("Label") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="Label" class="W50pc [% Data.LabelServerError | html %] Validate_Required" type="text" maxlength="200" value="[% Data.Label | html %]" name="Label"/&gt;
                                    &lt;div id="LabelError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate("This field is required.") | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;div id="LabelServerError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate(Data.LabelServerErrorMessage) | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;p class="FieldExplanation"&gt;[% Translate("This is the name to be shown on the screens where the field is active.") | html %]&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;

                                &lt;label class="Mandatory" for="FieldOrder"&gt;&lt;span class="Marker"&gt;*&lt;/span&gt; [% Translate("Field order") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    [% Data.DynamicFieldOrderSrtg %]
                                    &lt;div id="FieldOrderError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate("This field is required and must be numeric.") | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;div id="FieldOrderServerError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate(Data.FieldOrderServerErrorMessage) | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;p class="FieldExplanation"&gt;[% Translate("This is the order in which this field will be shown on the screens where is active.") | html %]&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;
                            &lt;/fieldset&gt;
                        &lt;/div&gt;
                        &lt;div class="Size1of2"&gt;
                            &lt;fieldset class="TableLike"&gt;
                                &lt;label for="ValidID"&gt;[% Translate("Validity") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    [% Data.ValidityStrg %]
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;

                                &lt;div class="SpacingTop"&gt;&lt;/div&gt;
                                &lt;label for="FieldTypeName"&gt;[% Translate("Field type") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="FieldTypeName" readonly="readonly" class="W50pc" type="text" maxlength="200" value="[% Data.FieldTypeName | html %]" name="FieldTypeName"/&gt;
                                    &lt;div class="Clear"&gt;&lt;/div&gt;
                                &lt;/div&gt;

                                &lt;div class="SpacingTop"&gt;&lt;/div&gt;
                                &lt;label for="ObjectTypeName"&gt;[% Translate("Object type") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="ObjectTypeName" readonly="readonly" class="W50pc" type="text" maxlength="200" value="[% Data.ObjectTypeName | html %]" name="ObjectTypeName"/&gt;
                                    &lt;div class="Clear"&gt;&lt;/div&gt;
                                &lt;/div&gt;
                            &lt;/fieldset&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            </pre><p>
        </p><p>
            This first widget contains the common form attributes for the Dynamic Fields. For
            consistency with other Dynamic Fields is recommended to leave this part of the code
            unchanged.
        </p><p>
            </p><pre class="programlisting">
            &lt;div class="WidgetSimple"&gt;
                &lt;div class="Header"&gt;
                    &lt;h2&gt;[% Translate(Data.FieldTypeName) | html %] [% Translate("Field Settings") | html %]&lt;/h2&gt;
                &lt;/div&gt;
                &lt;div class="Content"&gt;
                    &lt;fieldset class="TableLike"&gt;

                        &lt;label for="DefaultValue"&gt;[% Translate("Default value") | html %]:&lt;/label&gt;
                        &lt;div class="Field"&gt;
                            &lt;input id="DefaultValue" class="W50pc" type="text" maxlength="200" value="[% Data.DefaultValue | html %]" name="DefaultValue"/&gt;
                            &lt;p class="FieldExplanation"&gt;[% Translate("This is the default value for this field.") | html %]&lt;/p&gt;
                        &lt;/div&gt;
                        &lt;div class="Clear"&gt;&lt;/div&gt;

                        &lt;label for="ShowValue"&gt;[% Translate("Show value") | html %]:&lt;/label&gt;
                        &lt;div class="Field"&gt;
                            [% Data.ShowValueStrg %]
                            &lt;p class="FieldExplanation"&gt;
                                [% Translate("To reveal the field value in non edit screens ( e.g. Ticket Zoom Screen )") | html %]
                            &lt;/p&gt;
                        &lt;/div&gt;
                        &lt;div class="Clear"&gt;&lt;/div&gt;

                        &lt;label for="ValueMask"&gt;[% Translate("Hidden value mask") | html %]:&lt;/label&gt;
                        &lt;div class="Field"&gt;
                            &lt;input id="ValueMask" class="W50pc" type="text" maxlength="200" value="[% Data.ValueMask | html %]" name="ValueMask"/&gt;
                            &lt;p class="FieldExplanation"&gt;
                                [% Translate("This is the alternate value to show if Show value is set to \"No\" ( Default: **** ).") | html %]
                            &lt;/p&gt;
                        &lt;/div&gt;
                        &lt;div class="Clear"&gt;&lt;/div&gt;

                    &lt;/fieldset&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            </pre><p>
        </p><p>
            The second widget has the Dynamic Field specific form attributes. This is the place
            where new attributes can be set and it could use JavaScript and AJAX technologies to
            make it more easy or friendly for the end user.
        </p><p>
            </p><pre class="programlisting">
            &lt;fieldset class="TableLike"&gt;
                &lt;div class="Field SpacingTop"&gt;
                    &lt;button type="submit" class="Primary" value="[% Translate("Save") | html %]"&gt;[% Translate("Save") | html %]&lt;/button&gt;
                    [% Translate("or") | html %]
                    &lt;a href="[% Env("Baselink") %]Action=AdminDynamicField"&gt;[% Translate("Cancel") | html %]&lt;/a&gt;
                &lt;/div&gt;
                &lt;div class="Clear"&gt;&lt;/div&gt;
            &lt;/fieldset&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;
[% WRAPPER JSOnDocumentComplete %]
&lt;script type="text/javascript"&gt;//&lt;![CDATA[
$('.ShowWarning').bind('change keyup', function (Event) {
    $('p.Warning').removeClass('Hidden');
});

Core.Agent.Admin.DynamicField.ValidationInit();
//]]&gt;&lt;/script&gt;
[% END %]
            </pre><p>
        </p><p>
            The final part of the file contains the "Submit" button and the "Cancel" link, as well
            as other needed JavaScript code.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-driver"></a>Dynamic Field Driver Example</h6></div></div></div><p>
        The driver <span class="emphasis"><em>is</em></span> the Dynamic Field. It contains several functions that
        are used wide in the OTRS framework. A driver can inherit some functions form base classes,
        for example <code class="literal">TextArea</code> driver inherits most of the functions from
        <code class="filename">Base.pm</code> and <code class="filename">BaseText.pm</code> and it only implements
        the functions that requires different logic or results. Checkbox field driver only inherits
        from <code class="filename">Base.pm</code> as all other functions are very different from any other
        Base driver.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            Please refer to the Perl On-line Documentation (POD) of the module
            <code class="filename">/Kernel/System/DynmicField/Backend.pm</code> to have the list of all attributes and possible
            return data for each function.
        </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-driver-code"></a>Code Example:</h6></div></div></div><p>
            In this section the Password Dynamic Field driver is shown and explained. This driver
            inherits some functions from <code class="filename">Base.pm</code> and <code class="filename">BaseText.pm</code> and only implements the functions
            that needs different results.
         </p><p>
            </p><pre class="programlisting">
# --
# Kernel/System/DynamicField/Driver/Password.pm - Driver for DynamicField Password backend
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::DynamicField::Driver::Password;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(:all);
use Kernel::System::DynamicFieldValue;

use base qw(Kernel::System::DynamicField::Driver::BaseText);

our @ObjectDependencies = (
    'Kernel::Config',
    'Kernel::System::DynamicFieldValue',
    'Kernel::System::Main',
);
            </pre><p>
        </p><p>
            This is the common header that can be found in common OTRS modules. The class/package
            name is declared via the <code class="literal">package</code> keyword. Notice that
            <code class="literal">BaseText</code> is used as base class.
        </p><p>
            </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # set field behaviors
    $Self-&gt;{Behaviors} = {
        'IsACLReducible'               =&gt; 0,
        'IsNotificationEventCondition' =&gt; 1,
        'IsSortable'                   =&gt; 0,
        'IsFiltrable'                  =&gt; 0,
        'IsStatsCondition'             =&gt; 1,
        'IsCustomerInterfaceCapable'   =&gt; 1,
    };

    # get the Dynamic Field Backend custom extensions
    my $DynamicFieldDriverExtensions
        = $Kernel::OM-&gt;Get('Kernel::Config')-&gt;Get('DynamicFields::Extension::Driver::Password');

    EXTENSION:
    for my $ExtensionKey ( sort keys %{$DynamicFieldDriverExtensions} ) {

        # skip invalid extensions
        next EXTENSION if !IsHashRefWithData( $DynamicFieldDriverExtensions-&gt;{$ExtensionKey} );

        # create a extension config shortcut
        my $Extension = $DynamicFieldDriverExtensions-&gt;{$ExtensionKey};

        # check if extension has a new module
        if ( $Extension-&gt;{Module} ) {

            # check if module can be loaded
            if (
                !$Kernel::OM-&gt;Get('Kernel::System::Main')-&gt;RequireBaseClass( $Extension-&gt;{Module} )
                )
            {
                die "Can't load dynamic fields backend module"
                    . " $Extension-&gt;{Module}! $@";
            }
        }

        # check if extension contains more behaviors
        if ( IsHashRefWithData( $Extension-&gt;{Behaviors} ) ) {

            %{ $Self-&gt;{Behaviors} } = (
                %{ $Self-&gt;{Behaviors} },
                %{ $Extension-&gt;{Behaviors} }
            );
        }
    }

    return $Self;
}
            </pre><p>
        </p><p>
            The constructor <code class="literal">new</code> creates a new instance of the class. According
            to the coding guidelines objects of other classes that are needed in this module have
            to be created in <code class="literal">new</code>.
        </p><p>
            It is important to define the behaviors correctly as the field might or might not be
            used in certain screens, functions that depends on behaviors that are not active for
            this particular field might not be needed to be implemented.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Drivers are created only by the <code class="literal">BackendObject</code> and not directly from any other
                module.
            </p></div><p>
        </p><pre class="programlisting">
sub EditFieldRender {
    my ( $Self, %Param ) = @_;

    # take config from field config
    my $FieldConfig = $Param{DynamicFieldConfig}-&gt;{Config};
    my $FieldName   = 'DynamicField_' . $Param{DynamicFieldConfig}-&gt;{Name};
    my $FieldLabel  = $Param{DynamicFieldConfig}-&gt;{Label};

    my $Value = '';

    # set the field value or default
    if ( $Param{UseDefaultValue} ) {
        $Value = ( defined $FieldConfig-&gt;{DefaultValue} ? $FieldConfig-&gt;{DefaultValue} : '' );
    }
    $Value = $Param{Value} if defined $Param{Value};

    # extract the dynamic field value from the web request
    my $FieldValue = $Self-&gt;EditFieldValueGet(
        %Param,
    );

    # set values from ParamObject if present
    if ( defined $FieldValue ) {
        $Value = $FieldValue;
    }

    # check and set class if necessary
    my $FieldClass = 'DynamicFieldText W50pc';
    if ( defined $Param{Class} &amp;&amp; $Param{Class} ne '' ) {
        $FieldClass .= ' ' . $Param{Class};
    }

    # set field as mandatory
    $FieldClass .= ' Validate_Required' if $Param{Mandatory};

    # set error css class
    $FieldClass .= ' ServerError' if $Param{ServerError};

    my $HTMLString = &lt;&lt;"EOF";
&lt;input type="password" class="$FieldClass" id="$FieldName" name="$FieldName" title="$FieldLabel" value="$Value" /&gt;
EOF

    if ( $Param{Mandatory} ) {
        my $DivID = $FieldName . 'Error';

        # for client side validation
        $HTMLString .= &lt;&lt;"EOF";
    &lt;div id="$DivID" class="TooltipErrorMessage"&gt;
        &lt;p&gt;
            \$Text{"This field is required."}
        &lt;/p&gt;
    &lt;/div&gt;
EOF
    }

    if ( $Param{ServerError} ) {

        my $ErrorMessage = $Param{ErrorMessage} || 'This field is required.';
        my $DivID = $FieldName . 'ServerError';

        # for server side validation
        $HTMLString .= &lt;&lt;"EOF";
    &lt;div id="$DivID" class="TooltipErrorMessage"&gt;
        &lt;p&gt;
            \$Text{"$ErrorMessage"}
        &lt;/p&gt;
    &lt;/div&gt;
EOF
    }

    # call EditLabelRender on the common Driver
    my $LabelString = $Self-&gt;EditLabelRender(
        %Param,
        DynamicFieldConfig =&gt; $Param{DynamicFieldConfig},
        Mandatory          =&gt; $Param{Mandatory} || '0',
        FieldName          =&gt; $FieldName,
    );

    my $Data = {
        Field =&gt; $HTMLString,
        Label =&gt; $LabelString,
    };

    return $Data;
}
            </pre><p>
        </p><p>
            This function is the responsible to create the HTML representation of the field and its
            label, and is used in the edit screens like <code class="literal">AgentTicketPhone</code>, <code class="literal">AgentTicketNote</code>, etc.
        </p><p>
            </p><pre class="programlisting">
sub DisplayValueRender {
    my ( $Self, %Param ) = @_;

    # set HTMLOutput as default if not specified
    if ( !defined $Param{HTMLOutput} ) {
        $Param{HTMLOutput} = 1;
    }

    my $Value;
    my $Title;

    # check if field is set to show password or not
    if (
        defined $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue}
        &amp;&amp; $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue} eq 'Yes'
        )
    {

        # get raw Title and Value strings from field value
        $Value = defined $Param{Value} ? $Param{Value} : '';
        $Title = $Value;
    }
    else {

        # show the mask and not the value
        $Value = $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ValueMask} || '';
        $Title = 'The value of this field is hidden.'
    }

    # HTMLOutput transformations
    if ( $Param{HTMLOutput} ) {
        $Value = $Param{LayoutObject}-&gt;Ascii2Html(
            Text =&gt; $Value,
            Max =&gt; $Param{ValueMaxChars} || '',
        );

        $Title = $Param{LayoutObject}-&gt;Ascii2Html(
            Text =&gt; $Title,
            Max =&gt; $Param{TitleMaxChars} || '',
        );
    }
    else {
        if ( $Param{ValueMaxChars} &amp;&amp; length($Value) &gt; $Param{ValueMaxChars} ) {
            $Value = substr( $Value, 0, $Param{ValueMaxChars} ) . '...';
        }
        if ( $Param{TitleMaxChars} &amp;&amp; length($Title) &gt; $Param{TitleMaxChars} ) {
            $Title = substr( $Title, 0, $Param{TitleMaxChars} ) . '...';
        }
    }

    # create return structure
    my $Data = {
        Value =&gt; $Value,
        Title =&gt; $Title,
    };

    return $Data;
}
            </pre><p>
        </p><p>
            <code class="code">DisplayValueRender()</code> function returns the field value as a plain
            text as well as its title (both can be translated). For this particular example we are
            checking if the password should be revealed or display a predefined mask by  a
            configuration parameter in the Dynamic Field.
        </p><p>
            </p><pre class="programlisting">
sub ReadableValueRender {
    my ( $Self, %Param ) = @_;

    my $Value;
    my $Title;

    # check if field is set to show password or not
    if (
        defined $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue}
        &amp;&amp; $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue} eq 'Yes'
        )
    {

        # get raw Title and Value strings from field value
        $Value = $Param{Value} // '';
        $Title = $Value;
    }
    else {

        # show the mask and not the value
        $Value = $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ValueMask} || '';
        $Title = 'The value of this field is hidden.'
    }

    # cut strings if needed
    if ( $Param{ValueMaxChars} &amp;&amp; length($Value) &gt; $Param{ValueMaxChars} ) {
        $Value = substr( $Value, 0, $Param{ValueMaxChars} ) . '...';
    }
    if ( $Param{TitleMaxChars} &amp;&amp; length($Title) &gt; $Param{TitleMaxChars} ) {
        $Title = substr( $Title, 0, $Param{TitleMaxChars} ) . '...';
    }

    # create return structure
    my $Data = {
        Value =&gt; $Value,
        Title =&gt; $Title,
    };

    return $Data;
}
            </pre><p>
        </p><p>
            This function is similar to <code class="code">DisplayValueRender()</code> but is used  in
            places where there is no <code class="literal">LayoutObject</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-driver-other-functions"></a>Other Functions:</h6></div></div></div><p>
            The following are other functions that are might needed if the new Dynamic Field does
            not inherit from other classes. To see the complete code of this functions please take a
            look directly into the files <code class="filename">Kernel/System/DynamicField/Driver/Base.pm</code> and
            <code class="filename">Kernel/System/DynamicField/Driver/BaseText.pm</code>
        </p><p>
            </p><pre class="programlisting">
sub ValueGet { ... }
            </pre><p>
        </p><p>
            This function retrieves the value from the field on a specified Object. In this case we
            are returning the first text value, since the field only stores one text value at time.
        </p><p>
            </p><pre class="programlisting">
sub ValueSet { ... }
            </pre><p>
        </p><p>
            <code class="code">ValueSet()</code> is used to store a Dynamic Field value. In this case
            this field only stores one text type value. Other fields could store more than one
            value on either <code class="literal">ValueText</code>, <code class="literal">ValueDateTime</code> or <code class="literal">ValueInt</code> format.
        </p><p>
            </p><pre class="programlisting">
sub ValueDelete { ... }
            </pre><p>
        </p><p>
            This function is used to delete one field value attached to a particular object ID.
            For example if the instance of an object is to be deleted, then there is no reason to
            have the field value stored in the database for that particular object instance.
        </p><p>
            </p><pre class="programlisting">
sub AllValuesDelete { ... }
            </pre><p>
        </p><p>
            <code class="code">AllValuesDelete()</code> function is used to delete all values from a
            certain Dynamic Field. This function is very useful when a Dynamic Field is going to be
            deleted.
        </p><p>
            </p><pre class="programlisting">
sub ValueValidate { ... }
            </pre><p>
        </p><p>
            The <code class="code">ValueValidate()</code> function is used to check if the value is
            consistent to its type.
        </p><p>
            </p><pre class="programlisting">
sub SearchSQLGet { ... }
            </pre><p>
        </p><p>
            This function is used by <code class="literal">TicketSearch</code> core module to build the internal query to search
            for a ticket based on this field as a search parameter.
        </p><p>
            </p><pre class="programlisting">
sub SearchSQLOrderFieldGet { ... }
            </pre><p>
        </p><p>
            The <code class="literal">SearchSQLOrderFieldGet</code> is also a helper for <code class="literal">TicketSearch</code>
            module. <code class="literal">$Param{TableAlias}</code> should be kept and <code class="literal">value_text</code> could be replaced with
            <code class="literal">value_date</code> or <code class="literal">value_int</code> depending on the field.
        </p><p>
            </p><pre class="programlisting">
sub EditFieldValueGet { ... }
            </pre><p>
        </p><p>
            <code class="code">EditFieldValueGet()</code> is a function used in the edit screens of OTRS
            and its purpose is to get the value of the field, either from a template like generic
            agent profile or from a web request. This function gets the web request in the
            <code class="literal">$Param{ParamObject}</code>, that is a copy of the <code class="literal">ParamObject</code> of the Frontend Module or screen.
        </p><p>
            There are two return formats for this function, the normal: that is just the raw value
            or a structure: that is the pair field name =&gt; field value. For example a Date Dynamic
            Field returns normally the date as string, and if it should return a structure it
            returns a pair for each part of the date in the hash.
        </p><p>
            If the result should be a structure then, normally this is used to store its values
            in a template, like a generic agent profile. For example a date field uses several HTML
            components to build the field, like the "Used" check-box and selects for year, month,
            day etc.
        </p><p>
            </p><pre class="programlisting">
sub EditFieldValueValidate { ... }
            </pre><p>
        </p><p>
            This function should provide at least a method to validate if the field is empty, and
            return an error if the field is empty and mandatory, but it can also do more validations
            for other kind of fields, like if the option selected is valid, or if a date should be
            only in the past etc. It can provide a custom error message also.
        </p><p>
            </p><pre class="programlisting">
sub SearchFieldRender { ... }
            </pre><p>
        </p><p>
            This function is used by ticket search dialog and it is similar to
            <code class="code">EditFieldRander()</code>, but normally on a search screen small changes
            has to be done for all fields. For this example we use a HTML text input instead of a
            password input. In other fields like Dropdown field is displayed as a Multiple select in
            order to let the user search for more than one value at a time.
        </p><p>
            </p><pre class="programlisting">
sub SearchFieldValueGet { ... }
            </pre><p>
        </p><p>
            Very similar to <code class="code">EditFieldValueGet()</code>, but uses a different name
            prefix, adapted for the search dialog screen.
        </p><p>
            </p><pre class="programlisting">
sub SearchFieldParameterBuild { ... }
            </pre><p>
        </p><p>
            <code class="code">SearchFieldParameterBuild()</code> is used also by the ticket search
            dialog to set the correct operator and value to do the search on this field. It also
            returns how the value should be displayed in the used search attributes in the results
            page.
        </p><p>
            </p><pre class="programlisting">
sub StatsFieldParameterBuild { ... }
            </pre><p>
        </p><p>
            This function is used by the stats modules. It includes the field definition in the
            stats format. For fields with fixed values it also includes all this possible values
            and if they can be translated, take a look to the <code class="literal">BaseSelect</code> driver code for an example
            how to implement those.
        </p><p>
            </p><pre class="programlisting">
sub StatsSearchFieldParameterBuild { ... }
            </pre><p>
        </p><p>
            <code class="code">StatsSearchFieldParameterBuild()</code> is very similar to the
            <code class="code">SearchFieldParameterBuild()</code>. The difference is that the
            <code class="code">SearchFieldParameterBuild()</code> gets the value from the search profile
            and this one gets the value directly from its parameters.
        </p><p>
            This function is used by statistics module.
        </p><p>
            </p><pre class="programlisting">
sub TemplateValueTypeGet { ... }
            </pre><p>
        </p><p>
            The <code class="code">TemplateValueTypeGet()</code> function is used to know how the
            Dynamic Field values stored on a profile should be retrieved, as a SCALAR or as an
            ARRAY, and it also defines the correct name of the field in the profile.
        </p><p>
            </p><pre class="programlisting">
sub RandomValueSet { ... }
            </pre><p>
        </p><p>
            This function is used by <code class="filename">otrs.FillDB.pl</code> script to populate the database with some test
            and random data. The value inserted by this function is not really relevant. The only
            restriction is that the value must be compatible with the field value type.
        </p><p>
            </p><pre class="programlisting">
sub ObjectMatch { ... }
            </pre><p>
        </p><p>
            Used by the notification modules. This function returns 1 if the field is present in the
            <code class="literal">$Param{ObjectAttributes}</code> parameter and if it matches the given value.
        </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-extend"></a>Creating a Dynamic Field Functionality Extension</h4></div></div></div><p>
        To illustrate this process a new Dynamic Field functionality extension for the function
        <span class="emphasis"><em>Foo</em></span> will be added to the Backend Object as well as in the Text
        field driver.
    </p><p>
        To create this extension we will create 3 files: a Configuration File (XML)
        to register the modules, a Backend extension (Perl) to define the new function, and a
        Text field Driver extension (Perl) that implements the new function for Text fields.
    </p><p>
        File Structure:
    </p><pre class="programlisting">
$HOME (e. g. /opt/otrs/)
|
...
|--/Kernel/
|   |--/Config/
|   |   |--/Files/
|   |   |   |DynamicFieldFooExtension.xml
...
|   |--/System/
|   |   |--/DynamicField/
|   |   |   FooExtensionBackend.pm
|   |   |   |--/Driver/
|   |   |   |   |FooExtensionText.pm
...
        </pre><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extension-full-example-files"></a>Dynamic Field Foo Extension files</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-config"></a>Dynamic Field Extension Configuration File Example</h6></div></div></div><p>
        The configuration files are used to register the extensions for the Backend and Drivers as
        well as new behaviors for each drivers.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            If a driver is extended with a new function, the backend will need also an extension for
            that function.
        </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-config-code"></a>Code Example:</h6></div></div></div><p>
            In this section a configuration file for <code class="literal">Foo</code> extension is shown and explained.
        </p><p>
            </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;otrs_config version="1.0" init="Application"&gt;
            </pre><p>
        </p><p>
            This is the normal header for a configuration file.
        </p><p>
            </p><pre class="programlisting">
    &lt;ConfigItem Name="DynamicFields::Extension::Backend###100-Foo" Required="0" Valid="1"&gt;
        &lt;Description Translatable="1"&gt;Dynamic Fields Extension.&lt;/Description&gt;
        &lt;Group&gt;DynamicFieldFooExtension&lt;/Group&gt;
        &lt;SubGroup&gt;DynamicFields::Extension::Registration&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;Hash&gt;
                &lt;Item Key="Module"&gt;Kernel::System::DynamicField::FooExtensionBackend&lt;/Item&gt;
            &lt;/Hash&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            This setting registers the extension in the <code class="literal">Backend</code> object. The module will be loaded
            from <code class="literal">Backend</code> as a base class.
        </p><p>
            </p><pre class="programlisting">
    &lt;ConfigItem Name="DynamicFields::Extension::Driver::Text###100-Foo" Required="0" Valid="1"&gt;
        &lt;Description Translatable="1"&gt;Dynamic Fields Extension.&lt;/Description&gt;
        &lt;Group&gt;DynamicFieldFooExtension&lt;/Group&gt;
        &lt;SubGroup&gt;DynamicFields::Extension::Registration&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;Hash&gt;
                &lt;Item Key="Module"&gt;Kernel::System::DynamicField::Driver::FooExtensionText&lt;/Item&gt;
                &lt;Item Key="Behaviors"&gt;
                    &lt;Hash&gt;
                        &lt;Item Key="Foo"&gt;1&lt;/Item&gt;
                    &lt;/Hash&gt;
                &lt;/Item&gt;
            &lt;/Hash&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            This is the registration for an extension in the <code class="literal">Text</code> Dynamic Field Driver. The module
            will be loaded as a base class in the Driver. Notice also that new behaviors can be
            specified. These extended behaviors will be added to the behaviors that the Driver has
            out of the box, therefore a call to <code class="code">HasBehavior()</code> to check for these new behaviors will
            be totally transparent.
        </p><p>
            </p><pre class="programlisting">
&lt;/otrs_config&gt;
            </pre><p>
        </p><p>
            Standard closure of a configuration file.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-backend"></a>Dynamic Field Backend Extension Example</h6></div></div></div><p>
        Backend extensions will be loaded transparently into the Backend itself as a base class. All
        defined object and properties from the Backend will be accessible in the extension.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            All new functions defined in the Backend extension should be implemented in a Driver
            extension.
        </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-backend-code"></a>Code Example:</h6></div></div></div><p>
            In this section the <code class="literal">Foo</code> extension for Backend is shown and explained. The
            extension only defines the function <code class="code">Foo()</code>.
         </p><p>
            </p><pre class="programlisting">
# --
# Kernel/System/DynamicField/FooExtensionBackend.pm - Extension for DynamicField backend
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::DynamicField::FooExtensionBackend;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(:all);

=head1 NAME

Kernel::System::DynamicField::FooExtensionBackend

=head1 SYNOPSIS

DynamicFields Extension for Backend

=head1 PUBLIC INTERFACE

=over 4

=cut
            </pre><p>
        </p><p>
            This is common header that can be found in common OTRS modules. The class/package
            name is declared via the <code class="literal">package</code> keyword.
        </p><p>
            </p><pre class="programlisting">
=item Foo()

Testing function: returns 1 if function is available on a Dynamic Field driver.

    my $Success = $BackendObject-&gt;Foo(
        DynamicFieldConfig   =&gt; $DynamicFieldConfig,      # complete config of the DynamicField
    );

Returns:
    $Success = 1;       # or undef

=cut

sub Foo {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Needed (qw(DynamicFieldConfig)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Need $Needed!",
            );

            return;
        }
    }

    # check DynamicFieldConfig (general)
    if ( !IsHashRefWithData( $Param{DynamicFieldConfig} ) ) {
        $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
            Priority =&gt; 'error',
            Message  =&gt; "The field configuration is invalid",
        );

        return;
    }

    # check DynamicFieldConfig (internally)
    for my $Needed (qw(ID FieldType ObjectType)) {
        if ( !$Param{DynamicFieldConfig}-&gt;{$Needed} ) {
            $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Need $Needed in DynamicFieldConfig!",
            );

            return;
        }
    }

    # set the dynamic field specific backend
    my $DynamicFieldBackend = 'DynamicField' . $Param{DynamicFieldConfig}-&gt;{FieldType} . 'Object';

    if ( !$Self-&gt;{$DynamicFieldBackend} ) {
        $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
            Priority =&gt; 'error',
            Message  =&gt; "Backend $Param{DynamicFieldConfig}-&gt;{FieldType} is invalid!",
        );

        return;
    }

    # verify if function is available
    return if !$Self-&gt;{$DynamicFieldBackend}-&gt;can('Foo');

    # call HasBehavior on the specific backend
    return $Self-&gt;{$DynamicFieldBackend}-&gt;Foo(%Param);
}
            </pre><p>
        </p><p>
            The function <code class="code">Foo()</code> is only used for test purposes. First it checks
            the Dynamic Field configuration, then it checks if the Dynamic Field Driver (type)
            exists and was already loaded. To prevent the function call on a driver where is not
            defined it first check if the driver can execute the function, then executes the
            function in the driver passing all parameters.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                It is also possible to skip the step that tests if the Driver can execute the
                function. To do that it is necessary to implement a mechanism in the Frontend module
                to require a special behavior on the Dynamic Field, and only after call the function
                in the Backend object.
            </p></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-driver"></a>Dynamic Field Driver Extension Example</h6></div></div></div><p>
        Driver extensions will be loaded transparently into the Driver itself as a base class. All
        defined object and properties from the Driver will be accessible in the extension.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            All new functions implemented in the Driver extension should be defined in a Backend
            extension, as every function is called from the Backend Object.
        </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-driver-code"></a>Code Example:</h6></div></div></div><p>
            In this section the <code class="literal">Foo</code> extension for Text field driver is shown and explained. The
            extension only implements the function <code class="code">Foo()</code>.
         </p><p>
            </p><pre class="programlisting">
# --
# Kernel/System/DynamicField/Driver/FooExtensionText.pm - Extension for DynamicField Text Driver
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::DynamicField::Driver::FooExtensionText;

use strict;
use warnings;

=head1 NAME

Kernel::System::DynamicField::Driver::FooExtensionText

=head1 SYNOPSIS

DynamicFields Text Driver Extension

=head1 PUBLIC INTERFACE

This module extends the public interface of L&lt;Kernel::System::DynamicField::Backend&gt;.
Please look there for a detailed reference of the functions.

=over 4

=cut
            </pre><p>
        </p><p>
            This is common header that can be found in common OTRS modules. The class/package
            name is declared via the <code class="literal">package</code> keyword.
        </p><p>
            </p><pre class="programlisting">
sub Foo {
    my ( $Self, %Param ) = @_;
    return 1;
}
            </pre><p>
        </p><p>
            The function <code class="code">Foo()</code> has no special logic. It is only for testing and
            it always returns 1.
        </p></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="email-handling-modules"></a>Email Handling</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ticket-postmaster-module"></a>Ticket PostMaster Module</h4></div></div></div><p>
        PostMaster modules are used during the PostMaster process.
        There are two kinds of PostMaster modules: <code class="literal">PostMasterPre</code> (used after parsing an email)
        and <code class="literal">PostMasterPost</code> (used after an email is processed and is in the database).
    </p><p>
        If you want to create your own postmaster filter, just create your own module.
        These modules are located under <code class="filename">Kernel/System/PostMaster/Filter/*.pm</code>.
        For default modules see the admin manual. You just need two functions:
        <code class="code">new()</code> and <code class="code">Run()</code>.
    </p><p>
        The following is an exemplary module to match emails and set X-OTRS-Headers
        (see <code class="filename">doc/X-OTRS-Headers.txt</code> for more info).
    </p><p>
        <code class="filename">Kernel/Config/Files/MyModule.xml</code>:
    </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="PostMaster::PreFilterModule###1-Example" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Example module to filter and manipulate incoming messages.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Core::PostMaster&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::System::PostMaster::Filter::Example&lt;/Item&gt;
            &lt;Item Key="Match"&gt;
                &lt;Hash&gt;
                    &lt;Item Key="From"&gt;noreply@&lt;/Item&gt;
                &lt;/Hash&gt;
            &lt;/Item&gt;
            &lt;Item Key="Set"&gt;
                &lt;Hash&gt;
                    &lt;Item Key="X-OTRS-Ignore"&gt;yes&lt;/Item&gt;
                &lt;/Hash&gt;
            &lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
    </p><p>
        And the actual filter code in <code class="filename">Kernel/System/PostMaster/Filter/Example.pm</code>:
    </p><p>
        </p><pre class="programlisting">
# --
# Copyright (C) 2001-2020 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::PostMaster::Filter::Example;

use strict;
use warnings;

our @ObjectDependencies = (
    'Kernel::System::Log',
);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless ($Self, $Type);

    $Self-&gt;{Debug} = $Param{Debug} || 0;

    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;
    # get config options
    my %Config = ();
    my %Match = ();
    my %Set = ();
    if ($Param{JobConfig} &amp;&amp; ref($Param{JobConfig}) eq 'HASH') {
        %Config = %{$Param{JobConfig}};
        if ($Config{Match}) {
            %Match = %{$Config{Match}};
        }
        if ($Config{Set}) {
            %Set = %{$Config{Set}};
        }
        }
        # match 'Match =&gt; ???' stuff
        my $Matched = '';
        my $MatchedNot = 0;
        for (sort keys %Match) {
        if ($Param{GetParam}-&gt;{$_} &amp;&amp; $Param{GetParam}-&gt;{$_} =~ /$Match{$_}/i) {
            $Matched = $1 || '1';
            if ($Self-&gt;{Debug} &gt; 1) {
                $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
                    Priority =&gt; 'debug',
                    Message =&gt; "'$Param{GetParam}-&gt;{$_}' =~ /$Match{$_}/i matched!",
                );
            }
        }
        else {
            $MatchedNot = 1;
            if ($Self-&gt;{Debug} &gt; 1) {
                $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
                    Priority =&gt; 'debug',
                    Message =&gt; "'$Param{GetParam}-&gt;{$_}' =~ /$Match{$_}/i matched NOT!",
                );
            }
        }
        }
        # should I ignore the incoming mail?
        if ($Matched &amp;&amp; !$MatchedNot) {
        for (keys %Set) {
            if ($Set{$_} =~ /\[\*\*\*\]/i) {
                $Set{$_} = $Matched;
            }
            $Param{GetParam}-&gt;{$_} = $Set{$_};
            $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
                Priority =&gt; 'notice',
                Message =&gt; "Set param '$_' to '$Set{$_}' (Message-ID: $Param{GetParam}-&gt;{'Message-ID'}) ",
            );
        }
    }

    return 1;
}

1;
        </pre><p>
    </p><p>
        The following image shows you the email processing flow.
    </p><p>
        </p><div class="figure"><a name="id-1.4.3.10.2.10.1"></a><p class="title"><b>Figure 3.4. Email Processing Flow</b></p><div class="figure-contents"><div class="screenshot"><div><img src="screenshots/email-processing.png" alt="Email Processing Flow"></div></div></div></div><p><br class="figure-break">
    </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="how-to-extend-otrs.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="how-to-extend-otrs.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="how-to-publish-extensions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. How to Extend OTRS </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 4. How to Publish Your OTRS Extensions</td></tr></table></div></body></html>
